/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/assert/build/assert.js":
/*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(/*! ./internal/errors */ "./node_modules/assert/build/internal/errors.js"),
    _require$codes = _require.codes,
    ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
    ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;

var AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ "./node_modules/assert/build/internal/assert/assertion_error.js");

var _require2 = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require2.inspect;

var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/util/util.js").types),
    isPromise = _require$types.isPromise,
    isRegExp = _require$types.isRegExp;

var objectAssign = Object.assign ? Object.assign : (__webpack_require__(/*! es6-object-assign */ "./node_modules/es6-object-assign/index.js").assign);
var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;

function lazyLoadComparison() {
  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ "./node_modules/assert/build/internal/util/comparisons.js");

  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex


var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];

var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};

var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}

function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;

  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }

    if (argsLen === 2) operator = '!=';
  }

  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };

  if (message !== undefined) {
    errArgs.message = message;
  }

  var err = new AssertionError(errArgs);

  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }

  throw err;
}

assert.fail = fail; // The AssertionError is defined in internal/error.

assert.AssertionError = AssertionError;

function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }

    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.


function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  innerOk.apply(void 0, [ok, args.length].concat(args));
}

assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.

/* eslint-disable no-restricted-properties */

assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.


assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
}; // The equivalence assertion tests a deep equality relation.


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
}; // The non-equivalence assertion tests for any deep inequality.


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */


assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};

var Comparison = function Comparison(obj, keys, actual) {
  var _this = this;

  _classCallCheck(this, Comparison);

  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
};

function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }

    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}

function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.

    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    } // Handle primitives properly.


    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }

    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
    // as well.

    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }

    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
        return;
      }

      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  } // Guard instanceof against arrow functions as they don't have a prototype.


  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION_SENTINEL;
}

function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.
  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}

function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;

    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn(); // Fail in case no promise is returned.

      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }

    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}

function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }

    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }

    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }

  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';

    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }

    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }

  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}

function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }

  throw actual;
}

assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};

assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};

assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};

assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};

assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';

    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }

    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    }); // Make sure we actually have a stack trace!

    var origStack = err.stack;

    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift(); // Filter all frames existing in err.stack.

      var tmp1 = newErr.stack.split('\n');

      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);

        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }

      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }

    throw newErr;
  }
}; // Expose a strict only variant of assert


function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  innerOk.apply(void 0, [strict, args.length].concat(args));
}

assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ "./node_modules/assert/build/internal/assert/assertion_error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require.inspect;

var _require2 = __webpack_require__(/*! ../errors */ "./node_modules/assert/build/internal/errors.js"),
    ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat


function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));

  while (count) {
    str += str;
    count--;
  }

  str += str.substring(0, maxCount - str.length);
  return str;
}

var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.

var kMaxShortLength = 10;

function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}

function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}

function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.

  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  } // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.


  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.

    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;

      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        } // Ignore the first characters.


        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  } // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).


  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];

  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }

    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }

  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.


    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);

      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }

    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }

  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }

  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }

  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");

  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;

    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the expected line to the cache.

      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++; // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the actual line to the result.

      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++; // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.

      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //

      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }

      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }

          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        } // Mark the current line as the last diverging one.


        lastPos = i; // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.

        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2; // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = ''; // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.

        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    } // Inspected object to big (Show ~20 rows max)


    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }

  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}

var AssertionError =
/*#__PURE__*/
function (_Error) {
  _inherits(AssertionError, _Error);

  function AssertionError(options) {
    var _this;

    _classCallCheck(this, AssertionError);

    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    var message = options.message,
        operator = options.operator,
        stackStartFn = options.stackStartFn;
    var actual = options.actual,
        expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;

    if (message != null) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      } // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.


      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }

      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.

        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        } // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.


        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);

          while (res.length > 27) {
            res.pop();
          }
        } // Only print a single input.


        if (res.length === 1) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
        }
      } else {
        var _res = inspectValue(actual);

        var other = '';
        var knownOperators = kReadableOperator[operator];

        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);

          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));

          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }

          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }

          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
      }
    }

    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;

    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    } // Create error message including the error code in the name.


    _this.stack; // Reset the name.

    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }

  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: inspect.custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);

  return AssertionError;
}(_wrapNativeSuper(Error));

module.exports = AssertionError;

/***/ }),

/***/ "./node_modules/assert/build/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */

/* eslint node-core/alphabetize-errors: "error" */

/* eslint node-core/prefer-util-format-errors: "error" */
 // The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var codes = {}; // Lazy loaded

var assert;
var util;

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inherits(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      var _this;

      _classCallCheck(this, NodeError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code;
      return _this;
    }

    return NodeError;
  }(Base);

  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'

  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(/*! util/ */ "./node_modules/util/util.js");
  var inspected = util.inspect(value);

  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }

  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;

  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }

  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });

  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;

    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;

    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }

  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/assert/build/internal/util/comparisons.js":
/*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var regexFlagsSupported = /a/g.flags !== undefined;

var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};

var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};

var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ "./node_modules/is-nan/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);

var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/util/util.js").types),
    isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
    isArrayBufferView = _require$types.isArrayBufferView,
    isDate = _require$types.isDate,
    isMap = _require$types.isMap,
    isRegExp = _require$types.isRegExp,
    isSet = _require$types.isSet,
    isNativeError = _require$types.isNativeError,
    isBoxedPrimitive = _require$types.isBoxedPrimitive,
    isNumberObject = _require$types.isNumberObject,
    isStringObject = _require$types.isStringObject,
    isBooleanObject = _require$types.isBooleanObject,
    isBigIntObject = _require$types.isBigIntObject,
    isSymbolObject = _require$types.isSymbolObject,
    isFloat32Array = _require$types.isFloat32Array,
    isFloat64Array = _require$types.isFloat64Array;

function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;

  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  } // The maximum size for an array is 2 ** 32 -1.


  return key.length === 10 && key >= Math.pow(2, 32);
}

function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags

function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}

function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }

  return true;
}

function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}

function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}

function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }

  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }

  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }

  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }

  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.


function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  } // Check more closely if val1 and val2 are equal.


  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }

    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }

    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }

      return false;
    }

    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }

  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);

  if (val1Tag !== val2Tag) {
    return false;
  }

  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }

    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (keys1.length !== keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.


  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }

  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    } // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.


    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);

    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (_keys.length !== _keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }

  return keyCheck(val1, val2, strict, memos, kNoIterator);
}

function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}

function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.

    if (aKeys.length !== bKeys.length) {
      return false;
    }
  } // Cheap key test


  var i = 0;

  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }

  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);

    if (symbolKeysA.length !== 0) {
      var count = 0;

      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];

        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }

          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }

      var symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }

  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  } // Use memos to handle cycles.


  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);

    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);

      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }

    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}

function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];

    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }

  return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').


function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;

    case 'object':
      // Only pass in null as object!
      return undefined;

    case 'symbol':
      return false;

    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through

    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }

  }

  return true;
}

function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}

function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null) {
    return altValue;
  }

  var curB = b.get(altValue);

  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }

  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}

function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);

  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.

    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      } // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.


      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.

      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }

      if (set === null) {
        set = new Set();
      }

      set.add(val);
    }
  }

  if (set !== null) {
    var bValues = arrayFromSet(b);

    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i]; // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.

      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];

    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }

  return false;
}

function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);

  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
        key = _aEntries$i[0],
        item1 = _aEntries$i[1];

    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }

      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);

      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
        // keys.

        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;

        if (set === null) {
          set = new Set();
        }

        set.add(key);
      }
    }
  }

  if (set !== null) {
    var bEntries = arrayFromMap(b);

    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
          key = _bEntries$_i[0],
          item = _bEntries$_i[1];

      if (_typeof(key) === 'object' && key !== null) {
        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;

  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);

        for (; i < keysA.length; i++) {
          var key = keysA[i];

          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }

        if (keysA.length !== Object.keys(b).length) {
          return false;
        }

        return true;
      }
    }
  } // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:


  for (i = 0; i < keys.length; i++) {
    var _key = keys[i];

    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
      return false;
    }
  }

  return true;
}

function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}

function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}

module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/console-browserify/index.js":
/*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*global window, global*/
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")
var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js")
function now() { return new Date().getTime() }

var slice = Array.prototype.slice
var console
var times = {}

if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.console) {
    console = __webpack_require__.g.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    delete times[label]
    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}


/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var hasPropertyDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();

var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value; // eslint-disable-line no-param-reassign
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/es6-object-assign/index.js":
/*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */



function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}

module.exports = {
  assign: assign,
  polyfill: polyfill
};


/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/is-callable/index.js");

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

try {
	null.error; // eslint-disable-line no-unused-expressions
} catch (e) {
	// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
	var errorProto = getProto(getProto(e));
	INTRINSICS['%Error.prototype%'] = errorProto;
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/inputmask/lib/canUseDOM.js":
/*!*************************************************!*\
  !*** ./node_modules/inputmask/lib/canUseDOM.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const canUseDOM = !!(
  typeof window !== "undefined" &&
  window.document &&
  window.document.createElement
);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (canUseDOM);


/***/ }),

/***/ "./node_modules/inputmask/lib/defaults.js":
/*!************************************************!*\
  !*** ./node_modules/inputmask/lib/defaults.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _keycode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keycode.js */ "./node_modules/inputmask/lib/keycode.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
	_maxTestPos: 500,
	placeholder: "_",
	optionalmarker: ["[", "]"],
	quantifiermarker: ["{", "}"],
	groupmarker: ["(", ")"],
	alternatormarker: "|",
	escapeChar: "\\",
	mask: null, //needs tobe null instead of undefined as the extend method does not consider props with the undefined value
	regex: null, //regular expression as a mask
	oncomplete: () => {
	}, //executes when the mask is complete
	onincomplete: () => {
	}, //executes when the mask is incomplete and focus is lost
	oncleared: () => {
	}, //executes when the mask is cleared
	repeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer
	greedy: false, //true: allocated buffer for the mask and repetitions - false: allocate only if needed
	autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor
	removeMaskOnSubmit: false, //remove the mask before submitting the form.
	clearMaskOnLostFocus: true,
	insertMode: true, //insert the input or overwrite the input
	insertModeVisual: true, //show selected caret when insertmode = false
	clearIncomplete: false, //clear the incomplete input on blur
	alias: null,
	onKeyDown: () => {
	}, //callback to implement autocomplete on certain keys for example. args => event, buffer, caretPos, opts
	onBeforeMask: null, //executes before masking the initial value to allow preprocessing of the initial value.	args => initialValue, opts => return processedValue
	onBeforePaste: function (pastedValue, opts) {
		return typeof opts.onBeforeMask === "function" ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;
	}, //executes before masking the pasted value to allow preprocessing of the pasted value.	args => pastedValue, opts => return processedValue
	onBeforeWrite: null, //executes before writing to the masked element. args => event, opts
	onUnMask: null, //executes after unmasking to allow postprocessing of the unmaskedvalue.	args => maskedValue, unmaskedValue, opts
	showMaskOnFocus: true, //show the mask-placeholder when the input has focus
	showMaskOnHover: true, //show the mask-placeholder when hovering the empty input
	onKeyValidation: () => {
	}, //executes on every key-press with the result of isValid. Params: key, result, opts
	skipOptionalPartCharacter: " ", //a character which can be used to skip an optional part of a mask
	numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)
	rightAlign: false, //align to the right
	undoOnEscape: true, //pressing escape reverts the value to the value before focus
	//numeric basic properties
	radixPoint: "", //".", // | ","
	_radixDance: false, //dance around the radixPoint
	groupSeparator: "", //",", // | "."
	//numeric basic properties
	keepStatic: null, //try to keep the mask static while typing. Decisions to alter the mask will be posponed if possible
	positionCaretOnTab: true, //when enabled the caret position is set after the latest valid position on TAB
	tabThrough: false, //allows for tabbing through the different parts of the masked field
	supportsInputType: ["text", "tel", "url", "password", "search"], //list with the supported input types
	//specify keyCodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF
	ignorables: [
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Backspace,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Tab,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Pause,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Escape,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.PageUp,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.PageDown,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.End,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Home,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.ArrowLeft,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.ArrowUp,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.ArrowRight,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.ArrowDown,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Insert,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Delete,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.ContextMenu,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F1,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F2,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F3,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F4,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F5,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F6,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F7,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F8,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F9,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F10,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F11,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.F12,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Process,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Unidentified,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Shift,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Control,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Alt,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Tab,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.AltGraph,
		_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.CapsLock
	],
	isComplete: null, //override for isComplete - args => buffer, opts - return true || false
	preValidation: null, //hook to preValidate the input.  Usefull for validating regardless the definition.	args => buffer, pos, char, isSelection, opts, maskset, caretPos, strict => return true/false/command object
	postValidation: null, //hook to postValidate the result from isValid.	Usefull for validating the entry as a whole.	args => buffer, pos, c, currentResult, opts, maskset, strict, fromCheckval => return true/false/json
	staticDefinitionSymbol: undefined, //specify a definitionSymbol for static content, used to make matches for alternators
	jitMasking: false, //just in time masking ~ only mask while typing, can n (number), true or false
	nullable: true, //return nothing instead of the buffertemplate when the user hasn't entered anything.
	inputEventOnly: false, //dev option - testing inputfallback behavior
	noValuePatching: false, //disable value property patching
	positionCaretOnClick: "lvp", //none, lvp (based on the last valid position (default), radixFocus (position caret to radixpoint on initial click), select (select the whole input), ignore (ignore the click and continue the mask)
	casing: null, //mask-level casing. Options: null, "upper", "lower" or "title" or callback args => elem, test, pos, validPositions return charValue
	inputmode: "text", //specify the inputmode
	importDataAttributes: true, //import data-inputmask attributes
	shiftPositions: true, //shift position of the mask entries on entry and deletion.
	usePrototypeDefinitions: true, //use the default defined definitions from the prototype
	validationEventTimeOut: 3000, //Time to show validation error on form submit
	substitutes: {} //define character substitutes
});


/***/ }),

/***/ "./node_modules/inputmask/lib/definitions.js":
/*!***************************************************!*\
  !*** ./node_modules/inputmask/lib/definitions.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
	"9": { //\uFF11-\uFF19 #1606
		validator: "[0-9\uFF10-\uFF19]",
		definitionSymbol: "*"
	},
	"a": { //\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5 #76
		validator: "[A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
		definitionSymbol: "*"
	},
	"*": {
		validator: "[0-9\uFF10-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]"
	}
});

/***/ }),

/***/ "./node_modules/inputmask/lib/dependencyLibs/data.js":
/*!***********************************************************!*\
  !*** ./node_modules/inputmask/lib/dependencyLibs/data.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(owner, key, value) {
	if (value === undefined) {
		return owner.__data ? owner.__data[key] : null;
	} else {
		owner.__data = owner.__data || {};
		owner.__data[key] = value;
	}
}

/***/ }),

/***/ "./node_modules/inputmask/lib/dependencyLibs/events.js":
/*!*************************************************************!*\
  !*** ./node_modules/inputmask/lib/dependencyLibs/events.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": () => (/* binding */ Event),
/* harmony export */   "off": () => (/* binding */ off),
/* harmony export */   "on": () => (/* binding */ on),
/* harmony export */   "trigger": () => (/* binding */ trigger)
/* harmony export */ });
/* harmony import */ var _extend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extend */ "./node_modules/inputmask/lib/dependencyLibs/extend.js");
/* harmony import */ var _global_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global/window */ "./node_modules/inputmask/lib/global/window.js");
/* harmony import */ var _inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inputmask.dependencyLib */ "./node_modules/inputmask/lib/dependencyLibs/inputmask.dependencyLib.js");
/* harmony import */ var _canUseDOM__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../canUseDOM */ "./node_modules/inputmask/lib/canUseDOM.js");







function isValidElement(elem) {
	return elem instanceof Element;
}

let Event;
if (typeof _global_window__WEBPACK_IMPORTED_MODULE_1__["default"].CustomEvent === "function") {
	Event = _global_window__WEBPACK_IMPORTED_MODULE_1__["default"].CustomEvent;
} else {
	if (_canUseDOM__WEBPACK_IMPORTED_MODULE_3__["default"]) {
		Event = function (event, params) {
			params = params || {bubbles: false, cancelable: false, composed: true, detail: undefined};
			var evt = document.createEvent("CustomEvent");
			evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
			return evt;
		};
		Event.prototype = _global_window__WEBPACK_IMPORTED_MODULE_1__["default"].Event.prototype;
	}
}


function on(events, handler) {
	function addEvent(ev, namespace) {
		//register domevent
		if (elem.addEventListener) { // all browsers except IE before version 9
			elem.addEventListener(ev, handler, false);
		} else if (elem.attachEvent) { // IE before version 9
			elem.attachEvent(`on${ev}`, handler);
		}
		eventRegistry[ev] = eventRegistry[ev] || {};
		eventRegistry[ev][namespace] = eventRegistry[ev][namespace] || [];
		eventRegistry[ev][namespace].push(handler);
	}

	if (isValidElement(this[0])) {
		var eventRegistry = this[0].eventRegistry,
			elem = this[0];

		events.split(" ").forEach((event) => {
			const [ev, namespace = "global"] = event.split(".");
			addEvent(ev, namespace);
		});
	}
	return this;
}

function off(events, handler) {
	var eventRegistry, elem;

	function removeEvent(ev, namespace, handler) {
		if (ev in eventRegistry === true) {
			//unbind to dom events
			if (elem.removeEventListener) { // all browsers except IE before version 9
				elem.removeEventListener(ev, handler, false);
			} else if (elem.detachEvent) { // IE before version 9
				elem.detachEvent(`on${ev}`, handler);
			}
			if (namespace === "global") {
				for (var nmsp in eventRegistry[ev]) {
					eventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1);
				}
			} else {
				eventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1);
			}
		}
	}

	function resolveNamespace(ev, namespace) {
		var evts = [],
			hndx, hndL;
		if (ev.length > 0) {
			if (handler === undefined) {
				for (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++) {
					evts.push({
						ev: ev,
						namespace: namespace && namespace.length > 0 ? namespace : "global",
						handler: eventRegistry[ev][namespace][hndx]
					});
				}
			} else {
				evts.push({
					ev: ev,
					namespace: namespace && namespace.length > 0 ? namespace : "global",
					handler: handler
				});
			}
		} else if (namespace.length > 0) {
			for (var evNdx in eventRegistry) {
				for (var nmsp in eventRegistry[evNdx]) {
					if (nmsp === namespace) {
						if (handler === undefined) {
							for (hndx = 0, hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++) {
								evts.push({
									ev: evNdx,
									namespace: nmsp,
									handler: eventRegistry[evNdx][nmsp][hndx]
								});
							}
						} else {
							evts.push({
								ev: evNdx,
								namespace: nmsp,
								handler: handler
							});
						}
					}
				}
			}
		}

		return evts;
	}

	if (isValidElement(this[0]) && events) {
		eventRegistry = this[0].eventRegistry;
		elem = this[0];

		events.split(" ").forEach((event) => {
			const [ev, namespace] = event.split(".");
			resolveNamespace(ev, namespace).forEach(({ev: ev1, handler: handler1, namespace: namespace1}) => {
				removeEvent(ev1, namespace1, handler1);
			});
		});
	}
	return this;
}

function trigger(events /* , args... */) {
	if (isValidElement(this[0])) {
		var eventRegistry = this[0].eventRegistry,
			elem = this[0];
		var _events = typeof events === "string" ? events.split(" ") : [events.type];
		for (var endx = 0; endx < _events.length; endx++) {
			var nsEvent = _events[endx].split("."),
				ev = nsEvent[0],
				namespace = nsEvent[1] || "global";
			if (document !== undefined && namespace === "global") {
				//trigger domevent
				var evnt, i, params = {
					bubbles: true,
					cancelable: true,
					composed: true,
					detail: arguments[1]
				};
				// The custom event that will be created
				if (document.createEvent) {
					try {
						switch (ev) {
							case "input":
								params.inputType = "insertText";
								evnt = new InputEvent(ev, params);
								break;
							default:
								evnt = new CustomEvent(ev, params);
						}
					} catch (e) {
						evnt = document.createEvent("CustomEvent");
						evnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail);
					}
					if (events.type) (0,_extend__WEBPACK_IMPORTED_MODULE_0__["default"])(evnt, events);
					elem.dispatchEvent(evnt);
				} else {
					evnt = document.createEventObject();
					evnt.eventType = ev;
					evnt.detail = arguments[1];
					if (events.type) (0,_extend__WEBPACK_IMPORTED_MODULE_0__["default"])(evnt, events);
					elem.fireEvent("on" + evnt.eventType, evnt);
				}
			} else if (eventRegistry[ev] !== undefined) {
				arguments[0] = arguments[0].type ? arguments[0] : _inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_2__["default"].Event(arguments[0]);
				arguments[0].detail = arguments.slice(1);

				const registry = eventRegistry[ev],
					handlers = namespace === "global" ? Object.values(registry).flat() : registry[namespace];
				handlers.forEach(handler => handler.apply(elem, arguments));
			}
		}
	}
	return this;
}


/***/ }),

/***/ "./node_modules/inputmask/lib/dependencyLibs/extend.js":
/*!*************************************************************!*\
  !*** ./node_modules/inputmask/lib/dependencyLibs/extend.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ extend)
/* harmony export */ });
function extend() {
	let options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === "boolean") {
		deep = target;

		// Skip the boolean and the target
		target = arguments[i] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if (typeof target !== "object" && typeof target !== "function") {
		target = {};
	}

	for (; i < length; i++) {
		// Only deal with non-null/undefined values
		if ((options = arguments[i]) != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (Object.prototype.toString.call(copy) === "[object Object]" || (copyIsArray = Array.isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && Array.isArray(src) ? src : [];

					} else {
						clone = src && Object.prototype.toString.call(src) === "[object Object]" ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

					// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
}

/***/ }),

/***/ "./node_modules/inputmask/lib/dependencyLibs/inputmask.dependencyLib.js":
/*!******************************************************************************!*\
  !*** ./node_modules/inputmask/lib/dependencyLibs/inputmask.dependencyLib.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _extend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extend */ "./node_modules/inputmask/lib/dependencyLibs/extend.js");
/* harmony import */ var _global_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global/window */ "./node_modules/inputmask/lib/global/window.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data */ "./node_modules/inputmask/lib/dependencyLibs/data.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events */ "./node_modules/inputmask/lib/dependencyLibs/events.js");
/*
 Input Mask plugin dependencyLib
 http://github.com/RobinHerbots/jquery.inputmask
 Copyright (c) Robin Herbots
 Licensed under the MIT license
 */






const document = _global_window__WEBPACK_IMPORTED_MODULE_1__["default"].document;

function DependencyLib(elem) {
	if (elem instanceof DependencyLib) {
		return elem;
	}
	if (!(this instanceof DependencyLib)) {
		return new DependencyLib(elem);
	}
	if (elem !== undefined && elem !== null && elem !== _global_window__WEBPACK_IMPORTED_MODULE_1__["default"]) {
		this[0] = elem.nodeName ? elem : (elem[0] !== undefined && elem[0].nodeName ? elem[0] : document.querySelector(elem));
		if (this[0] !== undefined && this[0] !== null) {
			this[0].eventRegistry = this[0].eventRegistry || {};
		}
	}
}

DependencyLib.prototype = {
	on: _events__WEBPACK_IMPORTED_MODULE_3__.on,
	off: _events__WEBPACK_IMPORTED_MODULE_3__.off,
	trigger: _events__WEBPACK_IMPORTED_MODULE_3__.trigger
};

//static
DependencyLib.extend = _extend__WEBPACK_IMPORTED_MODULE_0__["default"];
DependencyLib.data = _data__WEBPACK_IMPORTED_MODULE_2__["default"];
DependencyLib.Event = _events__WEBPACK_IMPORTED_MODULE_3__.Event;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DependencyLib);


/***/ }),

/***/ "./node_modules/inputmask/lib/environment.js":
/*!***************************************************!*\
  !*** ./node_modules/inputmask/lib/environment.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ie": () => (/* binding */ ie),
/* harmony export */   "iphone": () => (/* binding */ iphone),
/* harmony export */   "mobile": () => (/* binding */ mobile)
/* harmony export */ });
/* harmony import */ var _global_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global/window */ "./node_modules/inputmask/lib/global/window.js");


const ua = (_global_window__WEBPACK_IMPORTED_MODULE_0__["default"].navigator && _global_window__WEBPACK_IMPORTED_MODULE_0__["default"].navigator.userAgent) || "",
    ie = (ua.indexOf("MSIE ") > 0) || (ua.indexOf("Trident/") > 0),
    mobile = (navigator.userAgentData && navigator.userAgentData.mobile) || (_global_window__WEBPACK_IMPORTED_MODULE_0__["default"].navigator && _global_window__WEBPACK_IMPORTED_MODULE_0__["default"].navigator.maxTouchPoints) || "ontouchstart" in _global_window__WEBPACK_IMPORTED_MODULE_0__["default"], //not entirely correct but will currently do
    iphone = /iphone/i.test(ua);




/***/ }),

/***/ "./node_modules/inputmask/lib/escapeRegex.js":
/*!***************************************************!*\
  !*** ./node_modules/inputmask/lib/escapeRegex.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const  escapeRegexRegex = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim");
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(str) {
	return str.replace(escapeRegexRegex, "\\$1");
}

/***/ }),

/***/ "./node_modules/inputmask/lib/eventhandlers.js":
/*!*****************************************************!*\
  !*** ./node_modules/inputmask/lib/eventhandlers.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventHandlers": () => (/* binding */ EventHandlers)
/* harmony export */ });
/* harmony import */ var _positioning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./positioning */ "./node_modules/inputmask/lib/positioning.js");
/* harmony import */ var _keycode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keycode.js */ "./node_modules/inputmask/lib/keycode.js");
/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./environment */ "./node_modules/inputmask/lib/environment.js");
/* harmony import */ var _validation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./validation */ "./node_modules/inputmask/lib/validation.js");
/* harmony import */ var _inputHandling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inputHandling */ "./node_modules/inputmask/lib/inputHandling.js");
/* harmony import */ var _validation_tests__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./validation-tests */ "./node_modules/inputmask/lib/validation-tests.js");









var EventHandlers = {
    keyEvent: function (e, checkval, writeOut, strict, ndx) {
        const inputmask = this.inputmask, opts = inputmask.opts, $ = inputmask.dependencyLib,
            maskset = inputmask.maskset;

        var input = this,
            $input = $(input),
            c = e.key,
            pos = _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input);

        var kdResult = opts.onKeyDown.call(this, e, _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask), pos, opts);
        if (kdResult !== undefined) return kdResult;

        //backspace, delete, and escape get special treatment
        if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Backspace || c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Delete || (_environment__WEBPACK_IMPORTED_MODULE_2__.iphone && c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.BACKSPACE_SAFARI) || (e.ctrlKey && c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.x && !("oncut" in input))) { //backspace/delete
            e.preventDefault(); //stop default action but allow propagation
            _validation__WEBPACK_IMPORTED_MODULE_3__.handleRemove.call(inputmask, input, c, pos);
            (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.writeBuffer)(input, _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask, true), maskset.p, e, input.inputmask._valueGet() !== _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask).join(""));
        } else if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.End || c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.PageDown) { //when END or PAGE_DOWN pressed set position at lastmatch
            e.preventDefault();
            var caretPos = _positioning__WEBPACK_IMPORTED_MODULE_0__.seekNext.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_0__.getLastValidPosition.call(inputmask));
            _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, e.shiftKey ? pos.begin : caretPos, caretPos, true);
        } else if ((c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Home && !e.shiftKey) || c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.PageUp) { //Home or page_up
            e.preventDefault();
            _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, 0, e.shiftKey ? pos.begin : 0, true);
        } else if (((opts.undoOnEscape && c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Escape) || ( false && 0)) && e.altKey !== true) { //escape && undo && #762
            (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.checkVal)(input, true, false, inputmask.undoValue.split(""));
            $input.trigger("click");
        } else if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Insert && !(e.shiftKey || e.ctrlKey) && inputmask.userOptions.insertMode === undefined) { //insert
            if (!_validation__WEBPACK_IMPORTED_MODULE_3__.isSelection.call(inputmask, pos)) {
                opts.insertMode = !opts.insertMode;
                _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, pos.begin, pos.begin);
            } else opts.insertMode = !opts.insertMode;
        } else if (opts.tabThrough === true && c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Tab) {
            if (e.shiftKey === true) {
                pos.end = _positioning__WEBPACK_IMPORTED_MODULE_0__.seekPrevious.call(inputmask, pos.end, true);
                if (_validation_tests__WEBPACK_IMPORTED_MODULE_5__.getTest.call(inputmask, pos.end - 1).match.static === true) {
                    pos.end--;
                }
                pos.begin = _positioning__WEBPACK_IMPORTED_MODULE_0__.seekPrevious.call(inputmask, pos.end, true);
                if (pos.begin >= 0 && pos.end > 0) {
                    e.preventDefault();
                    _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, pos.begin, pos.end);
                }
            } else {
                pos.begin = _positioning__WEBPACK_IMPORTED_MODULE_0__.seekNext.call(inputmask, pos.begin, true);
                pos.end = _positioning__WEBPACK_IMPORTED_MODULE_0__.seekNext.call(inputmask, pos.begin, true);
                if (pos.end < maskset.maskLength) pos.end--;
                if (pos.begin <= maskset.maskLength) {
                    e.preventDefault();
                    _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, pos.begin, pos.end);
                }
            }
        } else if (!e.shiftKey) {
            if (opts.insertModeVisual && opts.insertMode === false) {
                if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.ArrowRight) {
                    setTimeout(function () {
                        var caretPos = _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input);
                        _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, caretPos.begin);
                    }, 0);
                } else if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.ArrowLeft) {
                    setTimeout(function () {
                        var caretPos = {
                            begin: _positioning__WEBPACK_IMPORTED_MODULE_0__.translatePosition.call(inputmask, input.inputmask.caretPos.begin),
                            end: _positioning__WEBPACK_IMPORTED_MODULE_0__.translatePosition.call(inputmask, input.inputmask.caretPos.end)
                        };
                        if (inputmask.isRTL) {
                            _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, caretPos.begin + (caretPos.begin === maskset.maskLength ? 0 : 1));
                        } else {
                            _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, caretPos.begin - (caretPos.begin === 0 ? 0 : 1));
                        }
                    }, 0);
                }
            }
        }

        inputmask.isComposing = (c == _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Process || c == _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Unidentified);
        inputmask.ignorable = opts.ignorables.includes(c);
        return EventHandlers.keypressEvent.call(this, e, checkval, writeOut, strict, ndx);
    },
    keypressEvent: function (e, checkval, writeOut, strict, ndx) {
        const inputmask = this.inputmask || this, opts = inputmask.opts, $ = inputmask.dependencyLib,
            maskset = inputmask.maskset;

        var input = inputmask.el,
            $input = $(input),
            c = e.key;

        if (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || inputmask.ignorable))) {
            if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Enter) {
                if (inputmask.undoValue !== inputmask._valueGet(true)) {
                    inputmask.undoValue = inputmask._valueGet(true);
                    // e.preventDefault();

                    setTimeout(function () {
                        $input.trigger("change");
                    }, 0);
                }
            }
            //inputmask.skipInputEvent = true; //skip the input as otherwise the skipped char could be picked up for validation by the inputfallback
            return;
        } else if (c) {
            //special treat the decimal separator
            // if ((k === 44 || k === 46) && e.location === 3 && opts.radixPoint !== "") k = opts.radixPoint.charCodeAt(0);
            var pos = checkval ? {
                    begin: ndx,
                    end: ndx
                } : _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input),
                forwardPosition;

            //allow for character substitution
            c = opts.substitutes[c] || c;
            maskset.writeOutBuffer = true;
            var valResult = _validation__WEBPACK_IMPORTED_MODULE_3__.isValid.call(inputmask, pos, c, strict, undefined, undefined, undefined, checkval);
            if (valResult !== false) {
                _positioning__WEBPACK_IMPORTED_MODULE_0__.resetMaskSet.call(inputmask, true);
                forwardPosition = valResult.caret !== undefined ? valResult.caret : _positioning__WEBPACK_IMPORTED_MODULE_0__.seekNext.call(inputmask, valResult.pos.begin ? valResult.pos.begin : valResult.pos);
                maskset.p = forwardPosition; //needed for checkval
            }

            forwardPosition = ((opts.numericInput && valResult.caret === undefined) ? _positioning__WEBPACK_IMPORTED_MODULE_0__.seekPrevious.call(inputmask, forwardPosition) : forwardPosition);
            if (writeOut !== false) {

                setTimeout(function () {
                    opts.onKeyValidation.call(input, c, valResult);
                }, 0);
                if (maskset.writeOutBuffer && valResult !== false) {
                    var buffer = _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask);
                    (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.writeBuffer)(input, buffer, forwardPosition, e, checkval !== true);
                }
            }

            e.preventDefault();

            if (checkval) {
                if (valResult !== false) valResult.forwardPosition = forwardPosition;
                return valResult;
            }
        }
    },
    pasteEvent: function (e) {
        const inputmask = this.inputmask, opts = inputmask.opts;

        var input = this,
            inputValue = inputmask._valueGet(true),
            caretPos = _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input),
            tempValue;

        if (inputmask.isRTL) {
            tempValue = caretPos.end;
            caretPos.end = _positioning__WEBPACK_IMPORTED_MODULE_0__.translatePosition.call(inputmask, caretPos.begin);
            caretPos.begin = _positioning__WEBPACK_IMPORTED_MODULE_0__.translatePosition.call(inputmask, tempValue);
        }

        var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
            valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);

        if (valueBeforeCaret == (inputmask.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask).slice().reverse() : _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask)).slice(0, caretPos.begin).join("")) valueBeforeCaret = "";
        if (valueAfterCaret == (inputmask.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask).slice().reverse() : _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask)).slice(caretPos.end).join("")) valueAfterCaret = "";

        if (window.clipboardData && window.clipboardData.getData) { // IE
            inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret;
        } else if (e.clipboardData && e.clipboardData.getData) {
            inputValue = valueBeforeCaret + e.clipboardData.getData("text/plain") + valueAfterCaret;
        } else {
            return true;
        } //allow native paste event as fallback ~ masking will continue by inputfallback

        var pasteValue = inputValue;
        if (inputmask.isRTL) {
            pasteValue = pasteValue.split("");
            for (let c of _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask)) {
                if (pasteValue[0] === c)
                    pasteValue.shift();
            }
            pasteValue = pasteValue.join("");
        }
        if (typeof opts.onBeforePaste === "function") {
            pasteValue = opts.onBeforePaste.call(inputmask, pasteValue, opts);
            if (pasteValue === false) {
                return false;
            }
            if (!pasteValue) {
                pasteValue = inputValue;
            }
        }
        (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.checkVal)(input, true, false, pasteValue.toString().split(""), e);
        e.preventDefault();
    },
    inputFallBackEvent: function (e) { //fallback when keypress is not triggered
        const inputmask = this.inputmask, opts = inputmask.opts, $ = inputmask.dependencyLib;
        // console.log(e.inputType);

        function analyseChanges(inputValue, buffer, caretPos) {
            var frontPart = inputValue.substr(0, caretPos.begin).split(""),
                backPart = inputValue.substr(caretPos.begin).split(""),
                frontBufferPart = buffer.substr(0, caretPos.begin).split(""),
                backBufferPart = buffer.substr(caretPos.begin).split("");

            var fpl = frontPart.length >= frontBufferPart.length ? frontPart.length : frontBufferPart.length,
                bpl = backPart.length >= backBufferPart.length ? backPart.length : backBufferPart.length,
                bl, i, action = "", data = [], marker = "~", placeholder;

            //align buffers
            while (frontPart.length < fpl) frontPart.push(marker);
            while (frontBufferPart.length < fpl) frontBufferPart.push(marker);
            while (backPart.length < bpl) backPart.unshift(marker);
            while (backBufferPart.length < bpl) backBufferPart.unshift(marker);

            var newBuffer = frontPart.concat(backPart);
            var oldBuffer = frontBufferPart.concat(backBufferPart);

            // console.log("N " + newBuffer);
            // console.log("O " + oldBuffer);

            for (i = 0, bl = newBuffer.length; i < bl; i++) {
                placeholder = _validation_tests__WEBPACK_IMPORTED_MODULE_5__.getPlaceholder.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_0__.translatePosition.call(inputmask, i));
                switch (action) {
                    case "insertText":
                        if (oldBuffer[i - 1] === newBuffer[i] && caretPos.begin == newBuffer.length - 1) {
                            data.push(newBuffer[i]);
                        }
                        i = bl;
                        break;
                    case "insertReplacementText":
                        if (newBuffer[i] === marker) { //extend selection
                            caretPos.end++;
                        } else {
                            // breakout loop
                            i = bl;
                        }
                        break;
                    case "deleteContentBackward":
                        if (newBuffer[i] === marker) {
                            caretPos.end++;
                        } else {
                            //breakout loop
                            i = bl;
                        }
                        break;
                    default:
                        if (newBuffer[i] !== oldBuffer[i]) {
                            if ((newBuffer[i + 1] === marker || newBuffer[i + 1] === placeholder || newBuffer[i + 1] === undefined) && ((oldBuffer[i] === placeholder && oldBuffer[i + 1] === marker) || oldBuffer[i] === marker)) {  //basic insert
                                action = "insertText";
                                data.push(newBuffer[i]);
                                caretPos.begin--;
                                caretPos.end--;
                            } else if (oldBuffer[i + 1] === marker && oldBuffer[i] === newBuffer[i + 1]) { //insert between
                                action = "insertText";
                                data.push(newBuffer[i]);
                                caretPos.begin--;
                                caretPos.end--;
                            } else if (newBuffer[i] !== placeholder && newBuffer[i] !== marker &&
                                (newBuffer[i + 1] === marker || (oldBuffer[i] !== newBuffer[i] && oldBuffer[i + 1] === newBuffer[i + 1] /*single char replacement*/))) { //replace selection
                                action = "insertReplacementText";
                                data.push(newBuffer[i]);
                                caretPos.begin--;
                            } else if (newBuffer[i] === marker) {  //delete~backspace
                                action = "deleteContentBackward";
                                if (_positioning__WEBPACK_IMPORTED_MODULE_0__.isMask.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_0__.translatePosition.call(inputmask, i), true) || oldBuffer[i] === opts.radixPoint) caretPos.end++;
                            } else {
                                i = bl;
                            }
                        }
                        break;
                }
            }

            return {
                action: action,
                data: data,
                caret: caretPos
            };
        }

        var input = this,
            inputValue = input.inputmask._valueGet(true),
            buffer = (inputmask.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask).slice().reverse() : _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask)).join(""),
            caretPos = _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, undefined, undefined, true),
            changes;

        if (buffer !== inputValue) {
            changes = analyseChanges(inputValue, buffer, caretPos);
            if ((input.inputmask.shadowRoot || input.ownerDocument).activeElement !== input) {
                input.focus();
            }
            (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.writeBuffer)(input, _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask));
            _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, caretPos.begin, caretPos.end, true);

            // Japanese IME hack #2662
            if (!_environment__WEBPACK_IMPORTED_MODULE_2__.mobile && inputmask.skipNextInsert && e.inputType === "insertText" && changes.action === "insertText" && inputmask.isComposing) {
                return false;
            }
            if (e.inputType === "insertCompositionText" && changes.action === "insertText" && inputmask.isComposing) {
                inputmask.skipNextInsert = true;
            } else {
                inputmask.skipNextInsert = false;
            }

            switch (changes.action) {
                case "insertText":
                case "insertReplacementText":
                    changes.data.forEach(function (entry, ndx) {
                        var keypress = new $.Event("keypress");
                        keypress.key = entry;
                        inputmask.ignorable = false; //make sure ignorable is ignored ;-)
                        EventHandlers.keypressEvent.call(input, keypress);
                    });
                    setTimeout(function () {  //#2195 trigger keyup to help some other plugins to track changes
                        inputmask.$el.trigger("keyup");
                    }, 0);
                    break;
                case "deleteContentBackward":
                    var keydown = new $.Event("keydown");
                    keydown.key = _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Backspace;
                    EventHandlers.keyEvent.call(input, keydown);
                    break;
                default:
                    (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.applyInputValue)(input, inputValue);
                    _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, caretPos.begin, caretPos.end, true);
                    break;
            }

            e.preventDefault();
        }
    },
    setValueEvent: function (e) {
        const inputmask = this.inputmask;
        var input = this,
            value = (e && e.detail) ? e.detail[0] : arguments[1];

        if (value === undefined) {
            value = input.inputmask._valueGet(true);
        }

        (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.applyInputValue)(input, value);

        if ((e.detail && e.detail[1] !== undefined) || arguments[2] !== undefined) {
            _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, e.detail ? e.detail[1] : arguments[2]);
        }
    }
    ,
    focusEvent: function (e) {
        const inputmask = this.inputmask, opts = inputmask.opts;
        var input = this,
            nptValue = inputmask?._valueGet();

        if (opts.showMaskOnFocus) {
            if (nptValue !== _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask).join("")) {
                (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.writeBuffer)(input, _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask), _positioning__WEBPACK_IMPORTED_MODULE_0__.seekNext.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_0__.getLastValidPosition.call(inputmask)));
            } /*else if (mouseEnter === false) { //only executed on focus without mouseenter
					caret(input, seekNext(getLastValidPosition()));
				}*/
        }
        if (opts.positionCaretOnTab === true && inputmask.mouseEnter === false && (!_validation__WEBPACK_IMPORTED_MODULE_3__.isComplete.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask)) || _positioning__WEBPACK_IMPORTED_MODULE_0__.getLastValidPosition.call(inputmask) === -1)) {
            EventHandlers.clickEvent.apply(input, [e, true]);
        }
        inputmask.undoValue = inputmask?._valueGet(true);
    },
    invalidEvent: function (e) {
        this.inputmask.validationEvent = true;
    },
    mouseleaveEvent: function () {
        const inputmask = this.inputmask, opts = inputmask.opts;

        var input = this;
        inputmask.mouseEnter = false;
        if (opts.clearMaskOnLostFocus && (input.inputmask.shadowRoot || input.ownerDocument).activeElement !== input) {
            (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.HandleNativePlaceholder)(input, inputmask.originalPlaceholder);
        }
    },
    clickEvent: function (e, tabbed) {
        const inputmask = this.inputmask;
        inputmask.clicked++;

        var input = this;
        if ((input.inputmask.shadowRoot || input.ownerDocument).activeElement === input) {
            var newCaretPosition = _positioning__WEBPACK_IMPORTED_MODULE_0__.determineNewCaretPosition.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input), tabbed);
            if (newCaretPosition !== undefined) {
                _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input, newCaretPosition);
            }
        }
    },
    cutEvent: function (e) {
        const inputmask = this.inputmask, maskset = inputmask.maskset;

        var input = this,
            pos = _positioning__WEBPACK_IMPORTED_MODULE_0__.caret.call(inputmask, input);

        //correct clipboardData
        var clipData = inputmask.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask).slice(pos.end, pos.begin) : _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask).slice(pos.begin, pos.end),
            clipDataText = inputmask.isRTL ? clipData.reverse().join("") : clipData.join("");
        if (window.navigator.clipboard) window.navigator.clipboard.writeText(clipDataText);
        else if (window.clipboardData && window.clipboardData.getData) { // IE
            window.clipboardData.setData("Text", clipDataText);
        }
        _validation__WEBPACK_IMPORTED_MODULE_3__.handleRemove.call(inputmask, input, _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Delete, pos);
        (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.writeBuffer)(input, _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask), maskset.p, e, inputmask.undoValue !== inputmask._valueGet(true));
    },
    blurEvent: function (e) {
        const inputmask = this.inputmask, opts = inputmask.opts, $ = inputmask.dependencyLib;
        inputmask.clicked = 0;

        var $input = $(this),
            input = this;
        if (input.inputmask) {
            (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.HandleNativePlaceholder)(input, inputmask.originalPlaceholder);
            var nptValue = input.inputmask._valueGet(),
                buffer = _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask).slice();

            if (nptValue !== "") {
                if (opts.clearMaskOnLostFocus) {
                    if (_positioning__WEBPACK_IMPORTED_MODULE_0__.getLastValidPosition.call(inputmask) === -1 && nptValue === _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask).join("")) {
                        buffer = [];
                    } else { //clearout optional tail of the mask
                        _inputHandling__WEBPACK_IMPORTED_MODULE_4__.clearOptionalTail.call(inputmask, buffer);
                    }
                }
                if (_validation__WEBPACK_IMPORTED_MODULE_3__.isComplete.call(inputmask, buffer) === false) {
                    setTimeout(function () {
                        $input.trigger("incomplete");
                    }, 0);
                    if (opts.clearIncomplete) {
                        _positioning__WEBPACK_IMPORTED_MODULE_0__.resetMaskSet.call(inputmask);
                        if (opts.clearMaskOnLostFocus) {
                            buffer = [];
                        } else {
                            buffer = _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask).slice();
                        }

                    }
                }

                (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.writeBuffer)(input, buffer, undefined, e);
            }

            if (inputmask.undoValue !== inputmask._valueGet(true)) {
                inputmask.undoValue = inputmask._valueGet(true);
                $input.trigger("change");
            }
        }
    }
    ,
    mouseenterEvent: function () {
        const inputmask = this.inputmask, {showMaskOnHover} = inputmask.opts;

        var input = this;
        inputmask.mouseEnter = true;
        if ((input.inputmask.shadowRoot || input.ownerDocument).activeElement !== input) {
            var bufferTemplate = (inputmask.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask).slice().reverse() : _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask)).join("");
            if (showMaskOnHover) {
                (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.HandleNativePlaceholder)(input, bufferTemplate);
            }
        }
    }
    ,
    submitEvent: function () { //trigger change on submit if any
        const inputmask = this.inputmask, opts = inputmask.opts;

        if (inputmask.undoValue !== inputmask._valueGet(true)) {
            inputmask.$el.trigger("change");
        }
        if (/*opts.clearMaskOnLostFocus && */_positioning__WEBPACK_IMPORTED_MODULE_0__.getLastValidPosition.call(inputmask) === -1 && inputmask._valueGet && inputmask._valueGet() === _positioning__WEBPACK_IMPORTED_MODULE_0__.getBufferTemplate.call(inputmask).join("")) {
            inputmask._valueSet(""); //clear masktemplete on submit and still has focus
        }
        if (opts.clearIncomplete && _validation__WEBPACK_IMPORTED_MODULE_3__.isComplete.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask)) === false) {
            inputmask._valueSet("");
        }
        if (opts.removeMaskOnSubmit) {
            inputmask._valueSet(inputmask.unmaskedvalue(), true);
            setTimeout(function () {
                (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.writeBuffer)(inputmask.el, _positioning__WEBPACK_IMPORTED_MODULE_0__.getBuffer.call(inputmask));
            }, 0);
        }
    }
    ,
    resetEvent: function () {
        const inputmask = this.inputmask;

        inputmask.refreshValue = true; //indicate a forced refresh when there is a call to the value before leaving the triggering event fn
        setTimeout(function () {
            (0,_inputHandling__WEBPACK_IMPORTED_MODULE_4__.applyInputValue)(inputmask.el, inputmask._valueGet(true));
        }, 0);
    }
};


/***/ }),

/***/ "./node_modules/inputmask/lib/eventruler.js":
/*!**************************************************!*\
  !*** ./node_modules/inputmask/lib/eventruler.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventRuler": () => (/* binding */ EventRuler)
/* harmony export */ });
/* harmony import */ var _inputmask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inputmask */ "./node_modules/inputmask/lib/inputmask.js");
/* harmony import */ var _keycode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keycode.js */ "./node_modules/inputmask/lib/keycode.js");
/* harmony import */ var _positioning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./positioning */ "./node_modules/inputmask/lib/positioning.js");
/* harmony import */ var _inputHandling__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inputHandling */ "./node_modules/inputmask/lib/inputHandling.js");







var EventRuler = {
    on: function (input, eventName, eventHandler) {
        const $ = input.inputmask.dependencyLib;

        var ev = function (e) {
            if (e.originalEvent) {
                e = e.originalEvent || e; //get original event from jquery evenbt
                arguments[0] = e;
            }
            // console.log(e.type);
            var that = this, args, inputmask = that.inputmask, opts = inputmask ? inputmask.opts : undefined;
            if (inputmask === undefined && this.nodeName !== "FORM") { //happens when cloning an object with jquery.clone
                var imOpts = $.data(that, "_inputmask_opts");
                $(that).off(); //unbind all events
                if (imOpts) {
                    (new _inputmask__WEBPACK_IMPORTED_MODULE_0__["default"](imOpts)).mask(that);
                }
            } else if (!["submit", "reset", "setvalue"].includes(e.type) && this.nodeName !== "FORM" && (that.disabled || (that.readOnly && !(e.type === "keydown" && (e.ctrlKey && e.key === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.c) || (opts.tabThrough === false && e.key === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Tab))))) {
                e.preventDefault();
            } else {
                switch (e.type) {
                    case "input":
                        if (inputmask.skipInputEvent === true) {
                            inputmask.skipInputEvent = false;
                            return e.preventDefault();
                        }

                        // if (mobile) { //this causes problem see #2220
                        // 	args = arguments;
                        // 	setTimeout(function () { //needed for caret selection when entering a char on Android 8 - #1818
                        // 		eventHandler.apply(that, args);
                        // 		caret(that, that.inputmask.caretPos, undefined, true);
                        // 	}, 0);
                        // 	return false;
                        // }
                        break;
                    case "click":
                    case "focus":
                        if (inputmask.validationEvent) { // #841
                            inputmask.validationEvent = false;
                            input.blur();
                            (0,_inputHandling__WEBPACK_IMPORTED_MODULE_3__.HandleNativePlaceholder)(input, (inputmask.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_2__.getBufferTemplate.call(inputmask).slice().reverse() : _positioning__WEBPACK_IMPORTED_MODULE_2__.getBufferTemplate.call(inputmask)).join(""));
                            setTimeout(function () {
                                input.focus();
                            }, opts.validationEventTimeOut);
                            return false;
                        }
                        args = arguments;
                        setTimeout(function () { //needed for Chrome ~ initial selection clears after the clickevent
                            if (!input.inputmask) {
                                // `inputmask.remove()` was called before this callback
                                return;
                            }
                            eventHandler.apply(that, args);
                        }, 0);
                        return /*false*/; //#2423
                }
                var returnVal = eventHandler.apply(that, arguments);
                if (returnVal === false) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                return returnVal;
            }
        };
        if (["submit", "reset"].includes(eventName)) {
            ev = ev.bind(input); //bind creates a new eventhandler (wrap)
            if (input.form !== null) $(input.form).on(eventName, ev);
        } else {
            $(input).on(eventName, ev);
        }

        //keep instance of the event
        input.inputmask.events[eventName] = input.inputmask.events[eventName] || [];
        input.inputmask.events[eventName].push(ev);

    },
    off: function (input, event) {
        if (input.inputmask && input.inputmask.events) {
            const $ = input.inputmask.dependencyLib;
            let events = input.inputmask.events;
            if (event) {
                events = [];
                events[event] = input.inputmask.events[event];
            }
            for (let eventName in events) {
                let evArr = events[eventName];
                while (evArr.length > 0) {
                    let ev = evArr.pop();
                    if (["submit", "reset",].includes(eventName)) {
                        if (input.form !== null) $(input.form).off(eventName, ev);
                    } else {
                        $(input).off(eventName, ev);
                    }
                }
                delete input.inputmask.events[eventName];
            }
        }
    }
};


/***/ }),

/***/ "./node_modules/inputmask/lib/global/window.js":
/*!*****************************************************!*\
  !*** ./node_modules/inputmask/lib/global/window.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _canUseDOM__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../canUseDOM */ "./node_modules/inputmask/lib/canUseDOM.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_canUseDOM__WEBPACK_IMPORTED_MODULE_0__["default"] ? window : {});


/***/ }),

/***/ "./node_modules/inputmask/lib/inputHandling.js":
/*!*****************************************************!*\
  !*** ./node_modules/inputmask/lib/inputHandling.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HandleNativePlaceholder": () => (/* binding */ HandleNativePlaceholder),
/* harmony export */   "applyInputValue": () => (/* binding */ applyInputValue),
/* harmony export */   "checkVal": () => (/* binding */ checkVal),
/* harmony export */   "clearOptionalTail": () => (/* binding */ clearOptionalTail),
/* harmony export */   "unmaskedvalue": () => (/* binding */ unmaskedvalue),
/* harmony export */   "writeBuffer": () => (/* binding */ writeBuffer)
/* harmony export */ });
/* harmony import */ var _keycode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keycode.js */ "./node_modules/inputmask/lib/keycode.js");
/* harmony import */ var _validation_tests__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validation-tests */ "./node_modules/inputmask/lib/validation-tests.js");
/* harmony import */ var _positioning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./positioning */ "./node_modules/inputmask/lib/positioning.js");
/* harmony import */ var _validation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./validation */ "./node_modules/inputmask/lib/validation.js");
/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./environment */ "./node_modules/inputmask/lib/environment.js");
/* harmony import */ var _eventhandlers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./eventhandlers */ "./node_modules/inputmask/lib/eventhandlers.js");










function applyInputValue(input, value) {
    const inputmask = input ? input.inputmask : this, opts = inputmask.opts;

    input.inputmask.refreshValue = false;
    if (typeof opts.onBeforeMask === "function") value = opts.onBeforeMask.call(inputmask, value, opts) || value;
    value = (value || "").toString().split("");
    checkVal(input, true, false, value);
    inputmask.undoValue = inputmask._valueGet(true);
    if ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === _positioning__WEBPACK_IMPORTED_MODULE_2__.getBufferTemplate.call(inputmask).join("") && _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask) === -1) {
        input.inputmask._valueSet("");
    }
}

//todo put on prototype?
function clearOptionalTail(buffer) {
    const inputmask = this;

    buffer.length = 0;
    var template = _validation_tests__WEBPACK_IMPORTED_MODULE_1__.getMaskTemplate.call(inputmask, true, 0, true, undefined, true), lmnt;
    while ((lmnt = template.shift()) !== undefined) buffer.push(lmnt);
    return buffer;
}

function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {
    const inputmask = input ? input.inputmask : this,
        maskset = inputmask.maskset,
        opts = inputmask.opts, $ = inputmask.dependencyLib;

    var inputValue = nptvl.slice(),
        charCodes = "",
        initialNdx = -1,
        result = undefined, skipOptionalPartCharacter = opts.skipOptionalPartCharacter;
    opts.skipOptionalPartCharacter = ""; //see issue #2311

    function isTemplateMatch(ndx, charCodes) {
        var targetTemplate = _validation_tests__WEBPACK_IMPORTED_MODULE_1__.getMaskTemplate.call(inputmask, true, 0).slice(ndx, _positioning__WEBPACK_IMPORTED_MODULE_2__.seekNext.call(inputmask, ndx, false, false)).join("").replace(/'/g, ""),
            charCodeNdx = targetTemplate.indexOf(charCodes);
        //strip spaces from targetTemplate
        while (charCodeNdx > 0 && targetTemplate[charCodeNdx - 1] === " ") charCodeNdx--;

        var match = charCodeNdx === 0 && !_positioning__WEBPACK_IMPORTED_MODULE_2__.isMask.call(inputmask, ndx)
            && (_validation_tests__WEBPACK_IMPORTED_MODULE_1__.getTest.call(inputmask, ndx).match.nativeDef === charCodes.charAt(0)
                || (_validation_tests__WEBPACK_IMPORTED_MODULE_1__.getTest.call(inputmask, ndx).match.static === true && _validation_tests__WEBPACK_IMPORTED_MODULE_1__.getTest.call(inputmask, ndx).match.nativeDef === ("'" + charCodes.charAt(0)))
                || (_validation_tests__WEBPACK_IMPORTED_MODULE_1__.getTest.call(inputmask, ndx).match.nativeDef === " " && (_validation_tests__WEBPACK_IMPORTED_MODULE_1__.getTest.call(inputmask, ndx + 1).match.nativeDef === charCodes.charAt(0)
                    || (_validation_tests__WEBPACK_IMPORTED_MODULE_1__.getTest.call(inputmask, ndx + 1).match.static === true && _validation_tests__WEBPACK_IMPORTED_MODULE_1__.getTest.call(inputmask, ndx + 1).match.nativeDef === ("'" + charCodes.charAt(0))))));

        if (!match && charCodeNdx > 0 && !_positioning__WEBPACK_IMPORTED_MODULE_2__.isMask.call(inputmask, ndx, false, true)) {
            var nextPos = _positioning__WEBPACK_IMPORTED_MODULE_2__.seekNext.call(inputmask, ndx);
            if (inputmask.caretPos.begin < nextPos) {
                inputmask.caretPos = {begin: nextPos};
            }
        }
        return match;
    }

    _positioning__WEBPACK_IMPORTED_MODULE_2__.resetMaskSet.call(inputmask);
    maskset.tests = {}; //reset tests ~ possible after alternating
    initialNdx = opts.radixPoint ? _positioning__WEBPACK_IMPORTED_MODULE_2__.determineNewCaretPosition.call(inputmask, {
        begin: 0,
        end: 0
    }, false, opts.__financeInput === false ? "radixFocus" : undefined).begin : 0;
    maskset.p = initialNdx;
    inputmask.caretPos = {begin: initialNdx};

    var staticMatches = [], prevCaretPos = inputmask.caretPos;
    inputValue.forEach(function (charCode, ndx) {
        if (charCode !== undefined) { //inputfallback strips some elements out of the inputarray.  $.each logically presents them as undefined
            /*if (maskset.validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder.call(inputmask, ndx) && isMask.call(inputmask, ndx, true) &&
                isValid.call(inputmask, ndx, inputValue[ndx], true, undefined, true, true) === false) {
                inputmask.caretPos.begin++;
            } else*/
            {
                var keypress = new $.Event("_checkval");
                keypress.key = charCode;
                charCodes += charCode;
                var lvp = _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask, undefined, true);
                if (!isTemplateMatch(initialNdx, charCodes)) {
                    result = _eventhandlers__WEBPACK_IMPORTED_MODULE_5__.EventHandlers.keypressEvent.call(inputmask, keypress, true, false, strict, inputmask.caretPos.begin);

                    if (result) {
                        initialNdx = inputmask.caretPos.begin + 1;
                        charCodes = "";
                    }
                } else {
                    result = _eventhandlers__WEBPACK_IMPORTED_MODULE_5__.EventHandlers.keypressEvent.call(inputmask, keypress, true, false, strict, lvp + 1);
                }
                if (result) {
                    if (result.pos !== undefined && maskset.validPositions[result.pos] && maskset.validPositions[result.pos].match.static === true && maskset.validPositions[result.pos].alternation === undefined) {
                        staticMatches.push(result.pos);
                        if (!inputmask.isRTL) {
                            result.forwardPosition = result.pos + 1;
                        }
                    }
                    writeBuffer.call(inputmask, undefined, _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask), result.forwardPosition, keypress, false);
                    inputmask.caretPos = {begin: result.forwardPosition, end: result.forwardPosition};
                    prevCaretPos = inputmask.caretPos;
                } else {
                    if (maskset.validPositions[ndx] === undefined && inputValue[ndx] === _validation_tests__WEBPACK_IMPORTED_MODULE_1__.getPlaceholder.call(inputmask, ndx) && _positioning__WEBPACK_IMPORTED_MODULE_2__.isMask.call(inputmask, ndx, true)) {
                        inputmask.caretPos.begin++;
                    } else inputmask.caretPos = prevCaretPos; //restore the caret position from before the failed validation
                }
            }
        }
    });
    if (staticMatches.length > 0) {
        var sndx, validPos, nextValid = _positioning__WEBPACK_IMPORTED_MODULE_2__.seekNext.call(inputmask, -1, undefined, false);
        if ((!_validation__WEBPACK_IMPORTED_MODULE_3__.isComplete.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask)) && staticMatches.length <= nextValid)
            || (_validation__WEBPACK_IMPORTED_MODULE_3__.isComplete.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask)) && staticMatches.length > 0 && (staticMatches.length !== nextValid && staticMatches[0] === 0))) { //should check if is sequence starting from 0
            var nextSndx = nextValid;
            while ((sndx = staticMatches.shift()) !== undefined) {
                var keypress = new $.Event("_checkval");
                validPos = maskset.validPositions[sndx];
                validPos.generatedInput = true;
                keypress.key = validPos.input;
                result = _eventhandlers__WEBPACK_IMPORTED_MODULE_5__.EventHandlers.keypressEvent.call(inputmask, keypress, true, false, strict, nextSndx);
                if (result && result.pos !== undefined && result.pos !== sndx && maskset.validPositions[result.pos] && maskset.validPositions[result.pos].match.static === true) {
                    staticMatches.push(result.pos);
                } else if (!result) break;
                nextSndx++;
            }
        } else { //mark al statics as generated
            // while ((sndx = staticMatches.pop())) {
            // 	validPos = maskset.validPositions[sndx];
            // 	if (validPos) {
            // 		validPos.generatedInput = true;
            // 	}
            // }
        }
    }
    if (writeOut) {
        writeBuffer.call(
            inputmask,
            input,
            _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask), result ? result.forwardPosition : inputmask.caretPos.begin,
            initiatingEvent || new $.Event("checkval"),
            initiatingEvent && ((initiatingEvent.type === "input" && inputmask.undoValue !== _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask).join("")) || initiatingEvent.type === "paste"));
        // for (var vndx in maskset.validPositions) {
        // 	if (maskset.validPositions[vndx].match.generated !== true) { //only remove non forced generated
        // 		delete maskset.validPositions[vndx].generatedInput; //clear generated markings ~ consider initializing with a  value as fully typed
        // 	}
        // }
    }
    opts.skipOptionalPartCharacter = skipOptionalPartCharacter;
}

function HandleNativePlaceholder(npt, value) {
    const inputmask = npt ? npt.inputmask : this;

    if (_environment__WEBPACK_IMPORTED_MODULE_4__.ie) {
        if (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || npt.placeholder === "")) {
            var buffer = _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask).slice(),
                nptValue = npt.inputmask._valueGet();
            if (nptValue !== value) {
                var lvp = _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask);
                if (lvp === -1 && nptValue === _positioning__WEBPACK_IMPORTED_MODULE_2__.getBufferTemplate.call(inputmask).join("")) {
                    buffer = [];
                } else if (lvp !== -1) { //clearout optional tail of the mask
                    clearOptionalTail.call(inputmask, buffer);
                }
                writeBuffer(npt, buffer);
            }
        }
    } else if (npt.placeholder !== value) {
        npt.placeholder = value;
        if (npt.placeholder === "") npt.removeAttribute("placeholder");
    }
}

function unmaskedvalue(input) {
    const inputmask = input ? input.inputmask : this,
        opts = inputmask.opts,
        maskset = inputmask.maskset;

    if (input) {
        if (input.inputmask === undefined) {
            return input.value;
        }
        if (input.inputmask && input.inputmask.refreshValue) { //forced refresh from the value form.reset
            applyInputValue(input, input.inputmask._valueGet(true));
        }
    }
    var umValue = [],
        vps = maskset.validPositions;
    for (let pndx = 0, vpl = vps.length; pndx < vpl; pndx++) {
        if (vps[pndx] && vps[pndx].match && (vps[pndx].match.static != true || (Array.isArray(maskset.metadata) && vps[pndx].generatedInput !== true))) {
            //only include generated input with multiple masks (check on metadata)
            umValue.push(vps[pndx].input);
        }
    }
    var unmaskedValue = umValue.length === 0 ? "" : (inputmask.isRTL ? umValue.reverse() : umValue).join("");
    if (typeof opts.onUnMask === "function") {
        var bufferValue = (inputmask.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask).slice().reverse() : _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask)).join("");
        unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);
    }
    return unmaskedValue;
}

function writeBuffer(input, buffer, caretPos, event, triggerEvents) {
    const inputmask = input ? input.inputmask : this,
        opts = inputmask.opts,
        $ = inputmask.dependencyLib;

    if (event && typeof opts.onBeforeWrite === "function") {
        //    buffer = buffer.slice(); //prevent uncontrolled manipulation of the internal buffer
        var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);
        if (result) {
            if (result.refreshFromBuffer) {
                var refresh = result.refreshFromBuffer;
                _validation__WEBPACK_IMPORTED_MODULE_3__.refreshFromBuffer.call(inputmask, refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);
                buffer = _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask, true);
            }
            if (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;
        }
    }
    if (input !== undefined) {
        input.inputmask._valueSet(buffer.join(""));
        if (caretPos !== undefined && (event === undefined || event.type !== "blur")) {
            // console.log(caretPos);
            _positioning__WEBPACK_IMPORTED_MODULE_2__.caret.call(inputmask, input, caretPos, undefined, undefined, (event !== undefined && event.type === "keydown" && (event.key === _keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Delete || event.key === _keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Backspace)));
        }
        if (triggerEvents === true) {
            var $input = $(input), nptVal = input.inputmask._valueGet();
            input.inputmask.skipInputEvent = true;
            $input.trigger("input");
            setTimeout(function () { //timeout needed for IE
                if (nptVal === _positioning__WEBPACK_IMPORTED_MODULE_2__.getBufferTemplate.call(inputmask).join("")) {
                    $input.trigger("cleared");
                } else if (_validation__WEBPACK_IMPORTED_MODULE_3__.isComplete.call(inputmask, buffer) === true) {
                    $input.trigger("complete");
                }
            }, 0);
        }
    }
}


/***/ }),

/***/ "./node_modules/inputmask/lib/inputmask.js":
/*!*************************************************!*\
  !*** ./node_modules/inputmask/lib/inputmask.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _mask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mask */ "./node_modules/inputmask/lib/mask.js");
/* harmony import */ var _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dependencyLibs/inputmask.dependencyLib */ "./node_modules/inputmask/lib/dependencyLibs/inputmask.dependencyLib.js");
/* harmony import */ var _global_window__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global/window */ "./node_modules/inputmask/lib/global/window.js");
/* harmony import */ var _mask_lexer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mask-lexer */ "./node_modules/inputmask/lib/mask-lexer.js");
/* harmony import */ var _validation_tests__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./validation-tests */ "./node_modules/inputmask/lib/validation-tests.js");
/* harmony import */ var _positioning__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./positioning */ "./node_modules/inputmask/lib/positioning.js");
/* harmony import */ var _validation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validation */ "./node_modules/inputmask/lib/validation.js");
/* harmony import */ var _inputHandling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./inputHandling */ "./node_modules/inputmask/lib/inputHandling.js");
/* harmony import */ var _eventruler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./eventruler */ "./node_modules/inputmask/lib/eventruler.js");
/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./definitions */ "./node_modules/inputmask/lib/definitions.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./defaults */ "./node_modules/inputmask/lib/defaults.js");
/* harmony import */ var _canUseDOM__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./canUseDOM */ "./node_modules/inputmask/lib/canUseDOM.js");
/*
 * Input Mask Core
 * http://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) Robin Herbots
 * Licensed under the MIT license
 */














const document = _global_window__WEBPACK_IMPORTED_MODULE_2__["default"].document, dataKey = "_inputmask_opts";

function Inputmask(alias, options, internal) {
    if (!_canUseDOM__WEBPACK_IMPORTED_MODULE_11__["default"]) {
        return;
    }

    //allow instanciating without new
    if (!(this instanceof Inputmask)) {
        return new Inputmask(alias, options, internal);
    }

    this.dependencyLib = _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"];
    this.el = undefined;
    this.events = {};
    this.maskset = undefined;

    if (internal !== true) {
        //init options
        if (Object.prototype.toString.call(alias) === "[object Object]") {
            options = alias;
        } else {
            options = options || {};
            if (alias) options.alias = alias;
        }
        this.opts = _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, {}, this.defaults, options);
        this.noMasksCache = options && options.definitions !== undefined;
        this.userOptions = options || {}; //user passed options
        resolveAlias(this.opts.alias, options, this.opts);
    }

    //maskscope properties
    this.refreshValue = false; //indicate a refresh from the inputvalue is needed (form.reset)
    this.undoValue = undefined;
    this.$el = undefined;
    this.skipInputEvent = false; //skip when triggered from within inputmask
    this.validationEvent = false;
    this.ignorable = false;
    this.maxLength;
    this.mouseEnter = false;
    this.clicked = 0;
    this.originalPlaceholder = undefined; //needed for FF
    this.isComposing = false, //keydowncode == 229  compositionevent fallback
    this.hasAlternator = false;
}

Inputmask.prototype = {
    dataAttribute: "data-inputmask", //data attribute prefix used for attribute binding
    //options default
    defaults: _defaults__WEBPACK_IMPORTED_MODULE_10__["default"],
    definitions: _definitions__WEBPACK_IMPORTED_MODULE_9__["default"],
    aliases: {}, //aliases definitions
    masksCache: {},
    get isRTL() {
        return this.opts.isRTL || this.opts.numericInput;
    },
    mask: function (elems) {
        var that = this;
        if (typeof elems === "string") {
            elems = (document.getElementById(elems) || document.querySelectorAll(elems));
        }
        elems = elems.nodeName ? [elems] : (Array.isArray(elems) ? elems : [].slice.call(elems)); //[].slice as alternate for Array.from (Yandex browser)
        elems.forEach(function (el, ndx) {
            var scopedOpts = _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, {}, that.opts);
            if (importAttributeOptions(el, scopedOpts, _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, {}, that.userOptions), that.dataAttribute)) {
                var maskset = (0,_mask_lexer__WEBPACK_IMPORTED_MODULE_3__.generateMaskSet)(scopedOpts, that.noMasksCache);
                if (maskset !== undefined) {
                    if (el.inputmask !== undefined) {
                        el.inputmask.opts.autoUnmask = true; //force autounmasking when remasking
                        el.inputmask.remove();
                    }
                    //store inputmask instance on the input with element reference
                    el.inputmask = new Inputmask(undefined, undefined, true);
                    el.inputmask.opts = scopedOpts;
                    el.inputmask.noMasksCache = that.noMasksCache;
                    el.inputmask.userOptions = _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, {}, that.userOptions);
                    // el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput;
                    el.inputmask.el = el;
                    el.inputmask.$el = (0,_dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
                    el.inputmask.maskset = maskset;

                    _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].data(el, dataKey, that.userOptions);
                    _mask__WEBPACK_IMPORTED_MODULE_0__.mask.call(el.inputmask);
                }
            }
        });
        return elems && elems[0] ? (elems[0].inputmask || this) : this;
    },
    option: function (options, noremask) { //set extra options || retrieve value of a current option
        if (typeof options === "string") {
            return this.opts[options];
        } else if (typeof options === "object") {
            _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(this.userOptions, options); //user passed options
            //remask
            if (this.el && noremask !== true) {
                this.mask(this.el);
            }
            return this;
        }
    },
    unmaskedvalue: function (value) {
        this.maskset = this.maskset || (0,_mask_lexer__WEBPACK_IMPORTED_MODULE_3__.generateMaskSet)(this.opts, this.noMasksCache);
        if (this.el === undefined || value !== undefined) {
            var valueBuffer = (typeof this.opts.onBeforeMask === "function" ? (this.opts.onBeforeMask.call(this, value, this.opts) || value) : value).split("");
            _inputHandling__WEBPACK_IMPORTED_MODULE_7__.checkVal.call(this, undefined, false, false, valueBuffer);
            if (typeof this.opts.onBeforeWrite === "function") this.opts.onBeforeWrite.call(this, undefined, _positioning__WEBPACK_IMPORTED_MODULE_5__.getBuffer.call(this), 0, this.opts);
        }
        return _inputHandling__WEBPACK_IMPORTED_MODULE_7__.unmaskedvalue.call(this, this.el);
    },
    remove: function () {
        if (this.el) {
            _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].data(this.el, dataKey, null); //invalidate
            //writeout the value
            var cv = this.opts.autoUnmask ? (0,_inputHandling__WEBPACK_IMPORTED_MODULE_7__.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
            if (cv !== _positioning__WEBPACK_IMPORTED_MODULE_5__.getBufferTemplate.call(this).join("")) this._valueSet(cv, this.opts.autoUnmask); else this._valueSet("");
            //unbind all events
            _eventruler__WEBPACK_IMPORTED_MODULE_8__.EventRuler.off(this.el);

            //restore the value property
            var valueProperty;
            if (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {
                valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value");
                if (valueProperty) {
                    if (this.__valueGet) {
                        Object.defineProperty(this.el, "value", {
                            get: this.__valueGet,
                            set: this.__valueSet,
                            configurable: true
                        });
                    }
                }
            } else if (document.__lookupGetter__ && this.el.__lookupGetter__("value")) {
                if (this.__valueGet) {
                    this.el.__defineGetter__("value", this.__valueGet);
                    this.el.__defineSetter__("value", this.__valueSet);
                }
            }
            //clear data
            this.el.inputmask = undefined;
        }
        return this.el;
    },
    getemptymask: function () { //return the default (empty) mask value, usefull for setting the default value in validation
        this.maskset = this.maskset || (0,_mask_lexer__WEBPACK_IMPORTED_MODULE_3__.generateMaskSet)(this.opts, this.noMasksCache);
        return (this.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_5__.getBufferTemplate.call(this).reverse() : _positioning__WEBPACK_IMPORTED_MODULE_5__.getBufferTemplate.call(this)).join("");
    },
    hasMaskedValue: function () { //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value
        return !this.opts.autoUnmask;
    },
    isComplete: function () {
        this.maskset = this.maskset || (0,_mask_lexer__WEBPACK_IMPORTED_MODULE_3__.generateMaskSet)(this.opts, this.noMasksCache);
        return _validation__WEBPACK_IMPORTED_MODULE_6__.isComplete.call(this, _positioning__WEBPACK_IMPORTED_MODULE_5__.getBuffer.call(this));
    },
    getmetadata: function () { //return mask metadata if exists
        this.maskset = this.maskset || (0,_mask_lexer__WEBPACK_IMPORTED_MODULE_3__.generateMaskSet)(this.opts, this.noMasksCache);
        if (Array.isArray(this.maskset.metadata)) {
            var maskTarget = _validation_tests__WEBPACK_IMPORTED_MODULE_4__.getMaskTemplate.call(this, true, 0, false).join("");
            this.maskset.metadata.forEach(function (mtdt) {
                if (mtdt.mask === maskTarget) {
                    maskTarget = mtdt;
                    return false;
                }

                return true;
            });
            return maskTarget;
        }
        return this.maskset.metadata;
    },
    isValid: function (value) {
        this.maskset = this.maskset || (0,_mask_lexer__WEBPACK_IMPORTED_MODULE_3__.generateMaskSet)(this.opts, this.noMasksCache);
        if (value) {
            var valueBuffer = (typeof this.opts.onBeforeMask === "function" ? (this.opts.onBeforeMask.call(this, value, this.opts) || value) : value).split("");
            _inputHandling__WEBPACK_IMPORTED_MODULE_7__.checkVal.call(this, undefined, true, false, valueBuffer);
        } else {
            value = this.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_5__.getBuffer.call(this).slice().reverse().join("") : _positioning__WEBPACK_IMPORTED_MODULE_5__.getBuffer.call(this).join("");
        }
        var buffer = _positioning__WEBPACK_IMPORTED_MODULE_5__.getBuffer.call(this);
        var rl = _positioning__WEBPACK_IMPORTED_MODULE_5__.determineLastRequiredPosition.call(this),
            lmib = buffer.length - 1;
        for (; lmib > rl; lmib--) {
            if (_positioning__WEBPACK_IMPORTED_MODULE_5__.isMask.call(this, lmib)) break;
        }
        buffer.splice(rl, lmib + 1 - rl);

        return _validation__WEBPACK_IMPORTED_MODULE_6__.isComplete.call(this, buffer) && value === (this.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_5__.getBuffer.call(this).slice().reverse().join("") : _positioning__WEBPACK_IMPORTED_MODULE_5__.getBuffer.call(this).join(""));

    },
    format: function (value, metadata) {
        this.maskset = this.maskset || (0,_mask_lexer__WEBPACK_IMPORTED_MODULE_3__.generateMaskSet)(this.opts, this.noMasksCache);
        let valueBuffer = (typeof this.opts.onBeforeMask === "function" ? (this.opts.onBeforeMask.call(this, value, this.opts) || value) : value).split("");
        _inputHandling__WEBPACK_IMPORTED_MODULE_7__.checkVal.call(this, undefined, true, false, valueBuffer);
        let formattedValue = this.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_5__.getBuffer.call(this).slice().reverse().join("") : _positioning__WEBPACK_IMPORTED_MODULE_5__.getBuffer.call(this).join("");
        return metadata ? {
            value: formattedValue,
            metadata: this.getmetadata()
        } : formattedValue;
    },
    setValue: function (value) {
        if (this.el) {
            (0,_dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"])(this.el).trigger("setvalue", [value]);
        }
    },
    analyseMask: _mask_lexer__WEBPACK_IMPORTED_MODULE_3__.analyseMask
};

function resolveAlias(aliasStr, options, opts) {
    var aliasDefinition = Inputmask.prototype.aliases[aliasStr];
    if (aliasDefinition) {
        if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias
        _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, opts, aliasDefinition); //merge alias definition in the options
        _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, opts, options); //reapply extra given options
        return true;
    } else //alias not found - try as mask
    if (opts.mask === null) {
        opts.mask = aliasStr;
    }

    return false;
}

function importAttributeOptions(npt, opts, userOptions, dataAttribute) {
    function importOption(option, optionData) {
        const attrOption = dataAttribute === "" ? option : dataAttribute + "-" + option;
        optionData = optionData !== undefined ? optionData : npt.getAttribute(attrOption);
        if (optionData !== null) {
            if (typeof optionData === "string") {
                if (option.indexOf("on") === 0) {
                    optionData = _global_window__WEBPACK_IMPORTED_MODULE_2__["default"][optionData];
                }//get function definition
                else if (optionData === "false") {
                    optionData = false;
                } else if (optionData === "true") optionData = true;
            }
            userOptions[option] = optionData;
        }
    }

    if (opts.importDataAttributes === true) {
        var attrOptions = npt.getAttribute(dataAttribute), option, dataoptions, optionData, p;

        if (attrOptions && attrOptions !== "") {
            attrOptions = attrOptions.replace(/'/g, "\"");
            dataoptions = JSON.parse("{" + attrOptions + "}");
        }

        //resolve aliases
        if (dataoptions) { //pickup alias from dataAttribute
            optionData = undefined;
            for (p in dataoptions) {
                if (p.toLowerCase() === "alias") {
                    optionData = dataoptions[p];
                    break;
                }
            }
        }
        importOption("alias", optionData); //pickup alias from dataAttribute-alias
        if (userOptions.alias) {
            resolveAlias(userOptions.alias, userOptions, opts);
        }

        for (option in opts) {
            if (dataoptions) {
                optionData = undefined;
                for (p in dataoptions) {
                    if (p.toLowerCase() === option.toLowerCase()) {
                        optionData = dataoptions[p];
                        break;
                    }
                }
            }
            importOption(option, optionData);
        }
    }
    _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, opts, userOptions);

    //handle dir=rtl
    if (npt.dir === "rtl" || opts.rightAlign) {
        npt.style.textAlign = "right";
    }

    if (npt.dir === "rtl" || opts.numericInput) {
        npt.dir = "ltr";
        npt.removeAttribute("dir");
        opts.isRTL = true;
    }

    return Object.keys(userOptions).length;
}

//apply defaults, definitions, aliases
Inputmask.extendDefaults = function (options) {
    _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, Inputmask.prototype.defaults, options);
};
Inputmask.extendDefinitions = function (definition) {
    _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, Inputmask.prototype.definitions, definition);
};
Inputmask.extendAliases = function (alias) {
    _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"].extend(true, Inputmask.prototype.aliases, alias);
};
//static fn on inputmask
Inputmask.format = function (value, options, metadata) {
    return Inputmask(options).format(value, metadata);
};
Inputmask.unmask = function (value, options) {
    return Inputmask(options).unmaskedvalue(value);
};
Inputmask.isValid = function (value, options) {
    return Inputmask(options).isValid(value);
};
Inputmask.remove = function (elems) {
    if (typeof elems === "string") {
        elems = document.getElementById(elems) || document.querySelectorAll(elems);
    }
    elems = elems.nodeName ? [elems] : elems;
    elems.forEach(function (el) {
        if (el.inputmask) el.inputmask.remove();
    });
};
Inputmask.setValue = function (elems, value) {
    if (typeof elems === "string") {
        elems = document.getElementById(elems) || document.querySelectorAll(elems);
    }
    elems = elems.nodeName ? [elems] : elems;
    elems.forEach(function (el) {
        if (el.inputmask) el.inputmask.setValue(value); else (0,_dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"])(el).trigger("setvalue", [value]);
    });
};

Inputmask.dependencyLib = _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_1__["default"];

//make inputmask available
_global_window__WEBPACK_IMPORTED_MODULE_2__["default"].Inputmask = Inputmask;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Inputmask);


/***/ }),

/***/ "./node_modules/inputmask/lib/keycode.js":
/*!***********************************************!*\
  !*** ./node_modules/inputmask/lib/keycode.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "keyCode": () => (/* binding */ keyCode),
/* harmony export */   "keys": () => (/* binding */ keys),
/* harmony export */   "toKey": () => (/* binding */ toKey),
/* harmony export */   "toKeyCode": () => (/* binding */ toKeyCode)
/* harmony export */ });


const keyCode = {
    "AltGraph": 18,
    "ArrowDown": 40,
    "ArrowLeft": 37,
    "ArrowRight": 39,
    "ArrowUp": 38,
    "Backspace": 8,
    "BACKSPACE_SAFARI": 127,
    "CapsLock": 20,
    "Delete": 46,
    "End": 35,
    "Enter": 13,
    "Escape": 27,
    "Home": 36,
    "Insert": 45,
    "PageDown": 34,
    "PageUp": 33,
    "Space": 32,
    "Tab": 9,
    "c": 67,
    "x": 88,
    "z": 90,
    "Shift": 16,
    "Control": 17,
    "Alt": 18,
    "Pause": 19,
    "Meta_LEFT": 91,
    "Meta_RIGHT": 92,
    "ContextMenu": 93,
    "Process": 229,
    "Unidentified": 229,
    "F1": 112,
    "F2": 113,
    "F3": 114,
    "F4": 115,
    "F5": 116,
    "F6": 117,
    "F7": 118,
    "F8": 119,
    "F9": 120,
    "F10": 121,
    "F11": 122,
    "F12": 123
};

const keyCodeRev = Object.entries(keyCode).reduce((acc, [key, value]) => (acc[value] = acc[value] === undefined ? key : acc[value] , acc), {});
const keys = Object.entries(keyCode).reduce((acc, [key, value]) => (acc[key] = key === "Space" ? " " : key, acc), {});

function toKey(keyCode, shiftKey) {
    return keyCodeRev[keyCode] || (shiftKey ? String.fromCharCode(keyCode) : String.fromCharCode(keyCode).toLowerCase());
}

function toKeyCode(key) {
    return keyCode[key];
}


/***/ }),

/***/ "./node_modules/inputmask/lib/mask-lexer.js":
/*!**************************************************!*\
  !*** ./node_modules/inputmask/lib/mask-lexer.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "analyseMask": () => (/* binding */ analyseMask),
/* harmony export */   "generateMaskSet": () => (/* binding */ generateMaskSet)
/* harmony export */ });
/* harmony import */ var _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dependencyLibs/inputmask.dependencyLib */ "./node_modules/inputmask/lib/dependencyLibs/inputmask.dependencyLib.js");
/* harmony import */ var _masktoken__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./masktoken */ "./node_modules/inputmask/lib/masktoken.js");
/* harmony import */ var _inputmask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inputmask */ "./node_modules/inputmask/lib/inputmask.js");
/* harmony import */ var _escapeRegex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./escapeRegex */ "./node_modules/inputmask/lib/escapeRegex.js");







function generateMaskSet(opts, nocache) {
    var ms;

    function preProcessMask(mask, {repeat, groupmarker, quantifiermarker, keepStatic}) {
        if (repeat > 0 || repeat === "*" || repeat === "+") {
            var repeatStart = repeat === "*" ? 0 : (repeat === "+" ? 1 : repeat);
            mask = groupmarker[0] + mask + groupmarker[1] + quantifiermarker[0] + repeatStart + "," + repeat + quantifiermarker[1];
        }
        if (keepStatic === true) {
            let optionalRegex = "(.)\\[([^\\]]*)\\]", // "(?<p1>.)\\[(?<p2>[^\\]]*)\\]", remove named capture group @2428
                maskMatches = mask.match(new RegExp(optionalRegex, "g"));
            maskMatches && maskMatches.forEach((m, i) => {
                let [p1, p2] = m.split("["); p2 = p2.replace("]", "");
                mask = mask.replace(new RegExp(`${(0,_escapeRegex__WEBPACK_IMPORTED_MODULE_3__["default"])(p1)}\\[${(0,_escapeRegex__WEBPACK_IMPORTED_MODULE_3__["default"])(p2)}\\]`),
                    p1.charAt(0) === p2.charAt(0) ?
                        `(${p1}|${p1}${p2})` :
                        `${p1}[${p2}]`);
                // console.log(mask);
            });
        }

        return mask;
    }

    function generateMask(mask, metadata, opts) {
        var regexMask = false;
        if (mask === null || mask === "") {
            regexMask = opts.regex !== null;
            if (regexMask) {
                mask = opts.regex;
                mask = mask.replace(/^(\^)(.*)(\$)$/, "$2");
            } else {
                regexMask = true;
                mask = ".*";
            }
        }
        if (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {
            opts.placeholder = "";
        } //hide placeholder with single non-greedy mask
        mask = preProcessMask(mask, opts);

        // console.log(mask);
        var masksetDefinition, maskdefKey;
        maskdefKey = regexMask ? "regex_" + opts.regex : opts.numericInput ? mask.split("").reverse().join("") : mask;
        if (opts.keepStatic !== null) { //keepstatic modifies the output from the testdefinitions ~ so differentiate in the maskcache
            maskdefKey = "ks_" + opts.keepStatic + maskdefKey;
        }

        if (_inputmask__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.masksCache[maskdefKey] === undefined || nocache === true) {
            masksetDefinition = {
                "mask": mask,
                "maskToken": _inputmask__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.analyseMask(mask, regexMask, opts),
                "validPositions": [],
                "_buffer": undefined,
                "buffer": undefined,
                "tests": {},
                "excludes": {}, //excluded alternations
                "metadata": metadata,
                "maskLength": undefined,
                "jitOffset": {}
            };
            if (nocache !== true) {
                _inputmask__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.masksCache[maskdefKey] = masksetDefinition;
                masksetDefinition = _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_0__["default"].extend(true, {}, _inputmask__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.masksCache[maskdefKey]);
            }
        } else {
            masksetDefinition = _dependencyLibs_inputmask_dependencyLib__WEBPACK_IMPORTED_MODULE_0__["default"].extend(true, {}, _inputmask__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.masksCache[maskdefKey]);
        }

        return masksetDefinition;
    }

    if (typeof opts.mask === "function") { //allow mask to be a preprocessing fn - should return a valid mask
        opts.mask = opts.mask(opts);
    }
    if (Array.isArray(opts.mask)) {
        if (opts.mask.length > 1) {
            if (opts.keepStatic === null) { //enable by default when passing multiple masks when the option is not explicitly specified
                opts.keepStatic = true;
            }
            var altMask = opts.groupmarker[0];
            (opts.isRTL ? opts.mask.reverse() : opts.mask).forEach(function (msk) {
                if (altMask.length > 1) {
                    altMask += opts.alternatormarker;
                }
                if (msk.mask !== undefined && typeof msk.mask !== "function") {
                    altMask += msk.mask;
                } else {
                    altMask += msk;
                }
            });
            altMask += opts.groupmarker[1];
            // console.log(altMask);
            return generateMask(altMask, opts.mask, opts);
        } else {
            opts.mask = opts.mask.pop();
        }
    }
    if (opts.mask && opts.mask.mask !== undefined && typeof opts.mask.mask !== "function") {
        ms = generateMask(opts.mask.mask, opts.mask, opts);
    } else {
        ms = generateMask(opts.mask, opts.mask, opts);
    }
    if (opts.keepStatic === null) opts.keepStatic = false;
    return ms;
}

function analyseMask(mask, regexMask, opts) {
    const tokenizer = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g,
        //Thx to https://github.com/slevithan/regex-colorizer for the regexTokenizer regex
        regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g;
    var escaped = false,
        currentToken = new _masktoken__WEBPACK_IMPORTED_MODULE_1__["default"](),
        match,
        m,
        openenings = [],
        maskTokens = [],
        openingToken,
        currentOpeningToken,
        alternator,
        lastMatch,
        closeRegexGroup = false;

    //test definition => {fn: RegExp/function, static: true/false optionality: bool, newBlockMarker: bool, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder, mask: real maskDefinition}
    function insertTestDefinition(mtoken, element, position) {
        position = position !== undefined ? position : mtoken.matches.length;
        var prevMatch = mtoken.matches[position - 1];
        if (regexMask) {
            if (element.indexOf("[") === 0 || (escaped && /\\d|\\s|\\w|\\p/i.test(element)) || element === ".") {
                let flag = opts.casing ? "i" : "";
                if (/^\\p\{.*}$/i.test(element))
                    flag += "u";
                mtoken.matches.splice(position++, 0, {
                    fn: new RegExp(element, flag),
                    static: false,
                    optionality: false,
                    newBlockMarker: prevMatch === undefined ? "master" : prevMatch.def !== element,
                    casing: null,
                    def: element,
                    placeholder: undefined,
                    nativeDef: element
                });
            } else {
                if (escaped) element = element[element.length - 1];
                element.split("").forEach(function (lmnt, ndx) {
                    prevMatch = mtoken.matches[position - 1];
                    mtoken.matches.splice(position++, 0, {
                        fn: /[a-z]/i.test((opts.staticDefinitionSymbol || lmnt)) ? new RegExp("[" + (opts.staticDefinitionSymbol || lmnt) + "]", opts.casing ? "i" : "") : null,
                        static: true,
                        optionality: false,
                        newBlockMarker: prevMatch === undefined ? "master" : (prevMatch.def !== lmnt && prevMatch.static !== true),
                        casing: null,
                        def: opts.staticDefinitionSymbol || lmnt,
                        placeholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,
                        nativeDef: (escaped ? "'" : "") + lmnt
                    });
                });
            }
            escaped = false;
        } else {
            var maskdef = (opts.definitions && opts.definitions[element]) || (opts.usePrototypeDefinitions && _inputmask__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.definitions[element]);
            if (maskdef && !escaped) {
                mtoken.matches.splice(position++, 0, {
                    fn: maskdef.validator ? typeof maskdef.validator == "string" ? new RegExp(maskdef.validator, opts.casing ? "i" : "") : new function () {
                        this.test = maskdef.validator;
                    } : new RegExp("."),
                    static: maskdef.static || false,
                    optionality: maskdef.optional || false,
                    defOptionality: maskdef.optional || false, //indicator for an optional from the definition
                    newBlockMarker: (prevMatch === undefined || maskdef.optional) ? "master" : prevMatch.def !== (maskdef.definitionSymbol || element),
                    casing: maskdef.casing,
                    def: maskdef.definitionSymbol || element,
                    placeholder: maskdef.placeholder,
                    nativeDef: element,
                    generated: maskdef.generated
                });
            } else {
                mtoken.matches.splice(position++, 0, {
                    fn: /[a-z]/i.test((opts.staticDefinitionSymbol || element)) ? new RegExp("[" + (opts.staticDefinitionSymbol || element) + "]", opts.casing ? "i" : "") : null,
                    static: true,
                    optionality: false,
                    newBlockMarker: prevMatch === undefined ? "master" : (prevMatch.def !== element && prevMatch.static !== true),
                    casing: null,
                    def: opts.staticDefinitionSymbol || element,
                    placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,
                    nativeDef: (escaped ? "'" : "") + element
                });
                escaped = false;
            }
        }
    }

    function verifyGroupMarker(maskToken) {
        if (maskToken && maskToken.matches) {
            maskToken.matches.forEach(function (token, ndx) {
                var nextToken = maskToken.matches[ndx + 1];
                if ((nextToken === undefined || (nextToken.matches === undefined || nextToken.isQuantifier === false)) && token && token.isGroup) { //this is not a group but a normal mask => convert
                    token.isGroup = false;
                    if (!regexMask) {
                        insertTestDefinition(token, opts.groupmarker[0], 0);
                        if (token.openGroup !== true) {
                            insertTestDefinition(token, opts.groupmarker[1]);
                        }
                    }
                }
                verifyGroupMarker(token);
            });
        }
    }

    function defaultCase() {
        if (openenings.length > 0) {
            currentOpeningToken = openenings[openenings.length - 1];
            insertTestDefinition(currentOpeningToken, m);
            if (currentOpeningToken.isAlternator) { //handle alternator a | b case
                alternator = openenings.pop();
                for (var mndx = 0; mndx < alternator.matches.length; mndx++) {
                    if (alternator.matches[mndx].isGroup) alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group
                }
                if (openenings.length > 0) {
                    currentOpeningToken = openenings[openenings.length - 1];
                    currentOpeningToken.matches.push(alternator);
                } else {
                    currentToken.matches.push(alternator);
                }
            }
        } else {
            insertTestDefinition(currentToken, m);
        }
    }

    function reverseTokens(maskToken) {
        function reverseStatic(st) {
            if (st === opts.optionalmarker[0]) {
                st = opts.optionalmarker[1];
            } else if (st === opts.optionalmarker[1]) {
                st = opts.optionalmarker[0];
            } else if (st === opts.groupmarker[0]) {
                st = opts.groupmarker[1];
            } else if (st === opts.groupmarker[1]) st = opts.groupmarker[0];

            return st;
        }

        maskToken.matches = maskToken.matches.reverse();
        for (var match in maskToken.matches) {
            if (Object.prototype.hasOwnProperty.call(maskToken.matches, match)) {
                var intMatch = parseInt(match);
                if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { //reposition quantifier
                    var qt = maskToken.matches[match];
                    maskToken.matches.splice(match, 1);
                    maskToken.matches.splice(intMatch + 1, 0, qt);
                }
                if (maskToken.matches[match].matches !== undefined) {
                    maskToken.matches[match] = reverseTokens(maskToken.matches[match]);
                } else {
                    maskToken.matches[match] = reverseStatic(maskToken.matches[match]);
                }
            }
        }

        return maskToken;
    }

    function groupify(matches) {
        var groupToken = new _masktoken__WEBPACK_IMPORTED_MODULE_1__["default"](true);
        groupToken.openGroup = false;
        groupToken.matches = matches;
        return groupToken;
    }

    function closeGroup() {
        // Group closing
        openingToken = openenings.pop();
        openingToken.openGroup = false; //mark group as complete
        if (openingToken !== undefined) {
            if (openenings.length > 0) {
                currentOpeningToken = openenings[openenings.length - 1];
                currentOpeningToken.matches.push(openingToken);
                if (currentOpeningToken.isAlternator) { //handle alternator (a) | (b) case
                    alternator = openenings.pop();
                    let altMatchesLength = alternator.matches[0].matches ? alternator.matches[0].matches.length : 1;
                    for (var mndx = 0; mndx < alternator.matches.length; mndx++) {
                        alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group
                        alternator.matches[mndx].alternatorGroup = false;
                        if (opts.keepStatic === null && altMatchesLength < (alternator.matches[mndx].matches ? alternator.matches[mndx].matches.length : 1)) { //enable by default when passing multiple masks when the option is not explicitly specified
                            opts.keepStatic = true;
                        }
                        altMatchesLength = alternator.matches[mndx].matches ? alternator.matches[mndx].matches.length : 1;
                    }
                    if (openenings.length > 0) {
                        currentOpeningToken = openenings[openenings.length - 1];
                        currentOpeningToken.matches.push(alternator);
                    } else {
                        currentToken.matches.push(alternator);
                    }
                }
            } else {
                currentToken.matches.push(openingToken);
            }
        } else {
            defaultCase();
        }
    }

    function groupQuantifier(matches) {
        var lastMatch = matches.pop();
        if (lastMatch.isQuantifier) {
            lastMatch = groupify([matches.pop(), lastMatch]);
        }
        return lastMatch;
    }

    if (regexMask) {
        opts.optionalmarker[0] = undefined;
        opts.optionalmarker[1] = undefined;
    }
    while ((match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask))) {
        m = match[0];

        if (regexMask) {
            switch (m.charAt(0)) {
                //Quantifier
                case "?":
                    m = "{0,1}";
                    break;
                case "+":
                case "*":
                    m = "{" + m + "}";
                    break;
                case "|":
                    //regex mask alternator  ex: [01][0-9]|2[0-3] => ([01][0-9]|2[0-3])
                    if (openenings.length === 0) { //wrap the mask in a group to form a regex alternator  ([01][0-9]|2[0-3])
                        var altRegexGroup = groupify(currentToken.matches);
                        altRegexGroup.openGroup = true;
                        openenings.push(altRegexGroup);
                        currentToken.matches = [];
                        closeRegexGroup = true;
                    }
                    break;
            }
            switch (m) {
                case "\\d":
                    m = "[0-9]";
                    break;
                case "\\p": //Unicode Categories
                    m += regexTokenizer.exec(mask)[0]; // {
                    m += regexTokenizer.exec(mask)[0]; // ?}
                    break;
                case "(?:": //non capturing group
                case "(?=": //lookahead
                case "(?!": //negative lookahead
                case "(?<=": //lookbehind
                case "(?<!": //negative lookbehind
                    // treat as group
                    break;
            }
        }

        if (escaped) {
            defaultCase();
            continue;
        }
        switch (m.charAt(0)) {
            case "$":
            case "^":
                //ignore beginswith and endswith as in masking this makes no point
                if (!regexMask) {
                    defaultCase();
                }
                break;
            case opts.escapeChar:
                escaped = true;
                if (regexMask) defaultCase();
                break;
            // optional closing
            case opts.optionalmarker[1]:
            case opts.groupmarker[1]:
                closeGroup();
                break;
            case opts.optionalmarker[0]:
                // optional opening
                openenings.push(new _masktoken__WEBPACK_IMPORTED_MODULE_1__["default"](false, true));
                break;
            case opts.groupmarker[0]:
                // Group opening
                openenings.push(new _masktoken__WEBPACK_IMPORTED_MODULE_1__["default"](true));
                break;
            case opts.quantifiermarker[0]:
                //Quantifier
                var quantifier = new _masktoken__WEBPACK_IMPORTED_MODULE_1__["default"](false, false, true);

                m = m.replace(/[{}?]/g, ""); //? matches lazy quantifiers
                var mqj = m.split("|"),
                    mq = mqj[0].split(","),
                    mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                    mq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1])),
                    mqJit = isNaN(mqj[1]) ? mqj[1] : parseInt(mqj[1]);
                if (mq0 === "*" || mq0 === "+") {
                    mq0 = mq1 === "*" ? 0 : 1;
                }
                quantifier.quantifier = {
                    min: mq0,
                    max: mq1,
                    jit: mqJit
                };
                var matches = openenings.length > 0 ? openenings[openenings.length - 1].matches : currentToken.matches;
                match = matches.pop();
                // if (match.isAlternator) { //handle quantifier in an alternation [0-9]{2}|[0-9]{3}
                //     matches.push(match); //push back alternator
                //     matches = match.matches; //remap target matches
                //     var groupToken = new MaskToken(true);
                //     var tmpMatch = matches.pop();
                //     matches.push(groupToken); //push the group
                //     matches = groupToken.matches;
                //     match = tmpMatch;
                // }
                if (!match.isGroup) {
                    match = groupify([match]);
                }
                matches.push(match);
                matches.push(quantifier);

                break;
            case opts.alternatormarker:
                if (openenings.length > 0) {
                    currentOpeningToken = openenings[openenings.length - 1];
                    var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];
                    if (currentOpeningToken.openGroup && //regexp alt syntax
                        (subToken.matches === undefined || (subToken.isGroup === false && subToken.isAlternator === false))) { //alternations within group
                        lastMatch = openenings.pop();
                    } else {
                        lastMatch = groupQuantifier(currentOpeningToken.matches);
                    }
                } else {
                    lastMatch = groupQuantifier(currentToken.matches);
                }
                if (lastMatch.isAlternator) {
                    openenings.push(lastMatch);
                } else {
                    if (lastMatch.alternatorGroup) {
                        alternator = openenings.pop();
                        lastMatch.alternatorGroup = false;
                    } else {
                        alternator = new _masktoken__WEBPACK_IMPORTED_MODULE_1__["default"](false, false, false, true);
                    }
                    alternator.matches.push(lastMatch);
                    openenings.push(alternator);
                    if (lastMatch.openGroup) { //regexp alt syntax
                        lastMatch.openGroup = false;
                        var alternatorGroup = new _masktoken__WEBPACK_IMPORTED_MODULE_1__["default"](true);
                        alternatorGroup.alternatorGroup = true;
                        openenings.push(alternatorGroup);
                    }
                }
                break;
            default:
                defaultCase();
        }
    }

    if (closeRegexGroup) closeGroup();

    while (openenings.length > 0) {
        openingToken = openenings.pop();
        currentToken.matches.push(openingToken);
    }
    if (currentToken.matches.length > 0) {
        verifyGroupMarker(currentToken);
        maskTokens.push(currentToken);
    }

    if (opts.numericInput || opts.isRTL) {
        reverseTokens(maskTokens[0]);
    }
    // console.log(JSON.stringify(maskTokens));
    return maskTokens;
}


/***/ }),

/***/ "./node_modules/inputmask/lib/mask.js":
/*!********************************************!*\
  !*** ./node_modules/inputmask/lib/mask.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mask": () => (/* binding */ mask)
/* harmony export */ });
/* harmony import */ var _keycode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keycode.js */ "./node_modules/inputmask/lib/keycode.js");
/* harmony import */ var _positioning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./positioning */ "./node_modules/inputmask/lib/positioning.js");
/* harmony import */ var _inputHandling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inputHandling */ "./node_modules/inputmask/lib/inputHandling.js");
/* harmony import */ var _eventruler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventruler */ "./node_modules/inputmask/lib/eventruler.js");
/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./environment */ "./node_modules/inputmask/lib/environment.js");
/* harmony import */ var _validation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./validation */ "./node_modules/inputmask/lib/validation.js");
/* harmony import */ var _eventhandlers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./eventhandlers */ "./node_modules/inputmask/lib/eventhandlers.js");










//todo put on the prototype?
function mask() {
    const inputmask = this,
        opts = this.opts,
        el = this.el, $ = this.dependencyLib;


    function isElementTypeSupported(input, opts) {
        function patchValueProperty(npt) {
            var valueGet;
            var valueSet;

            function patchValhook(type) {
                if ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {
                    var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {
                        return elem.value;
                    };
                    var valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {
                        elem.value = value;
                        return elem;
                    };

                    $.valHooks[type] = {
                        get: function (elem) {
                            if (elem.inputmask) {
                                if (elem.inputmask.opts.autoUnmask) {
                                    return elem.inputmask.unmaskedvalue();
                                } else {
                                    var result = valhookGet(elem);
                                    return _positioning__WEBPACK_IMPORTED_MODULE_1__.getLastValidPosition.call(inputmask, undefined, undefined, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== true ? result : "";
                                }
                            } else {
                                return valhookGet(elem);
                            }
                        },
                        set: function (elem, value) {
                            var result = valhookSet(elem, value);
                            if (elem.inputmask) {
                                (0,_inputHandling__WEBPACK_IMPORTED_MODULE_2__.applyInputValue)(elem, value);
                            }
                            return result;
                        },
                        inputmaskpatch: true
                    };
                }
            }

            function getter() {
                if (this.inputmask) {
                    return this.inputmask.opts.autoUnmask ?
                        this.inputmask.unmaskedvalue() :
                        (_positioning__WEBPACK_IMPORTED_MODULE_1__.getLastValidPosition.call(inputmask) !== -1 || opts.nullable !== true ?
                            (((this.inputmask.shadowRoot || this.ownerDocument).activeElement) === this && opts.clearMaskOnLostFocus ?
                                (inputmask.isRTL ? _inputHandling__WEBPACK_IMPORTED_MODULE_2__.clearOptionalTail.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_1__.getBuffer.call(inputmask).slice()).reverse() : _inputHandling__WEBPACK_IMPORTED_MODULE_2__.clearOptionalTail.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_1__.getBuffer.call(inputmask).slice())).join("") :
                                valueGet.call(this)) :
                            "");
                } else {
                    return valueGet.call(this);
                }
            }

            function setter(value) {
                valueSet.call(this, value);
                if (this.inputmask) {
                    (0,_inputHandling__WEBPACK_IMPORTED_MODULE_2__.applyInputValue)(this, value);
                }
            }

            function installNativeValueSetFallback(npt) {
                _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(npt, "mouseenter", function () {
                    let input = this,
                        value = input.inputmask._valueGet(true),
                        bufferValue = (input.inputmask.isRTL ? _positioning__WEBPACK_IMPORTED_MODULE_1__.getBuffer.call(input.inputmask).slice().reverse() : _positioning__WEBPACK_IMPORTED_MODULE_1__.getBuffer.call(input.inputmask)).join("");
                    if (value != bufferValue) {
                        (0,_inputHandling__WEBPACK_IMPORTED_MODULE_2__.applyInputValue)(input, value);
                    }
                });
            }

            if (!npt.inputmask.__valueGet) {
                if (opts.noValuePatching !== true) {
                    if (Object.getOwnPropertyDescriptor) {
                        var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), "value") : undefined;
                        if (valueProperty && valueProperty.get && valueProperty.set) {
                            valueGet = valueProperty.get;
                            valueSet = valueProperty.set;
                            Object.defineProperty(npt, "value", {
                                get: getter,
                                set: setter,
                                configurable: true
                            });
                        } else if (npt.tagName.toLowerCase() !== "input") {
                            valueGet = function () {
                                return this.textContent;
                            };
                            valueSet = function (value) {
                                this.textContent = value;
                            };
                            Object.defineProperty(npt, "value", {
                                get: getter,
                                set: setter,
                                configurable: true
                            });
                        }
                    } else if (document.__lookupGetter__ && npt.__lookupGetter__("value")) {
                        valueGet = npt.__lookupGetter__("value");
                        valueSet = npt.__lookupSetter__("value");

                        npt.__defineGetter__("value", getter);
                        npt.__defineSetter__("value", setter);
                    }
                    npt.inputmask.__valueGet = valueGet; //store native property getter
                    npt.inputmask.__valueSet = valueSet; //store native property setter
                }
                npt.inputmask._valueGet = function (overruleRTL) {
                    return inputmask.isRTL && overruleRTL !== true ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el);
                };
                npt.inputmask._valueSet = function (value, overruleRTL) { //null check is needed for IE8 => otherwise converts to "null"
                    valueSet.call(this.el, (value === null || value === undefined) ? "" : ((overruleRTL !== true && inputmask.isRTL) ? value.split("").reverse().join("") : value));
                };

                if (valueGet === undefined) { //jquery.val fallback
                    valueGet = function () {
                        return this.value;
                    };
                    valueSet = function (value) {
                        this.value = value;
                    };
                    patchValhook(npt.type);
                    installNativeValueSetFallback(npt);
                }
            }
        }

        if (input.tagName.toLowerCase() !== "textarea") {
            opts.ignorables.push(_keycode_js__WEBPACK_IMPORTED_MODULE_0__.keys.Enter);
        }

        var elementType = input.getAttribute("type");
        var isSupported = (input.tagName.toLowerCase() === "input" && opts.supportsInputType.includes(elementType)) || input.isContentEditable || input.tagName.toLowerCase() === "textarea";
        if (!isSupported) {
            if (input.tagName.toLowerCase() === "input") {
                var el = document.createElement("input");
                el.setAttribute("type", elementType);
                isSupported = el.type === "text"; //apply mask only if the type is not natively supported
                el = null;
            } else {
                isSupported = "partial";
            }
        }
        if (isSupported !== false) {
            patchValueProperty(input);
        } else {
            input.inputmask = undefined;
        }
        return isSupported;
    }

    //unbind all events - to make sure that no other mask will interfere when re-masking
    _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.off(el);
    var isSupported = isElementTypeSupported(el, opts);
    if (isSupported !== false) {
        inputmask.originalPlaceholder = el.placeholder;

        //read maxlength prop from el
        inputmask.maxLength = el !== undefined ? el.maxLength : undefined;
        if (inputmask.maxLength === -1) inputmask.maxLength = undefined;
        if ("inputMode" in el && el.getAttribute("inputmode") === null) {
            el.inputMode = opts.inputmode;
            el.setAttribute("inputmode", opts.inputmode);
        }


        if (isSupported === true) {
            opts.showMaskOnFocus = opts.showMaskOnFocus && ["cc-number", "cc-exp"].indexOf(el.autocomplete) === -1;
            if (_environment__WEBPACK_IMPORTED_MODULE_4__.iphone) {
                //selecting the caret shows as a selection on iphone
                opts.insertModeVisual = false;
                //disable autocorrect
                el.setAttribute("autocorrect", "off");
            }

            //bind events
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "submit", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.submitEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "reset", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.resetEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "blur", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.blurEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "focus", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.focusEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "invalid", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.invalidEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "click", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.clickEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "mouseleave", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.mouseleaveEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "mouseenter", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.mouseenterEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "paste", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.pasteEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "cut", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.cutEvent);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "complete", opts.oncomplete);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "incomplete", opts.onincomplete);
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "cleared", opts.oncleared);
            if (opts.inputEventOnly !== true) {
                _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "keydown", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.keyEvent);
            }
            if (_environment__WEBPACK_IMPORTED_MODULE_4__.mobile || opts.inputEventOnly) {
                el.removeAttribute("maxLength");
            }
            _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "input", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.inputFallBackEvent);
            // EventRuler.on(el, "beforeinput", EventHandlers.beforeInputEvent); //https://github.com/w3c/input-events - to implement
        }
        _eventruler__WEBPACK_IMPORTED_MODULE_3__.EventRuler.on(el, "setvalue", _eventhandlers__WEBPACK_IMPORTED_MODULE_6__.EventHandlers.setValueEvent);

        //apply mask
        _positioning__WEBPACK_IMPORTED_MODULE_1__.getBufferTemplate.call(inputmask).join(""); //initialize the buffer and getmasklength
        inputmask.undoValue = inputmask._valueGet(true);
        var activeElement = (el.inputmask.shadowRoot || el.ownerDocument).activeElement;
        if (el.inputmask._valueGet(true) !== "" || opts.clearMaskOnLostFocus === false || activeElement === el) {
            (0,_inputHandling__WEBPACK_IMPORTED_MODULE_2__.applyInputValue)(el, el.inputmask._valueGet(true), opts);
            var buffer = _positioning__WEBPACK_IMPORTED_MODULE_1__.getBuffer.call(inputmask).slice();
            if (_validation__WEBPACK_IMPORTED_MODULE_5__.isComplete.call(inputmask, buffer) === false) {
                if (opts.clearIncomplete) {
                    _positioning__WEBPACK_IMPORTED_MODULE_1__.resetMaskSet.call(inputmask);
                }
            }
            if (opts.clearMaskOnLostFocus && activeElement !== el) {
                if (_positioning__WEBPACK_IMPORTED_MODULE_1__.getLastValidPosition.call(inputmask) === -1) {
                    buffer = [];
                } else {
                    _inputHandling__WEBPACK_IMPORTED_MODULE_2__.clearOptionalTail.call(inputmask, buffer);
                }
            }
            if (opts.clearMaskOnLostFocus === false || (opts.showMaskOnFocus && activeElement === el) || el.inputmask._valueGet(true) !== "") {
                (0,_inputHandling__WEBPACK_IMPORTED_MODULE_2__.writeBuffer)(el, buffer);
            }
            if (activeElement === el) { //position the caret when in focus
                _positioning__WEBPACK_IMPORTED_MODULE_1__.caret.call(inputmask, el, _positioning__WEBPACK_IMPORTED_MODULE_1__.seekNext.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_1__.getLastValidPosition.call(inputmask)));
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/inputmask/lib/masktoken.js":
/*!*************************************************!*\
  !*** ./node_modules/inputmask/lib/masktoken.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(isGroup, isOptional, isQuantifier, isAlternator) {
	this.matches = [];
	this.openGroup = isGroup || false;
	this.alternatorGroup = false;
	this.isGroup = isGroup || false;
	this.isOptional = isOptional || false;
	this.isQuantifier = isQuantifier || false;
	this.isAlternator = isAlternator || false;
	this.quantifier = {
		min: 1,
		max: 1
	};
}

/***/ }),

/***/ "./node_modules/inputmask/lib/positioning.js":
/*!***************************************************!*\
  !*** ./node_modules/inputmask/lib/positioning.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "caret": () => (/* binding */ caret),
/* harmony export */   "determineLastRequiredPosition": () => (/* binding */ determineLastRequiredPosition),
/* harmony export */   "determineNewCaretPosition": () => (/* binding */ determineNewCaretPosition),
/* harmony export */   "getBuffer": () => (/* binding */ getBuffer),
/* harmony export */   "getBufferTemplate": () => (/* binding */ getBufferTemplate),
/* harmony export */   "getLastValidPosition": () => (/* binding */ getLastValidPosition),
/* harmony export */   "isMask": () => (/* binding */ isMask),
/* harmony export */   "resetMaskSet": () => (/* binding */ resetMaskSet),
/* harmony export */   "seekNext": () => (/* binding */ seekNext),
/* harmony export */   "seekPrevious": () => (/* binding */ seekPrevious),
/* harmony export */   "translatePosition": () => (/* binding */ translatePosition)
/* harmony export */ });
/* harmony import */ var _validation_tests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validation-tests */ "./node_modules/inputmask/lib/validation-tests.js");
/* harmony import */ var _validation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validation */ "./node_modules/inputmask/lib/validation.js");





//tobe put on prototype?
function caret(input, begin, end, notranslate, isDelete) {
    const inputmask = this,
        opts = this.opts;

    var range;
    if (begin !== undefined) {
        if (Array.isArray(begin)) {
            end = inputmask.isRTL ? begin[0] : begin[1];
            begin = inputmask.isRTL ? begin[1] : begin[0];
        }
        if (begin.begin !== undefined) {
            end = inputmask.isRTL ? begin.begin : begin.end;
            begin = inputmask.isRTL ? begin.end : begin.begin;
        }
        if (typeof begin === "number") {
            begin = notranslate ? begin : translatePosition.call(inputmask, begin);
            end = notranslate ? end : translatePosition.call(inputmask, end);
            end = (typeof end == "number") ? end : begin;
            // if (!$(input).is(":visible")) {
            // 	return;
            // }

            var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
            input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;
            input.inputmask.caretPos = {begin: begin, end: end}; //track caret internally
            if (opts.insertModeVisual && opts.insertMode === false && begin === end) {
                if (!isDelete) {
                    end++; //set visualization for insert/overwrite mode
                }
            }
            if (input === (input.inputmask.shadowRoot || input.ownerDocument).activeElement) {
                if ("setSelectionRange" in input) {
                    input.setSelectionRange(begin, end);
                } else if (window.getSelection) {
                    range = document.createRange();
                    if (input.firstChild === undefined || input.firstChild === null) {
                        var textNode = document.createTextNode("");
                        input.appendChild(textNode);
                    }
                    range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);
                    range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);
                    range.collapse(true);
                    var sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                    //input.focus();
                } else if (input.createTextRange) {
                    range = input.createTextRange();
                    range.collapse(true);
                    range.moveEnd("character", end);
                    range.moveStart("character", begin);
                    range.select();
                }
            }
        }
    } else {
        if ("selectionStart" in input && "selectionEnd" in input) {
            begin = input.selectionStart;
            end = input.selectionEnd;
        } else if (window.getSelection) {
            range = window.getSelection().getRangeAt(0);
            if (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {
                begin = range.startOffset;
                end = range.endOffset;
            }
        } else if (document.selection && document.selection.createRange) {
            range = document.selection.createRange();
            begin = 0 - range.duplicate().moveStart("character", -input.inputmask._valueGet().length);
            end = begin + range.text.length;
        }

        // if (opts.insertModeVisual && opts.insertMode === false && begin === (end - 1)) end--; //correct caret for insert/overwrite mode

        /*eslint-disable consistent-return */
        return {
            "begin": notranslate ? begin : translatePosition.call(inputmask, begin),
            "end": notranslate ? end : translatePosition.call(inputmask, end)
        };
        /*eslint-enable consistent-return */
    }
}

//tobe put on prototype?
function determineLastRequiredPosition(returnDefinition) {
    const inputmask = this, {maskset, dependencyLib: $} = inputmask;

    var buffer = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getMaskTemplate.call(inputmask, true, getLastValidPosition.call(inputmask), true, true),
        bl = buffer.length,
        pos, lvp = getLastValidPosition.call(inputmask),
        positions = {},
        lvTest = maskset.validPositions[lvp],
        ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined,
        testPos;
    for (pos = lvp + 1; pos < buffer.length; pos++) {
        testPos = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTestTemplate.call(inputmask, pos, ndxIntlzr, pos - 1);
        ndxIntlzr = testPos.locator.slice();
        positions[pos] = $.extend(true, {}, testPos);
    }

    var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;
    for (pos = bl - 1; pos > lvp; pos--) {
        testPos = positions[pos];
        if ((testPos.match.optionality ||
                (testPos.match.optionalQuantifier && testPos.match.newBlockMarker) ||
                (lvTestAlt &&
                    (
                        (lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.static != true) ||
                        (testPos.match.static === true &&
                            testPos.locator[lvTest.alternation] &&
                            _validation__WEBPACK_IMPORTED_MODULE_1__.checkAlternationMatch.call(inputmask, testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) &&
                            _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTests.call(inputmask, pos)[0].def !== "")
                    )
                )) &&
            buffer[pos] === _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getPlaceholder.call(inputmask, pos, testPos.match)) {
            bl--;
        } else {
            break;
        }
    }
    return returnDefinition ? {
        "l": bl,
        "def": positions[bl] ? positions[bl].match : undefined
    } : bl;
}

//tobe put on prototype?
function determineNewCaretPosition(selectedCaret, tabbed, positionCaretOnClick) {
    const inputmask = this, {maskset, opts} = inputmask;

    function doRadixFocus(clickPos) {
        if (opts.radixPoint !== "" && opts.digits !== 0) {
            var vps = maskset.validPositions;
            if (vps[clickPos] === undefined || (vps[clickPos].input === _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getPlaceholder.call(inputmask, clickPos))) {
                if (clickPos < seekNext.call(inputmask, -1)) return true;
                var radixPos = getBuffer.call(inputmask).indexOf(opts.radixPoint);
                if (radixPos !== -1) {
                    for (let vp = 0, vpl = vps.length; vp < vpl; vp++) {
                        if (vps[vp] && radixPos < vp && vps[vp].input !== _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getPlaceholder.call(inputmask, vp)) {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    }

    if (tabbed) {
        if (inputmask.isRTL) {
            selectedCaret.end = selectedCaret.begin;
        } else {
            selectedCaret.begin = selectedCaret.end;
        }
    }
    if (selectedCaret.begin === selectedCaret.end) {
        positionCaretOnClick = positionCaretOnClick || opts.positionCaretOnClick;
        switch (positionCaretOnClick) {
            case "none":
                break;
            case "select":
                selectedCaret = {begin: 0, end: getBuffer.call(inputmask).length};
                break;
            case "ignore":
                selectedCaret.end = selectedCaret.begin = seekNext.call(inputmask, getLastValidPosition.call(inputmask));
                break;
            case "radixFocus":
                if (inputmask.clicked > 1 && maskset.validPositions.length == 0)
                    break;
                if (doRadixFocus(selectedCaret.begin)) {
                    var radixPos = getBuffer.call(inputmask).join("").indexOf(opts.radixPoint);
                    selectedCaret.end = selectedCaret.begin = opts.numericInput ? seekNext.call(inputmask, radixPos) : radixPos;
                    break;
                } //fallback to lvp
            // eslint-disable-next-line no-fallthrough
            default: //lvp:
                var clickPosition = selectedCaret.begin,
                    lvclickPosition = getLastValidPosition.call(inputmask, clickPosition, true),
                    lastPosition = seekNext.call(inputmask, (lvclickPosition === -1 && !isMask.call(inputmask, 0)) ? -1 : lvclickPosition);

                if (clickPosition <= lastPosition) {
                    selectedCaret.end = selectedCaret.begin = !isMask.call(inputmask, clickPosition, false, true) ? seekNext.call(inputmask, clickPosition) : clickPosition;
                } else {
                    var lvp = maskset.validPositions[lvclickPosition],
                        tt = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTestTemplate.call(inputmask, lastPosition, lvp ? lvp.match.locator : undefined, lvp),
                        placeholder = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getPlaceholder.call(inputmask, lastPosition, tt.match);
                    if ((placeholder !== "" && getBuffer.call(inputmask)[lastPosition] !== placeholder && tt.match.optionalQuantifier !== true && tt.match.newBlockMarker !== true) || (!isMask.call(inputmask, lastPosition, opts.keepStatic, true) && tt.match.def === placeholder)) {
                        var newPos = seekNext.call(inputmask, lastPosition);
                        if (clickPosition >= newPos || clickPosition === lastPosition) {
                            lastPosition = newPos;
                        }
                    }
                    selectedCaret.end = selectedCaret.begin = lastPosition;
                }
        }

        return selectedCaret;
    }
}


//tobe put on prototype?
function getBuffer(noCache) {
    const inputmask = this, {maskset} = inputmask;

    if (maskset.buffer === undefined || noCache === true) {
        maskset.buffer = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getMaskTemplate.call(inputmask, true, getLastValidPosition.call(inputmask), true);
        if (maskset._buffer === undefined) maskset._buffer = maskset.buffer.slice();
    }
    return maskset.buffer;
}

//tobe put on prototype?
function getBufferTemplate() {
    const inputmask = this, maskset = this.maskset;

    if (maskset._buffer === undefined) {
        //generate template
        maskset._buffer = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getMaskTemplate.call(inputmask, false, 1);
        if (maskset.buffer === undefined) maskset.buffer = maskset._buffer.slice();
    }
    return maskset._buffer;
}

//tobe put on prototype?
function getLastValidPosition(closestTo, strict, validPositions) {
    const maskset = this.maskset;

    var before = -1,
        after = -1,
        valids = validPositions || maskset.validPositions; //for use in valhook ~ context switch
    if (closestTo === undefined) closestTo = -1;
    for (var psNdx = 0, vpl = valids.length; psNdx < vpl; psNdx++) {
        if (valids[psNdx] && (strict || valids[psNdx].generatedInput !== true)) {
            if (psNdx <= closestTo) before = psNdx;
            if (psNdx >= closestTo) after = psNdx;
        }
    }
    return (before === -1 || before == closestTo) ? after : after == -1 ? before : (closestTo - before) < (after - closestTo) ? before : after;
}

//tobe put on prototype?
function isMask(pos, strict, fuzzy) {
    const inputmask = this, maskset = this.maskset;

    var test = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTestTemplate.call(inputmask, pos).match;
    if (test.def === "") test = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, pos).match;

    if (test.static !== true) {
        return test.fn;
    }
    if (fuzzy === true && (maskset.validPositions[pos] !== undefined && maskset.validPositions[pos].generatedInput !== true)) {
        return true;
    }

    if (strict !== true && pos > -1) {
        if (fuzzy) { //check on the number of tests
            var tests = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTests.call(inputmask, pos);
            return tests.length > (1 + (tests[tests.length - 1].match.def === "" ? 1 : 0));
        }
        //else based on the template
        var testTemplate = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.determineTestTemplate.call(inputmask, pos, _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTests.call(inputmask, pos));
        var testPlaceHolder = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getPlaceholder.call(inputmask, pos, testTemplate.match);
        return testTemplate.match.def !== testPlaceHolder;

    }
    return false;
}

//tobe put on prototype?
function resetMaskSet(soft) {
    const maskset = this.maskset;

    maskset.buffer = undefined;
    if (soft !== true) {
        maskset.validPositions = [];
        maskset.p = 0;
    }
}

//tobe put on prototype?
function seekNext(pos, newBlock, fuzzy) {
    const inputmask = this;

    if (fuzzy === undefined) fuzzy = true;
    var position = pos + 1;
    while (_validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, position).match.def !== "" &&
    ((newBlock === true && (_validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, position).match.newBlockMarker !== true || !isMask.call(inputmask, position, undefined, true))) ||
        (newBlock !== true && !isMask.call(inputmask, position, undefined, fuzzy)))) {
        position++;
    }
    return position;
}

//tobe put on prototype?
function seekPrevious(pos, newBlock) {
    const inputmask = this;

    var position = pos - 1;
    if (pos <= 0) return 0;

    while (position > 0 &&
    ((newBlock === true && (_validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, position).match.newBlockMarker !== true || !isMask.call(inputmask, position, undefined, true))) ||
        (newBlock !== true && !isMask.call(inputmask, position, undefined, true)))) {
        position--;
    }
    return position;
}

//tobe put on prototype?
function translatePosition(pos) {
    const inputmask = this,
        opts = this.opts,
        el = this.el;

    if (inputmask.isRTL && typeof pos === "number" && (!opts.greedy || opts.placeholder !== "") && el) {
        pos = inputmask._valueGet().length - pos;
        if (pos < 0) pos = 0;
    }
    return pos;
}


/***/ }),

/***/ "./node_modules/inputmask/lib/validation-tests.js":
/*!********************************************************!*\
  !*** ./node_modules/inputmask/lib/validation-tests.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "determineTestTemplate": () => (/* binding */ determineTestTemplate),
/* harmony export */   "getDecisionTaker": () => (/* binding */ getDecisionTaker),
/* harmony export */   "getMaskTemplate": () => (/* binding */ getMaskTemplate),
/* harmony export */   "getPlaceholder": () => (/* binding */ getPlaceholder),
/* harmony export */   "getTest": () => (/* binding */ getTest),
/* harmony export */   "getTestTemplate": () => (/* binding */ getTestTemplate),
/* harmony export */   "getTests": () => (/* binding */ getTests),
/* harmony export */   "isSubsetOf": () => (/* binding */ isSubsetOf)
/* harmony export */ });
/* harmony import */ var _inputmask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inputmask */ "./node_modules/inputmask/lib/inputmask.js");



function getLocator(tst, align) { //need to align the locators to be correct
    var locator = (tst.alternation != undefined ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join("");
    if (locator !== "") while (locator.length < align) locator += "0";
    return locator;
}

function getDecisionTaker(tst) {
    var decisionTaker = tst.locator[tst.alternation];
    if (typeof decisionTaker == "string" && decisionTaker.length > 0) { //no decision taken ~ take first one as decider
        decisionTaker = decisionTaker.split(",")[0];
    }
    return decisionTaker !== undefined ? decisionTaker.toString() : "";
}

//tobe put on prototype?
function getPlaceholder(pos, test, returnPL) {
    const inputmask = this,
        opts = this.opts,
        maskset = this.maskset;

    test = test || getTest.call(inputmask, pos).match;
    if (test.placeholder !== undefined || returnPL === true) {
        return typeof test.placeholder === "function" ? test.placeholder(opts) : test.placeholder;
    } else if (test.static === true) {
        if (pos > -1 && maskset.validPositions[pos] === undefined) {
            var tests = getTests.call(inputmask, pos),
                staticAlternations = [],
                prevTest;
            if (tests.length > 1 + (tests[tests.length - 1].match.def === "" ? 1 : 0)) {
                for (var i = 0; i < tests.length; i++) {
                    if (tests[i].match.def !== "" && tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true &&
                        (tests[i].match.static === true || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, maskset, pos, true, opts) !== false))) {
                        staticAlternations.push(tests[i]);
                        if (tests[i].match.static === true) prevTest = tests[i];
                        if (staticAlternations.length > 1) {
                            if (/[0-9a-bA-Z]/.test(staticAlternations[0].match.def)) {
                                return opts.placeholder.charAt(pos % opts.placeholder.length);
                            }
                        }
                    }
                }
            }
        }
        return test.def;
    }

    return opts.placeholder.charAt(pos % opts.placeholder.length);
}

//tobe put on prototype?
function getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {
    //includeMode true => input, undefined => placeholder, false => mask

    var inputmask = this,
        opts = this.opts,
        maskset = this.maskset;


    var greedy = opts.greedy;
    if (clearOptionalTail && opts.greedy) {
        opts.greedy = false;
        inputmask.maskset.tests = {};
    }
    minimalPos = minimalPos || 0;
    var maskTemplate = [],
        ndxIntlzr, pos = 0,
        test, testPos, jitRenderStatic;
    do {
        if (baseOnInput === true && maskset.validPositions[pos]) {
            testPos = (clearOptionalTail && maskset.validPositions[pos].match.optionality
                && maskset.validPositions[pos + 1] === undefined
                && (maskset.validPositions[pos].generatedInput === true || (maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && pos > 0)))
                ? determineTestTemplate.call(inputmask, pos, getTests.call(inputmask, pos, ndxIntlzr, pos - 1))
                : maskset.validPositions[pos];
            test = testPos.match;
            ndxIntlzr = testPos.locator.slice();
            maskTemplate.push(includeMode === true ? testPos.input : includeMode === false ? test.nativeDef : getPlaceholder.call(inputmask, pos, test));
        } else {
            testPos = getTestTemplate.call(inputmask, pos, ndxIntlzr, pos - 1);
            test = testPos.match;
            ndxIntlzr = testPos.locator.slice();
            var jitMasking = noJit === true ? false : (opts.jitMasking !== false ? opts.jitMasking : test.jit);
            //check for groupSeparator is a hack for the numerics as we don't want the render of the groupSeparator beforehand
            jitRenderStatic = ((jitRenderStatic && test.static && test.def !== opts.groupSeparator && test.fn === null) || (maskset.validPositions[pos - 1] && test.static && test.def !== opts.groupSeparator && test.fn === null)) && maskset.tests[pos] /*&& maskset.tests[pos].length === 1*/;
            if (jitRenderStatic || jitMasking === false || jitMasking === undefined /*|| pos < lvp*/ || (typeof jitMasking === "number" && isFinite(jitMasking) && jitMasking > pos)) {
                maskTemplate.push(includeMode === false ? test.nativeDef : getPlaceholder.call(inputmask, maskTemplate.length, test));
            } else {
                jitRenderStatic = false;
            }
        }

        pos++;
    } while ((test.static !== true || test.def !== "") || minimalPos > pos);
    if (maskTemplate[maskTemplate.length - 1] === "") {
        maskTemplate.pop(); //drop the last one which is empty
    }
    if (includeMode !== false || //do not alter the masklength when just retrieving the maskdefinition
        maskset.maskLength === undefined) //just make sure the maskLength gets initialized in all cases (needed for isValid)
    {
        maskset.maskLength = pos - 1;
    }

    opts.greedy = greedy;
    return maskTemplate;
}

//tobe put on prototype?
function getTestTemplate(pos, ndxIntlzr, tstPs) {
    var inputmask = this,
        maskset = this.maskset;

    return maskset.validPositions[pos] || determineTestTemplate.call(inputmask, pos, getTests.call(inputmask, pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));
}

//tobe put on prototype?
function determineTestTemplate(pos, tests) {
    var inputmask = this,
        opts = this.opts,
        lenghtOffset = 0;
    var optionalityLevel = determineOptionalityLevel(pos, tests);
    pos = pos > 0 ? pos - 1 : 0;
    var altTest = getTest.call(inputmask, pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch;
    if (opts.greedy && tests.length > 1 && tests[tests.length - 1].match.def === "")
        lenghtOffset = 1;
    // console.log(" optionality = " + optionalityLevel);
    // console.log(" - " + JSON.stringify(tests));
    for (var ndx = 0; ndx < tests.length - lenghtOffset; ndx++) { //find best matching
        var tst = tests[ndx];
        tstLocator = getLocator(tst, targetLocator.length);
        var distance = Math.abs(tstLocator - targetLocator);

        if (closest === undefined
            || (tstLocator !== "" && distance < closest)
            || (bestMatch && !opts.greedy &&
                (bestMatch.match.optionality && bestMatch.match.optionality - optionalityLevel > 0) &&
                bestMatch.match.newBlockMarker === "master" &&
                ((!tst.match.optionality || tst.match.optionality - optionalityLevel < 1) || !tst.match.newBlockMarker))
            || (bestMatch && !opts.greedy && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier)) {
            closest = distance;
            bestMatch = tst;
        }
    }
    return bestMatch;
}

function determineOptionalityLevel(pos, tests) {
    let optionalityLevel = 0, differentOptionalLevels = false;
    tests.forEach(test => {
        if (test.match.optionality) {
            if (optionalityLevel !== 0 && optionalityLevel !== test.match.optionality)
                differentOptionalLevels = true;
            if (optionalityLevel === 0 || optionalityLevel > test.match.optionality) {
                optionalityLevel = test.match.optionality;
            }
        }
    });
    if (optionalityLevel) {
        if (pos == 0) optionalityLevel = 0;
        else if (tests.length == 1) optionalityLevel = 0;
        else if (!differentOptionalLevels) optionalityLevel = 0;
    }
    return optionalityLevel;
}

//tobe put on prototype?
function getTest(pos, tests) {
    var inputmask = this,
        maskset = this.maskset;

    if (maskset.validPositions[pos]) {
        return maskset.validPositions[pos];
    }
    return (tests || getTests.call(inputmask, pos))[0];
}

function isSubsetOf(source, target, opts) {
    function expand(pattern) {
        var expanded = [], start = -1, end;
        for (var i = 0, l = pattern.length; i < l; i++) {
            if (pattern.charAt(i) === "-") {
                end = pattern.charCodeAt(i + 1);
                while (++start < end) expanded.push(String.fromCharCode(start));
            } else {
                start = pattern.charCodeAt(i);
                expanded.push(pattern.charAt(i));
            }
        }
        return expanded.join("");
    }

    if (source.match.def === target.match.nativeDef) return true;
    if ((opts.regex || (source.match.fn instanceof RegExp && target.match.fn instanceof RegExp)) && source.match.static !== true && target.match.static !== true) { //is regex a subset
        return expand(target.match.fn.toString().replace(/[[\]/]/g, "")).indexOf(expand(source.match.fn.toString().replace(/[[\]/]/g, ""))) !== -1;
    }
    return false;
}

//tobe put on prototype?
function getTests(pos, ndxIntlzr, tstPs) {
    var inputmask = this,
        $ = this.dependencyLib,
        maskset = this.maskset,
        opts = this.opts,
        el = this.el,
        maskTokens = maskset.maskToken,
        testPos = ndxIntlzr ? tstPs : 0,
        ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],
        matches = [],
        insertStop = false,
        latestMatch,
        cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";

    function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitializer contains a set of indexes to speedup searches in the mtokens
        function handleMatch(match, loopNdx, quantifierRecurse) {
            function isFirstMatch(latestMatch, tokenGroup) {
                var firstMatch = tokenGroup.matches.indexOf(latestMatch) === 0;
                if (!firstMatch) {
                    tokenGroup.matches.every(function (match, ndx) {
                        if (match.isQuantifier === true) {
                            firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]);
                        } else if (Object.prototype.hasOwnProperty.call(match, "matches")) firstMatch = isFirstMatch(latestMatch, match);
                        if (firstMatch) return false;

                        return true;
                    });
                }
                return firstMatch;
            }

            function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {
                var bestMatch, indexPos;

                if (maskset.tests[pos] || maskset.validPositions[pos]) {
                    (maskset.tests[pos] || [maskset.validPositions[pos]]).every(function (lmnt, ndx) {
                        if (lmnt.mloc[alternateNdx]) {
                            bestMatch = lmnt;
                            return false; //break
                        }
                        var alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation,
                            ndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;
                        if ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {
                            bestMatch = lmnt;
                            indexPos = ndxPos;
                        }

                        return true;
                    });
                }
                if (bestMatch) {
                    var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation];
                    var locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;
                    return locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1);
                } else {
                    return targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;
                }
            }

            function staticCanMatchDefinition(source, target) {
                return source.match.static === true && target.match.static !== true ? target.match.fn.test(source.match.def, maskset, pos, false, opts, false) : false;
            }

            //mergelocators for retrieving the correct locator match when merging
            function setMergeLocators(targetMatch, altMatch) {
                var alternationNdx = targetMatch.alternation,
                    shouldMerge = altMatch === undefined || (alternationNdx === altMatch.alternation &&
                        targetMatch.locator[alternationNdx].toString().indexOf(altMatch.locator[alternationNdx]) === -1);
                if (!shouldMerge && alternationNdx > altMatch.alternation) {
                    for (var i = altMatch.alternation; i < alternationNdx; i++) {
                        if (targetMatch.locator[i] !== altMatch.locator[i]) {
                            alternationNdx = i;
                            shouldMerge = true;
                            break;
                        }
                    }
                }

                if (shouldMerge) {
                    targetMatch.mloc = targetMatch.mloc || {};
                    var locNdx = targetMatch.locator[alternationNdx];
                    if (locNdx === undefined) {
                        targetMatch.alternation = undefined;
                    } else {
                        if (typeof locNdx === "string") locNdx = locNdx.split(",")[0];
                        if (targetMatch.mloc[locNdx] === undefined) targetMatch.mloc[locNdx] = targetMatch.locator.slice();
                        if (altMatch !== undefined) {
                            for (var ndx in altMatch.mloc) {
                                if (typeof ndx === "string") ndx = ndx.split(",")[0];
                                if (targetMatch.mloc[ndx] === undefined) targetMatch.mloc[ndx] = altMatch.mloc[ndx];
                            }
                            targetMatch.locator[alternationNdx] = Object.keys(targetMatch.mloc).join(",");
                        }
                        return true;
                    }
                }
                return false;
            }

            function isSameLevel(targetMatch, altMatch) {
                if (targetMatch.locator.length !== altMatch.locator.length) {
                    return false;
                }
                for (let locNdx = targetMatch.alternation + 1; locNdx < targetMatch.locator.length; locNdx++) {
                    if (targetMatch.locator[locNdx] !== altMatch.locator[locNdx]) {
                        return false;
                    }
                }
                return true;
            }

            function handleGroup() {
                match = handleMatch(maskToken.matches[maskToken.matches.indexOf(match) + 1], loopNdx, quantifierRecurse);
                if (match) return true;
            }

            function handleOptional() {
                var optionalToken = match, mtchsNdx = matches.length;
                match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);
                if (matches.length > 0) { //check on matches.length instead of match to handle quantifier in a recursive call
                    //mark optionality in matches
                    matches.forEach(function (mtch, ndx) {
                        if (ndx >= mtchsNdx) {
                            mtch.match.optionality = mtch.match.optionality ? mtch.match.optionality + 1 : 1;
                        }
                    });
                    latestMatch = matches[matches.length - 1].match;

                    if (quantifierRecurse === undefined && isFirstMatch(latestMatch, optionalToken)) { //prevent loop see #698
                        insertStop = true; //insert a stop
                        testPos = pos; //match the position after the group
                    } else {
                        return match; //make the loop continue when it is deliberately by a quantifier
                    }
                }
            }

            function handleAlternator() {
                inputmask.hasAlternator = true;
                var alternateToken = match,
                    malternateMatches = [],
                    maltMatches,
                    currentMatches = matches.slice(),
                    loopNdxCnt = loopNdx.length,
                    unMatchedAlternation = false;
                var altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;
                if (altIndex === -1 || typeof altIndex === "string") {
                    var currentPos = testPos,
                        ndxInitializerClone = ndxInitializer.slice(),
                        altIndexArr = [],
                        amndx;
                    if (typeof altIndex == "string") {
                        altIndexArr = altIndex.split(",");
                    } else {
                        for (amndx = 0; amndx < alternateToken.matches.length; amndx++) {
                            altIndexArr.push(amndx.toString());
                        }
                    }

                    if (maskset.excludes[pos] !== undefined) {
                        var altIndexArrClone = altIndexArr.slice();
                        for (var i = 0, exl = maskset.excludes[pos].length; i < exl; i++) {
                            var excludeSet = maskset.excludes[pos][i].toString().split(":");
                            if (loopNdx.length == excludeSet[1]) {
                                altIndexArr.splice(altIndexArr.indexOf(excludeSet[0]), 1);
                            }
                        }
                        if (altIndexArr.length === 0) { //fully alternated => reset
                            delete maskset.excludes[pos];
                            altIndexArr = altIndexArrClone;
                        }
                    }
                    if (opts.keepStatic === true || (isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic)) altIndexArr = altIndexArr.slice(0, 1);
                    for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
                        amndx = parseInt(altIndexArr[ndx]);
                        matches = [];
                        //set the correct ndxInitializer
                        ndxInitializer = typeof altIndex === "string" ? resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice() : ndxInitializerClone.slice();
                        var tokenMatch = alternateToken.matches[amndx];
                        if (tokenMatch && handleMatch(tokenMatch, [amndx].concat(loopNdx), quantifierRecurse)) {
                            match = true;
                        } else {
                            if (ndx === 0) {
                                unMatchedAlternation = true;
                            }
                            if (tokenMatch && tokenMatch.matches && tokenMatch.matches.length > alternateToken.matches[0].matches.length) {
                                break;
                            }
                        }

                        maltMatches = matches.slice();
                        testPos = currentPos;
                        matches = [];

                        //fuzzy merge matches
                        for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                            var altMatch = maltMatches[ndx1],
                                dropMatch = false;
                            altMatch.match.jit = altMatch.match.jit || unMatchedAlternation; //mark jit when there are unmatched alternations  ex: mask: "(a|aa)"
                            altMatch.alternation = altMatch.alternation || loopNdxCnt;
                            setMergeLocators(altMatch);
                            for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
                                var altMatch2 = malternateMatches[ndx2];
                                if (typeof altIndex !== "string" || (altMatch.alternation !== undefined && altIndexArr.includes(altMatch.locator[altMatch.alternation].toString()))) {
                                    if (altMatch.match.nativeDef === altMatch2.match.nativeDef) {
                                        dropMatch = true;
                                        setMergeLocators(altMatch2, altMatch);
                                        break;
                                    } else if (isSubsetOf(altMatch, altMatch2, opts)) {
                                        if (setMergeLocators(altMatch, altMatch2)) {
                                            dropMatch = true;
                                            malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);
                                        }
                                        break;
                                    } else if (isSubsetOf(altMatch2, altMatch, opts)) {
                                        setMergeLocators(altMatch2, altMatch);
                                        break;
                                    } else if (staticCanMatchDefinition(altMatch, altMatch2)) {
                                        if (!isSameLevel(altMatch, altMatch2) && el.inputmask.userOptions.keepStatic === undefined) {
                                            opts.keepStatic = true;
                                        } else if (setMergeLocators(altMatch, altMatch2)) {
                                            //insert match above general match
                                            dropMatch = true;
                                            malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);
                                        }
                                        break;
                                    }
                                }
                            }
                            if (!dropMatch) {
                                malternateMatches.push(altMatch);
                            }
                        }
                    }

                    matches = currentMatches.concat(malternateMatches);
                    testPos = pos;
                    insertStop = matches.length > 0; //insert a stopelemnt when there is an alternate - needed for non-greedy option
                    match = malternateMatches.length > 0; //set correct match state

                    //cloneback
                    ndxInitializer = ndxInitializerClone.slice();
                } else {
                    match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);
                }
                if (match) return true;
            }

            function handleQuantifier() {
                var qt = match, breakloop = false;
                for (var qndx = (ndxInitializer.length > 0) ? ndxInitializer.shift() : 0; (qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {
                    var tokenGroup = maskToken.matches[maskToken.matches.indexOf(qt) - 1];
                    match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup); //set the tokenGroup as quantifierRecurse marker
                    if (match) {
                        matches.forEach(function (mtch, ndx) {
                            if (IsMatchOf(tokenGroup, mtch.match))
                                latestMatch = mtch.match;
                            else latestMatch = matches[matches.length - 1].match;

                            //mark optionality
                            //TODO FIX RECURSIVE QUANTIFIERS
                            latestMatch.optionalQuantifier = qndx >= qt.quantifier.min;
                            // console.log(pos + " " + qt.quantifier.min + " " + latestMatch.optionalQuantifier);
                            //qndx + 1 as the index starts from 0
                            latestMatch.jit = (qndx + 1) * (tokenGroup.matches.indexOf(latestMatch) + 1) > qt.quantifier.jit;
                            if (latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {
                                insertStop = true;
                                testPos = pos; //match the position after the group
                                if (opts.greedy && maskset.validPositions[pos - 1] == undefined && qndx > qt.quantifier.min && ["*", "+"].indexOf(qt.quantifier.max) != -1) {
                                    matches.pop();
                                    cacheDependency = undefined;
                                }
                                breakloop = true; //stop quantifierloop && search for next possible match
                                match = false; //mark match to false to make sure the loop in optionals continues
                            }
                            if (!breakloop && latestMatch.jit /*&& !latestMatch.optionalQuantifier*/) {
                                //always set jitOffset, isvalid checks when to apply
                                maskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch);
                            }
                        });
                        if (breakloop) break; // search for next possible match
                        return true;
                    }
                }
            }

            if (testPos > (pos + opts._maxTestPos)) {
                throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + maskset.mask;
            }
            if (testPos === pos && match.matches === undefined) {
                matches.push({
                    "match": match,
                    "locator": loopNdx.reverse(),
                    "cd": cacheDependency,
                    "mloc": {}
                });
                if (match.optionality && quantifierRecurse === undefined &&
                    ((opts.definitions && opts.definitions[match.nativeDef] && opts.definitions[match.nativeDef].optional) ||
                        (_inputmask__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.definitions[match.nativeDef] && _inputmask__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.definitions[match.nativeDef].optional))) { //prevent loop see #698
                    insertStop = true; //insert a stop
                    testPos = pos; //match the position after the group
                } else {
                    return true;
                }
            } else if (match.matches !== undefined) {
                if (match.isGroup && quantifierRecurse !== match) { //when a group pass along to the quantifier
                    return handleGroup();
                } else if (match.isOptional) {
                    return handleOptional();
                } else if (match.isAlternator) {
                    return handleAlternator();
                } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[maskToken.matches.indexOf(match) - 1]) {
                    return handleQuantifier();
                } else {
                    match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);
                    if (match) return true;
                }
            } else {
                testPos++;
            }
        }

        //the offset is set in the quantifierloop when git masking is used
        for (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0); tndx < maskToken.matches.length; tndx++) {
            if (maskToken.matches[tndx].isQuantifier !== true) {
                var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);
                if (match && testPos === pos) {
                    return match;
                } else if (testPos > pos) {
                    break;
                }
            }
        }
    }

    function IsMatchOf(tokenGroup, match) {
        let isMatch = tokenGroup.matches.indexOf(match) != -1;
        if (!isMatch) {
            tokenGroup.matches.forEach((mtch, ndx) => {
                if (mtch.matches !== undefined && !isMatch) {
                    isMatch = IsMatchOf(mtch, match);
                }
            });
        }
        return isMatch;
    }

    function mergeLocators(pos, tests) {
        let locator = [], alternation;
        if (!Array.isArray(tests)) tests = [tests];

        if (tests.length > 0) {
            if (tests[0].alternation === undefined || opts.keepStatic === true) {
                locator = determineTestTemplate.call(inputmask, pos, tests.slice()).locator.slice();
                if (locator.length === 0) locator = tests[0].locator.slice();
            } else {
                tests.forEach(function (tst) {
                    if (tst.def !== "") {
                        if (locator.length === 0) {
                            alternation = tst.alternation;
                            locator = tst.locator.slice();
                        } else {
                            if (tst.locator[alternation] && locator[alternation].toString().indexOf(tst.locator[alternation]) === -1) {
                                locator[alternation] += "," + tst.locator[alternation];
                            }
                        }
                    }
                });
            }
        }
        return locator;
    }

    if (pos > -1) {
        if (ndxIntlzr === undefined) { //determine index initializer
            var previousPos = pos - 1,
                test;
            while ((test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) === undefined && previousPos > -1) {
                previousPos--;
            }
            if (test !== undefined && previousPos > -1) {
                ndxInitializer = mergeLocators(previousPos, test);
                cacheDependency = ndxInitializer.join("");
                testPos = previousPos;
            }
        }
        if (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) { //cacheDependency is set on all tests, just check on the first
            return maskset.tests[pos];
        }
        for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {
            var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);
            if ((match && testPos === pos) || testPos > pos) {
                break;
            }
        }
    }
    if (matches.length === 0 || insertStop) {
        matches.push({
            match: {
                fn: null,
                static: true,
                optionality: false,
                casing: null,
                def: "",
                placeholder: ""
            },
            locator: [],
            mloc: {},
            cd: cacheDependency
        });
    }
    var result;
    if (ndxIntlzr !== undefined && maskset.tests[pos]) { //prioritize full tests for caching
        result = $.extend(true, [], matches);
    } else {
        maskset.tests[pos] = $.extend(true, [], matches); //set a clone to prevent overwriting some props
        result = maskset.tests[pos];
    }

    // console.log(pos + " - " + JSON.stringify(matches));
    //cleanup optionality marking
    matches.forEach(t => {
        t.match.optionality = t.match.defOptionality || false;
    });

    return result;
}


/***/ }),

/***/ "./node_modules/inputmask/lib/validation.js":
/*!**************************************************!*\
  !*** ./node_modules/inputmask/lib/validation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "alternate": () => (/* binding */ alternate),
/* harmony export */   "checkAlternationMatch": () => (/* binding */ checkAlternationMatch),
/* harmony export */   "handleRemove": () => (/* binding */ handleRemove),
/* harmony export */   "isComplete": () => (/* binding */ isComplete),
/* harmony export */   "isSelection": () => (/* binding */ isSelection),
/* harmony export */   "isValid": () => (/* binding */ isValid),
/* harmony export */   "refreshFromBuffer": () => (/* binding */ refreshFromBuffer),
/* harmony export */   "revalidateMask": () => (/* binding */ revalidateMask)
/* harmony export */ });
/* harmony import */ var _validation_tests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validation-tests */ "./node_modules/inputmask/lib/validation-tests.js");
/* harmony import */ var _keycode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keycode.js */ "./node_modules/inputmask/lib/keycode.js");
/* harmony import */ var _positioning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./positioning */ "./node_modules/inputmask/lib/positioning.js");
/* harmony import */ var _eventhandlers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventhandlers */ "./node_modules/inputmask/lib/eventhandlers.js");







//tobe put on prototype?
function alternate(maskPos, c, strict, fromIsValid, rAltPos, selection) { //pos == true => generalize
    const inputmask = this,
        $ = this.dependencyLib,
        opts = this.opts,
        maskset = inputmask.maskset;

    var validPsClone = $.extend(true, [], maskset.validPositions),
        tstClone = $.extend(true, {}, maskset.tests),
        lastAlt,
        alternation,
        isValidRslt = false, returnRslt = false,
        altPos, prevAltPos, i, validPos,
        decisionPos,
        lAltPos = rAltPos !== undefined ? rAltPos : _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask), nextPos, input, begin, end;

    if (selection) {
        begin = selection.begin;
        end = selection.end;
        if (selection.begin > selection.end) {
            begin = selection.end;
            end = selection.begin;
        }
    }
    if (lAltPos === -1 && rAltPos === undefined) { //do not recurse when already paste the beginning
        lastAlt = 0;
        prevAltPos = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, lastAlt);
        alternation = prevAltPos.alternation;
    } else {
        //find last modified alternation
        for (; lAltPos >= 0; lAltPos--) {
            altPos = maskset.validPositions[lAltPos];
            if (altPos && altPos.alternation !== undefined) {
                if (lAltPos <= (maskPos || 0) && prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {
                    break;
                }
                lastAlt = lAltPos;
                alternation = maskset.validPositions[lastAlt].alternation;
                prevAltPos = altPos;
            }
        }
    }

    if (alternation !== undefined) {
        decisionPos = parseInt(lastAlt);
        maskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [];
        if (maskPos !== true) { //generalize
            maskset.excludes[decisionPos].push((0,_validation_tests__WEBPACK_IMPORTED_MODULE_0__.getDecisionTaker)(prevAltPos) + ":" + prevAltPos.alternation);
        }

        var validInputs = [], resultPos = -1;
        for (i = decisionPos; i < _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask, undefined, true) + 1; i++) {
            if (resultPos === -1 && maskPos <= i && c !== undefined) {
                validInputs.push(c);
                resultPos = validInputs.length - 1;
            }
            validPos = maskset.validPositions[i];
            if (validPos && validPos.generatedInput !== true && (selection === undefined || (i < begin || i >= end))) {
                validInputs.push(validPos.input);
            }
            delete maskset.validPositions[i];
        }
        if (resultPos === -1 && c !== undefined) {
            validInputs.push(c);
            resultPos = validInputs.length - 1;
        }

        while (maskset.excludes[decisionPos] !== undefined && maskset.excludes[decisionPos].length < 10) {
            // maskset.tests[decisionPos] = undefined; //clear decisionPos
            maskset.tests = {};  //clear all
            _positioning__WEBPACK_IMPORTED_MODULE_2__.resetMaskSet.call(inputmask, true); //clear getbuffer
            isValidRslt = true;
            for (i = 0; i < validInputs.length; i++) {
                nextPos = isValidRslt.caret || (_positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask, undefined, true) + 1);
                input = validInputs[i];
                // nextPos = translatePosition.call(inputmask, nextPos);
                if (!(isValidRslt = isValid.call(inputmask, nextPos, input, false, fromIsValid, true))) {
                    break;
                }
                if (i === resultPos) {
                    returnRslt = isValidRslt;
                }
                if (maskPos == true && isValidRslt) {  //return validposition on generalise
                    returnRslt = {caretPos: i};
                }
            }
            if (!isValidRslt) {
                _positioning__WEBPACK_IMPORTED_MODULE_2__.resetMaskSet.call(inputmask);
                prevAltPos = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, decisionPos);  //get the current decisionPos to exclude ~ needs to be before restoring the initial validation
                //reset & revert
                maskset.validPositions = $.extend(true, [], validPsClone);
                maskset.tests = $.extend(true, {}, tstClone); //refresh tests after possible alternating
                if (maskset.excludes[decisionPos]) {
                    var decisionTaker = (0,_validation_tests__WEBPACK_IMPORTED_MODULE_0__.getDecisionTaker)(prevAltPos);
                    if (maskset.excludes[decisionPos].indexOf(decisionTaker + ":" + prevAltPos.alternation) !== -1) {
                        returnRslt = alternate.call(inputmask, maskPos, c, strict, fromIsValid, decisionPos - 1, selection);
                        break;
                    }
                    maskset.excludes[decisionPos].push(decisionTaker + ":" + prevAltPos.alternation);
                    for (i = decisionPos; i < _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask, undefined, true) + 1; i++) delete maskset.validPositions[i];
                } else { //latest alternation
                    returnRslt = alternate.call(inputmask, maskPos, c, strict, fromIsValid, decisionPos - 1, selection);
                    break;
                }
            } else {
                break;
            }
        }
    }
    //reset alternation excludes
    if (!returnRslt || opts.keepStatic !== false) {
        delete maskset.excludes[decisionPos];
    }
    return returnRslt;
}

function casing(elem, test, pos) {
    const opts = this.opts,
        maskset = this.maskset;

    switch (opts.casing || test.casing) {
        case "upper":
            elem = elem.toUpperCase();
            break;
        case "lower":
            elem = elem.toLowerCase();
            break;
        case "title":
            var posBefore = maskset.validPositions[pos - 1];
            if (pos === 0 || posBefore && posBefore.input === String.fromCharCode(_keycode_js__WEBPACK_IMPORTED_MODULE_1__.keyCode.Space)) {
                elem = elem.toUpperCase();
            } else {
                elem = elem.toLowerCase();
            }
            break;
        default:
            if (typeof opts.casing === "function") {
                var args = Array.prototype.slice.call(arguments);
                args.push(maskset.validPositions);
                elem = opts.casing.apply(this, args);
            }
    }

    return elem;
}

//tobe put on prototype?
function checkAlternationMatch(altArr1, altArr2, na) {
    const opts = this.opts;

    var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),
        isMatch = false,
        naArr = na !== undefined ? na.split(",") : [],
        naNdx;

    //remove no alternate indexes from alternation array
    for (var i = 0; i < naArr.length; i++) {
        if ((naNdx = altArr1.indexOf(naArr[i])) !== -1) {
            altArr1.splice(naNdx, 1);
        }
    }

    for (var alndx = 0; alndx < altArr1.length; alndx++) {
        if (altArrC.includes(altArr1[alndx])) {
            isMatch = true;
            break;
        }
    }
    return isMatch;
}

//tobe put on prototype?
function handleRemove(input, c, pos, strict, fromIsValid) {
    const inputmask = this, maskset = this.maskset, opts = this.opts;

    if (opts.numericInput || inputmask.isRTL) {
        if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Backspace) {
            c = _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Delete;
        } else if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Delete) {
            c = _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Backspace;
        }

        if (inputmask.isRTL) {
            var pend = pos.end;
            pos.end = pos.begin;
            pos.begin = pend;
        }
    }

    var lvp = _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask, undefined, true);
    if (pos.end >= _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask).length && lvp >= pos.end) { //handle numeric negate symbol offset, due to  dynamic jit masking
        pos.end = lvp + 1;
    }

    if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Backspace) {
        if ((pos.end - pos.begin < 1)) {
            pos.begin = _positioning__WEBPACK_IMPORTED_MODULE_2__.seekPrevious.call(inputmask, pos.begin);
        }
    } else if (c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Delete) {
        if (pos.begin === pos.end) {
            pos.end = _positioning__WEBPACK_IMPORTED_MODULE_2__.isMask.call(inputmask, pos.end, true, true) ? pos.end + 1 : _positioning__WEBPACK_IMPORTED_MODULE_2__.seekNext.call(inputmask, pos.end) + 1;
        }
    }
    var offset;
    if ((offset = revalidateMask.call(inputmask, pos)) !== false) {
        if (strict !== true && opts.keepStatic !== false || (opts.regex !== null && _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, pos.begin).match.def.indexOf("|") !== -1)) { //TODO NEEDS BETTER CHECK WHEN TO ALTERNATE  ~ opts regex isn"t good enough
            var result = alternate.call(inputmask, true);
            if (result) {
                var newPos = result.caret !== undefined ? result.caret : (result.pos ? _positioning__WEBPACK_IMPORTED_MODULE_2__.seekNext.call(inputmask, result.pos.begin ? result.pos.begin : result.pos) : _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask, -1, true));
                if (c !== _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Delete || pos.begin > newPos) {
                    pos.begin == newPos;
                }
            }
        }

        if (strict !== true) {
            maskset.p = c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Delete ? pos.begin + offset : pos.begin;
            maskset.p = _positioning__WEBPACK_IMPORTED_MODULE_2__.determineNewCaretPosition.call(inputmask, {
                begin: maskset.p,
                end: maskset.p
            }, false, opts.insertMode === false && c === _keycode_js__WEBPACK_IMPORTED_MODULE_1__.keys.Backspace ? "none" : undefined).begin;
        }
    }
}

//tobe put on prototype?
function isComplete(buffer) { //return true / false / undefined (repeat *)
    const inputmask = this, opts = this.opts, maskset = this.maskset;

    if (typeof opts.isComplete === "function") return opts.isComplete(buffer, opts);
    if (opts.repeat === "*") return undefined;
    var complete = false,
        lrp = _positioning__WEBPACK_IMPORTED_MODULE_2__.determineLastRequiredPosition.call(inputmask, true),
        aml = _positioning__WEBPACK_IMPORTED_MODULE_2__.seekPrevious.call(inputmask, lrp.l);

    if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
        complete = true;
        for (var i = 0; i <= aml; i++) {
            var test = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTestTemplate.call(inputmask, i).match;
            if ((test.static !== true && maskset.validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true) || (test.static === true && buffer[i] !== _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getPlaceholder.call(inputmask, i, test))) {
                complete = false;
                break;
            }
        }
    }
    return complete;
}

function isSelection(posObj) {
    const inputmask = this,
        opts = this.opts, insertModeOffset = opts.insertMode ? 0 : 1;
    return inputmask.isRTL ? (posObj.begin - posObj.end) > insertModeOffset : (posObj.end - posObj.begin) > insertModeOffset;
}

//tobe put on prototype?
function isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly, fromCheckval) { //strict true ~ no correction or autofill
    const inputmask = this,
        $ = this.dependencyLib,
        opts = this.opts,
        maskset = inputmask.maskset;

    strict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions

    var maskPos = pos;
    if (pos.begin !== undefined) { //position was a position object - used to handle a delete by typing over a selection
        maskPos = inputmask.isRTL ? pos.end : pos.begin;
    }

    function processCommandObject(commandObj) {
        if (commandObj !== undefined) {
            if (commandObj.remove !== undefined) { //remove position(s)
                if (!Array.isArray(commandObj.remove)) commandObj.remove = [commandObj.remove];
                commandObj.remove.sort(function (a, b) {
                    return inputmask.isRTL ? a.pos - b.pos : b.pos - a.pos;
                }).forEach(function (lmnt) {
                    revalidateMask.call(inputmask, {begin: lmnt, end: lmnt + 1});
                });
                commandObj.remove = undefined;
            }
            if (commandObj.insert !== undefined) { //insert position(s)
                if (!Array.isArray(commandObj.insert)) commandObj.insert = [commandObj.insert];
                commandObj.insert.sort(function (a, b) {
                    return inputmask.isRTL ? b.pos - a.pos : a.pos - b.pos;
                }).forEach(function (lmnt) {
                    if (lmnt.c !== "") {
                        isValid.call(inputmask, lmnt.pos, lmnt.c, lmnt.strict !== undefined ? lmnt.strict : true, lmnt.fromIsValid !== undefined ? lmnt.fromIsValid : fromIsValid);
                    }
                });
                commandObj.insert = undefined;
            }

            if (commandObj.refreshFromBuffer && commandObj.buffer) {
                var refresh = commandObj.refreshFromBuffer;
                refreshFromBuffer.call(inputmask, refresh === true ? refresh : refresh.start, refresh.end, commandObj.buffer);
                commandObj.refreshFromBuffer = undefined;
            }

            if (commandObj.rewritePosition !== undefined) {
                maskPos = commandObj.rewritePosition;
                // commandObj.rewritePosition = undefined;
                commandObj = true;
            }
        }
        return commandObj;
    }

    function _isValid(position, c, strict) {
        var rslt = false;
        _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTests.call(inputmask, position).every(function (tst, ndx) {
            var test = tst.match;
            //make sure the buffer is set and correct
            _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask, true);
            if (test.jit && maskset.validPositions[_positioning__WEBPACK_IMPORTED_MODULE_2__.seekPrevious.call(inputmask, position)] === undefined) //ignore if jit is not desirable
            {
                rslt = false;
            } else {
                //return is false or a json object => { pos: ??, c: ??} or true
                rslt = test.fn != null ?
                    test.fn.test(c, maskset, position, strict, opts, isSelection.call(inputmask, pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== "" ? //non mask
                        {
                            c: _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getPlaceholder.call(inputmask, position, test, true) || test.def,
                            pos: position
                        } : false;
            }
            if (rslt !== false) {
                var elem = rslt.c !== undefined ? rslt.c : c, validatedPos = position;
                elem = (elem === opts.skipOptionalPartCharacter && test.static === true) ?
                    (_validation_tests__WEBPACK_IMPORTED_MODULE_0__.getPlaceholder.call(inputmask, position, test, true) || test.def) : elem;

                rslt = processCommandObject(rslt);

                if (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) { //their is a position offset
                    validatedPos = rslt.pos;
                }

                if (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {
                    return false; //breakout if nothing to insert
                }

                if (revalidateMask.call(inputmask, pos, $.extend({}, tst, {
                    "input": casing.call(inputmask, elem, test, validatedPos)
                }), fromIsValid, validatedPos) === false) {
                    rslt = false;
                }
                return false; //break from loop
            }

            return true;
        });
        return rslt;
    }

    var result = true,
        positionsClone = $.extend(true, {}, maskset.validPositions); //clone the currentPositions

    if (opts.keepStatic === false && maskset.excludes[maskPos] !== undefined && fromAlternate !== true && fromIsValid !== true) {
        for (var i = maskPos; i < (inputmask.isRTL ? pos.begin : pos.end); i++) {
            if (maskset.excludes[i] !== undefined) {
                maskset.excludes[i] = undefined;
                delete maskset.tests[i];
            }
        }
    }

    if (typeof opts.preValidation === "function" && fromIsValid !== true && validateOnly !== true) {
        result = opts.preValidation.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask), maskPos, c, isSelection.call(inputmask, pos), opts, maskset, pos, strict || fromAlternate);
        result = processCommandObject(result);
    }
    if (result === true) { //preValidation result
        result = _isValid(maskPos, c, strict);
        if ((!strict || fromIsValid === true) && result === false && validateOnly !== true) {
            var currentPosValid = maskset.validPositions[maskPos];
            if (currentPosValid && currentPosValid.match.static === true && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {
                result = {
                    "caret": _positioning__WEBPACK_IMPORTED_MODULE_2__.seekNext.call(inputmask, maskPos)
                };
            } else {
                if (opts.insertMode || maskset.validPositions[_positioning__WEBPACK_IMPORTED_MODULE_2__.seekNext.call(inputmask, maskPos)] === undefined || pos.end > maskPos) { //does the input match on a further position?
                    var skip = false;
                    if (maskset.jitOffset[maskPos] && maskset.validPositions[_positioning__WEBPACK_IMPORTED_MODULE_2__.seekNext.call(inputmask, maskPos)] === undefined) {
                        result = isValid.call(inputmask, maskPos + maskset.jitOffset[maskPos], c, true, true);
                        if (result !== false) {
                            if (fromAlternate !== true) result.caret = maskPos;
                            skip = true;
                        }
                    }
                    if (pos.end > maskPos) {
                        maskset.validPositions[maskPos] = undefined;
                    }
                    if (!skip && !_positioning__WEBPACK_IMPORTED_MODULE_2__.isMask.call(inputmask, maskPos, opts.keepStatic && maskPos === 0)) {
                        for (var nPos = maskPos + 1, snPos = _positioning__WEBPACK_IMPORTED_MODULE_2__.seekNext.call(inputmask, maskPos, false, maskPos !== 0); nPos <= snPos; nPos++) {
                            // if (!isMask(nPos, true)) {
                            // 	continue;
                            // }
                            result = _isValid(nPos, c, strict);
                            if (result !== false) {
                                result = trackbackPositions.call(inputmask, maskPos, result.pos !== undefined ? result.pos : nPos) || result;
                                maskPos = nPos;
                                break;
                            }
                        }
                    }
                }
            }
        }

        if (inputmask.hasAlternator && fromAlternate !== true && !strict) {
            if (result === false && opts.keepStatic && (isComplete.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask)) || maskPos === 0)) { //try fuzzy alternator logic
                result = alternate.call(inputmask, maskPos, c, strict, fromIsValid, undefined, pos);
            } else if (isSelection.call(inputmask, pos) && maskset.tests[maskPos] && maskset.tests[maskPos].length > 1 && opts.keepStatic) { //selection clears an alternated keepstatic mask ~ #2189
                result = alternate.call(inputmask, true);
            } else if (result == true && opts.numericInput !== true && maskset.tests[maskPos] && maskset.tests[maskPos].length > 1 && _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask, undefined, true) > maskPos) {
                // console.log("Alternating");
                result = alternate.call(inputmask, true);
            }
        }

        if (result === true) {
            result = {
                "pos": maskPos
            };
        }
    }
    if (typeof opts.postValidation === "function" && fromIsValid !== true && validateOnly !== true) {
        var postResult = opts.postValidation.call(inputmask, _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask, true), pos.begin !== undefined ? (inputmask.isRTL ? pos.end : pos.begin) : pos, c, result, opts, maskset, strict, fromCheckval);
        if (postResult !== undefined) {
            result = postResult === true ? result : postResult;
        }
    }

    if (result && result.pos === undefined) {
        result.pos = maskPos;
    }

    if (result === false || validateOnly === true) {
        _positioning__WEBPACK_IMPORTED_MODULE_2__.resetMaskSet.call(inputmask, true);
        maskset.validPositions = $.extend(true, [], positionsClone); //revert validation changes
    } else {
        trackbackPositions.call(inputmask, undefined, maskPos, true);
    }

    var endResult = processCommandObject(result);
    // console.log("returned result " + JSON.stringify(endResult));
    if (inputmask.maxLength !== undefined) {
        var buffer = _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask);
        if (buffer.length > inputmask.maxLength && !fromIsValid) {
            _positioning__WEBPACK_IMPORTED_MODULE_2__.resetMaskSet.call(inputmask, true);
            maskset.validPositions = $.extend(true, [], positionsClone); //revert validation changes
            endResult = false;
        }
    }
    return endResult;
}

//tobe put on prototype?
function positionCanMatchDefinition(pos, testDefinition, opts) {
    const inputmask = this,
        maskset = this.maskset;

    var valid = false,
        tests = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTests.call(inputmask, pos);
    for (var tndx = 0; tndx < tests.length; tndx++) {
        if (tests[tndx].match &&
            ((tests[tndx].match["nativeDef"] === testDefinition.match[opts.shiftPositions ? "def" : "nativeDef"] && (!opts.shiftPositions || !testDefinition.match.static)) ||
                tests[tndx].match["nativeDef"] === testDefinition.match["nativeDef"] ||
                (opts.regex && !tests[tndx].match.static && tests[tndx].match.fn.test(testDefinition.input, maskset, pos, false, opts)))) {
            valid = true;
            break;
        } else if (tests[tndx].match && tests[tndx].match["def"] === testDefinition.match["nativeDef"]) {
            valid = undefined;
            break;
        }
    }
    if (valid === false) {
        if (maskset.jitOffset[pos] !== undefined) {
            valid = positionCanMatchDefinition.call(inputmask, pos + maskset.jitOffset[pos], testDefinition, opts);
        }
    }
    return valid;
}

//tobe put on prototype?
function refreshFromBuffer(start, end, buffer) {
    const inputmask = this,
        maskset = this.maskset,
        opts = this.opts,
        $ = this.dependencyLib;
    // checkVal.call(inputmask, el, false, true, isRTL ? buffer.reverse() : buffer);
    var i, p, skipOptionalPartCharacter = opts.skipOptionalPartCharacter,
        bffr = inputmask.isRTL ? buffer.slice().reverse() : buffer;
    opts.skipOptionalPartCharacter = "";
    if (start === true) {
        _positioning__WEBPACK_IMPORTED_MODULE_2__.resetMaskSet.call(inputmask);
        maskset.tests = {}; //refresh tests after possible alternating
        start = 0;
        end = buffer.length;
        p = _positioning__WEBPACK_IMPORTED_MODULE_2__.determineNewCaretPosition.call(inputmask, {begin: 0, end: 0}, false).begin;
    } else {
        for (i = start; i < end; i++) {
            delete maskset.validPositions[i];
        }
        p = start;
    }

    var keypress = new $.Event("keypress");
    for (i = start; i < end; i++) {
        keypress.key = bffr[i].toString();
        inputmask.ignorable = false; //make sure ignorable is ignored ;-)
        var valResult = _eventhandlers__WEBPACK_IMPORTED_MODULE_3__.EventHandlers.keypressEvent.call(inputmask, keypress, true, false, false, p);
        if (valResult !== false && valResult !== undefined) {
            p = valResult.forwardPosition;
        }
    }

    opts.skipOptionalPartCharacter = skipOptionalPartCharacter;
}

//tobe put on prototype?
//fill in best positions according the current input
function trackbackPositions(originalPos, newPos, fillOnly) {
    const inputmask = this,
        maskset = this.maskset,
        $ = this.dependencyLib;

    // console.log("trackbackPositions " + originalPos + " " + newPos);
    if (originalPos === undefined) {
        //find previous valid
        for (originalPos = newPos - 1; originalPos > 0; originalPos--) {
            if (maskset.validPositions[originalPos]) break;
        }
    }
    for (var ps = originalPos; ps < newPos; ps++) {
        if (maskset.validPositions[ps] === undefined && !_positioning__WEBPACK_IMPORTED_MODULE_2__.isMask.call(inputmask, ps, false)) {
            var vp = ps == 0 ? _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, ps) : maskset.validPositions[ps - 1];
            if (vp) {
                var tests = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTests.call(inputmask, ps).slice();
                if (tests[tests.length - 1].match.def === "") tests.pop();
                var bestMatch = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.determineTestTemplate.call(inputmask, ps, tests), np;
                if (bestMatch && (bestMatch.match.jit !== true || (bestMatch.match.newBlockMarker === "master" && (np = maskset.validPositions[ps + 1]) && np.match.optionalQuantifier === true))) {
                    bestMatch = $.extend({}, bestMatch, {
                        "input": _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getPlaceholder.call(inputmask, ps, bestMatch.match, true) || bestMatch.match.def
                    });
                    bestMatch.generatedInput = true;
                    revalidateMask.call(inputmask, ps, bestMatch, true);

                    if (fillOnly !== true) {
                        //revalidate the new position to update the locator value
                        var cvpInput = maskset.validPositions[newPos].input;
                        maskset.validPositions[newPos] = undefined;
                        return isValid.call(inputmask, newPos, cvpInput, true, true);
                    }
                }
            }
        }
    }
}

//tobe put on prototype?
function revalidateMask(pos, validTest, fromIsValid, validatedPos) {
    const inputmask = this,
        maskset = this.maskset,
        opts = this.opts,
        $ = this.dependencyLib;

    function IsEnclosedStatic(pos, valids, selection) {
        var posMatch = valids[pos];
        if (posMatch !== undefined && posMatch.match.static === true && posMatch.match.optionality !== true && (valids[0] === undefined || valids[0].alternation === undefined)) {
            var prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && valids[pos - 1].match.static === true && valids[pos - 1] : valids[pos - 1],
                nextMatch = selection.end > pos + 1 ? valids[pos + 1] && valids[pos + 1].match.static === true && valids[pos + 1] : valids[pos + 1];
            return prevMatch && nextMatch;
        }
        return false;
    }

    var offset = 0, begin = pos.begin !== undefined ? pos.begin : pos, end = pos.end !== undefined ? pos.end : pos,
        valid = true;
    if (pos.begin > pos.end) {
        begin = pos.end;
        end = pos.begin;
    }

    validatedPos = validatedPos !== undefined ? validatedPos : begin;
    if (fromIsValid === undefined && (begin !== end || (opts.insertMode && maskset.validPositions[validatedPos] !== undefined) || validTest === undefined || validTest.match.optionalQuantifier || validTest.match.optionality)) {
        //reposition & revalidate others
        var positionsClone = $.extend(true, {}, maskset.validPositions),
            lvp = _positioning__WEBPACK_IMPORTED_MODULE_2__.getLastValidPosition.call(inputmask, undefined, true),
            i;
        maskset.p = begin; //needed for alternated position after overtype selection

        for (i = lvp; i >= begin; i--) {
            delete maskset.validPositions[i];
            if (validTest === undefined) delete maskset.tests[i + 1];
        }

        var j = validatedPos,
            posMatch = j, t, canMatch, test;

        if (validTest) {
            maskset.validPositions[validatedPos] = $.extend(true, {}, validTest);
            posMatch++;
            j++;
        }

        for (i = validTest ? end : end - 1; i <= lvp; i++) {
            if ((t = positionsClone[i]) !== undefined && t.generatedInput !== true &&
                (i >= end || (i >= begin && IsEnclosedStatic(i, positionsClone, {
                    begin: begin,
                    end: end
                })))) {
                while (test = _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, posMatch), test.match.def !== "") { //loop needed to match further positions
                    if ((canMatch = positionCanMatchDefinition.call(inputmask, posMatch, t, opts)) !== false || t.match.def === "+") { //validated match //we still need some hackery for the + validator (numeric alias)
                        if (t.match.def === "+") _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask, true);
                        var result = isValid.call(inputmask, posMatch, t.input, t.match.def !== "+", /*t.match.def !== "+"*/ true);
                        valid = result !== false;
                        j = (result.pos || posMatch) + 1;
                        if (!valid && canMatch) break;
                    } else {
                        valid = false;
                    }
                    if (valid) {
                        if (validTest === undefined && t.match.static && i === pos.begin) offset++;
                        break;
                    }
                    if (!valid && _positioning__WEBPACK_IMPORTED_MODULE_2__.getBuffer.call(inputmask), posMatch > maskset.maskLength) {
                        break;
                    }
                    posMatch++;
                }
                if (_validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, posMatch).match.def == "") {
                    valid = false;
                }
                //restore position
                posMatch = j;
            }
            if (!valid) break;
        }
        if (!valid) {
            maskset.validPositions = $.extend(true, [], positionsClone);
            _positioning__WEBPACK_IMPORTED_MODULE_2__.resetMaskSet.call(inputmask, true);
            return false;
        }
    } else if (validTest && _validation_tests__WEBPACK_IMPORTED_MODULE_0__.getTest.call(inputmask, validatedPos).match.cd === validTest.match.cd) {
        maskset.validPositions[validatedPos] = $.extend(true, {}, validTest);
    }

    _positioning__WEBPACK_IMPORTED_MODULE_2__.resetMaskSet.call(inputmask, true);
    return offset;
}


/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ "./node_modules/is-nan/implementation.js":
/*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ "./node_modules/is-nan/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/is-nan/polyfill.js":
/*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/is-nan/shim.js":
/*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "./node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};


/***/ }),

/***/ "./node_modules/just-validate/dist/just-validate.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/just-validate/dist/just-validate.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomStyleTagIds": () => (/* binding */ CustomStyleTagIds),
/* harmony export */   "GroupRules": () => (/* binding */ GroupRules),
/* harmony export */   "Rules": () => (/* binding */ Rules),
/* harmony export */   "default": () => (/* binding */ JustValidate)
/* harmony export */ });
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const EMAIL_REGEXP = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
const INTEGER_REGEXP = /^-?[0-9]\d*$/;
const PASSWORD_REGEXP = /^(?=.*[A-Za-z])(?=.*\d).{8,}$/;
const STRONG_PASSWORD_REGEXP = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
const isEmpty = (value) => {
  let newVal = value;
  if (typeof value === "string") {
    newVal = value.trim();
  }
  return !newVal;
};
const isEmail = (value) => {
  return EMAIL_REGEXP.test(value);
};
const isLengthMoreThanMax = (value, len) => {
  return value.length > len;
};
const isLengthLessThanMin = (value, len) => {
  return value.length < len;
};
const isNumber = (value) => {
  if (typeof value !== "string") {
    return false;
  }
  return !isNaN(+value) && !isNaN(parseFloat(value));
};
const isInteger = (value) => {
  return INTEGER_REGEXP.test(value);
};
const isPassword = (value) => {
  return PASSWORD_REGEXP.test(value);
};
const isStrongPassword = (value) => {
  return STRONG_PASSWORD_REGEXP.test(value);
};
const isNumberMoreThanMax = (value, len) => {
  return value > len;
};
const isNumberLessThanMin = (value, len) => {
  return value < len;
};
const isInvalidOrEmptyString = (value) => {
  return typeof value !== "string" || value === "";
};
var Rules = /* @__PURE__ */ ((Rules2) => {
  Rules2["Required"] = "required";
  Rules2["Email"] = "email";
  Rules2["MinLength"] = "minLength";
  Rules2["MaxLength"] = "maxLength";
  Rules2["Password"] = "password";
  Rules2["Number"] = "number";
  Rules2["Integer"] = "integer";
  Rules2["MaxNumber"] = "maxNumber";
  Rules2["MinNumber"] = "minNumber";
  Rules2["StrongPassword"] = "strongPassword";
  Rules2["CustomRegexp"] = "customRegexp";
  Rules2["MinFilesCount"] = "minFilesCount";
  Rules2["MaxFilesCount"] = "maxFilesCount";
  Rules2["Files"] = "files";
  return Rules2;
})(Rules || {});
var GroupRules = /* @__PURE__ */ ((GroupRules2) => {
  GroupRules2["Required"] = "required";
  return GroupRules2;
})(GroupRules || {});
var CustomStyleTagIds = /* @__PURE__ */ ((CustomStyleTagIds2) => {
  CustomStyleTagIds2["Label"] = "label";
  CustomStyleTagIds2["LabelArrow"] = "labelArrow";
  return CustomStyleTagIds2;
})(CustomStyleTagIds || {});
const defaultDictionary = [
  {
    key: Rules.Required,
    dict: {
      en: "The field is required"
    }
  },
  {
    key: Rules.Email,
    dict: {
      en: "Email has invalid format"
    }
  },
  {
    key: Rules.MaxLength,
    dict: {
      en: "The field must contain a maximum of :value characters"
    }
  },
  {
    key: Rules.MinLength,
    dict: {
      en: "The field must contain a minimum of :value characters"
    }
  },
  {
    key: Rules.Password,
    dict: {
      en: "Password must contain minimum eight characters, at least one letter and one number"
    }
  },
  {
    key: Rules.StrongPassword,
    dict: {
      en: "Password should contain minimum eight characters, at least one uppercase letter, one lowercase letter, one number and one special character"
    }
  },
  {
    key: Rules.Number,
    dict: {
      en: "Value should be a number"
    }
  },
  {
    key: Rules.MaxNumber,
    dict: {
      en: "Number should be less or equal than :value"
    }
  },
  {
    key: Rules.MinNumber,
    dict: {
      en: "Number should be more or equal than :value"
    }
  },
  {
    key: Rules.MinFilesCount,
    dict: {
      en: "Files count should be more or equal than :value"
    }
  },
  {
    key: Rules.MaxFilesCount,
    dict: {
      en: "Files count should be less or equal than :value"
    }
  },
  {
    key: Rules.Files,
    dict: {
      en: "Uploaded files have one or several invalid properties (extension/size/type etc)."
    }
  }
];
const DEFAULT_ERROR_FIELD_MESSAGE = "Value is incorrect";
const isPromise = (val) => typeof val === "object" && val !== null && "then" in val && typeof val.then === "function";
const getNodeParents = (el) => {
  let elem = el;
  const els = [];
  while (elem) {
    els.unshift(elem);
    elem = elem.parentNode;
  }
  return els;
};
const getClosestParent = (groups, parents) => {
  const reversedParents = [...parents].reverse();
  for (let i = 0, len = reversedParents.length; i < len; ++i) {
    const parent = reversedParents[i];
    for (const key in groups) {
      const group = groups[key];
      if (group.groupElem === parent) {
        return [key, group];
      }
    }
  }
  return null;
};
const getClassList = (classList) => {
  if (Array.isArray(classList)) {
    return classList.filter((cls) => cls.length > 0);
  }
  if (typeof classList === "string" && classList.trim()) {
    return [...classList.split(" ").filter((cls) => cls.length > 0)];
  }
  return [];
};
const isElement = (element) => {
  return element instanceof Element || element instanceof HTMLDocument;
};
const errorLabelCss = `.just-validate-error-label[data-tooltip=true]{position:fixed;padding:4px 8px;background:#423f3f;color:#fff;white-space:nowrap;z-index:10;border-radius:4px;transform:translateY(-5px)}.just-validate-error-label[data-tooltip=true]:before{content:'';width:0;height:0;border-left:solid 5px transparent;border-right:solid 5px transparent;border-bottom:solid 5px #423f3f;position:absolute;z-index:3;display:block;bottom:-5px;transform:rotate(180deg);left:calc(50% - 5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]{transform:translateX(-5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]:before{right:-7px;bottom:auto;left:auto;top:calc(50% - 2px);transform:rotate(90deg)}.just-validate-error-label[data-tooltip=true][data-direction=right]{transform:translateX(5px)}.just-validate-error-label[data-tooltip=true][data-direction=right]:before{right:auto;bottom:auto;left:-7px;top:calc(50% - 2px);transform:rotate(-90deg)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]{transform:translateY(5px)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]:before{right:auto;bottom:auto;left:calc(50% - 5px);top:-5px;transform:rotate(0)}`;
const TOOLTIP_ARROW_HEIGHT = 5;
const defaultGlobalConfig = {
  errorFieldStyle: {
    color: "#b81111",
    border: "1px solid #B81111"
  },
  errorFieldCssClass: "just-validate-error-field",
  successFieldCssClass: "just-validate-success-field",
  errorLabelStyle: {
    color: "#b81111"
  },
  errorLabelCssClass: "just-validate-error-label",
  successLabelCssClass: "just-validate-success-label",
  focusInvalidField: true,
  lockForm: true,
  testingMode: false,
  validateBeforeSubmitting: false
};
class JustValidate {
  constructor(form, globalConfig, dictLocale) {
    __publicField(this, "form", null);
    __publicField(this, "fields", {});
    __publicField(this, "groupFields", {});
    __publicField(this, "errors", {});
    __publicField(this, "isValid", false);
    __publicField(this, "isSubmitted", false);
    __publicField(this, "globalConfig", defaultGlobalConfig);
    __publicField(this, "errorLabels", {});
    __publicField(this, "successLabels", {});
    __publicField(this, "eventListeners", []);
    __publicField(this, "dictLocale", defaultDictionary);
    __publicField(this, "currentLocale", "en");
    __publicField(this, "customStyleTags", {});
    __publicField(this, "onSuccessCallback");
    __publicField(this, "onFailCallback");
    __publicField(this, "onValidateCallback");
    __publicField(this, "tooltips", []);
    __publicField(this, "lastScrollPosition");
    __publicField(this, "isScrollTick");
    __publicField(this, "fieldIds", /* @__PURE__ */ new Map());
    __publicField(this, "getKeyByFieldSelector", (field) => {
      return this.fieldIds.get(field);
    });
    __publicField(this, "getFieldSelectorByKey", (key) => {
      for (const [fieldSelector, k] of this.fieldIds) {
        if (key === k) {
          return fieldSelector;
        }
      }
      return void 0;
    });
    __publicField(this, "getCompatibleFields", () => {
      const fields = {};
      Object.keys(this.fields).forEach((key) => {
        let newKey = key;
        const fieldSelector = this.getFieldSelectorByKey(key);
        if (typeof fieldSelector === "string") {
          newKey = fieldSelector;
        }
        fields[newKey] = { ...this.fields[key] };
      });
      return fields;
    });
    __publicField(this, "setKeyByFieldSelector", (field) => {
      if (this.fieldIds.has(field)) {
        return this.fieldIds.get(field);
      }
      const key = String(this.fieldIds.size + 1);
      this.fieldIds.set(field, key);
      return key;
    });
    __publicField(this, "refreshAllTooltips", () => {
      this.tooltips.forEach((item) => {
        item.refresh();
      });
    });
    __publicField(this, "handleDocumentScroll", () => {
      this.lastScrollPosition = window.scrollY;
      if (!this.isScrollTick) {
        window.requestAnimationFrame(() => {
          this.refreshAllTooltips();
          this.isScrollTick = false;
        });
        this.isScrollTick = true;
      }
    });
    __publicField(this, "formSubmitHandler", (ev) => {
      ev.preventDefault();
      this.isSubmitted = true;
      this.validateHandler(ev);
    });
    __publicField(this, "handleFieldChange", (target) => {
      let foundKey;
      for (const key in this.fields) {
        const field = this.fields[key];
        if (field.elem === target) {
          foundKey = key;
          break;
        }
      }
      if (!foundKey) {
        return;
      }
      this.fields[foundKey].touched = true;
      this.validateField(foundKey, true);
    });
    __publicField(this, "handleGroupChange", (target) => {
      let foundKey;
      for (const key in this.groupFields) {
        const group = this.groupFields[key];
        if (group.elems.find((elem) => elem === target)) {
          foundKey = key;
          break;
        }
      }
      if (!foundKey) {
        return;
      }
      this.groupFields[foundKey].touched = true;
      this.validateGroup(foundKey, true);
    });
    __publicField(this, "handlerChange", (ev) => {
      if (!ev.target) {
        return;
      }
      this.handleFieldChange(ev.target);
      this.handleGroupChange(ev.target);
      this.renderErrors();
    });
    this.initialize(form, globalConfig, dictLocale);
  }
  initialize(form, globalConfig, dictLocale) {
    this.form = null;
    this.errors = {};
    this.isValid = false;
    this.isSubmitted = false;
    this.globalConfig = defaultGlobalConfig;
    this.errorLabels = {};
    this.successLabels = {};
    this.eventListeners = [];
    this.customStyleTags = {};
    this.tooltips = [];
    this.currentLocale = "en";
    if (typeof form === "string") {
      const elem = document.querySelector(form);
      if (!elem) {
        throw Error(
          `Form with ${form} selector not found! Please check the form selector`
        );
      }
      this.setForm(elem);
    } else if (form instanceof HTMLFormElement) {
      this.setForm(form);
    } else {
      throw Error(
        `Form selector is not valid. Please specify a string selector or a DOM element.`
      );
    }
    this.globalConfig = { ...defaultGlobalConfig, ...globalConfig };
    if (dictLocale) {
      this.dictLocale = [...dictLocale, ...defaultDictionary];
    }
    if (this.isTooltip()) {
      const styleTag = document.createElement("style");
      styleTag.textContent = errorLabelCss;
      this.customStyleTags[CustomStyleTagIds.Label] = document.head.appendChild(styleTag);
      this.addListener("scroll", document, this.handleDocumentScroll);
    }
  }
  getLocalisedString(rule, ruleValue, customMsg) {
    var _a;
    const search = customMsg != null ? customMsg : rule;
    let localisedStr = (_a = this.dictLocale.find((item) => item.key === search)) == null ? void 0 : _a.dict[this.currentLocale];
    if (!localisedStr) {
      if (customMsg) {
        localisedStr = customMsg;
      }
    }
    if (localisedStr && ruleValue !== void 0) {
      switch (rule) {
        case Rules.MaxLength:
        case Rules.MinLength:
        case Rules.MaxNumber:
        case Rules.MinNumber:
        case Rules.MinFilesCount:
        case Rules.MaxFilesCount:
          localisedStr = localisedStr.replace(":value", String(ruleValue));
      }
    }
    return localisedStr || customMsg || DEFAULT_ERROR_FIELD_MESSAGE;
  }
  getFieldErrorMessage(fieldRule, elem) {
    const msg = typeof fieldRule.errorMessage === "function" ? fieldRule.errorMessage(this.getElemValue(elem), this.fields) : fieldRule.errorMessage;
    return this.getLocalisedString(fieldRule.rule, fieldRule.value, msg);
  }
  getFieldSuccessMessage(successMessage, elem) {
    const msg = typeof successMessage === "function" ? successMessage(this.getElemValue(elem), this.fields) : successMessage;
    return this.getLocalisedString(void 0, void 0, msg);
  }
  getGroupErrorMessage(groupRule) {
    return this.getLocalisedString(
      groupRule.rule,
      void 0,
      groupRule.errorMessage
    );
  }
  getGroupSuccessMessage(groupRule) {
    if (!groupRule.successMessage) {
      return void 0;
    }
    return this.getLocalisedString(
      void 0,
      void 0,
      groupRule.successMessage
    );
  }
  setFieldInvalid(key, fieldRule) {
    this.fields[key].isValid = false;
    this.fields[key].errorMessage = this.getFieldErrorMessage(
      fieldRule,
      this.fields[key].elem
    );
  }
  setFieldValid(key, successMessage) {
    this.fields[key].isValid = true;
    if (successMessage !== void 0) {
      this.fields[key].successMessage = this.getFieldSuccessMessage(
        successMessage,
        this.fields[key].elem
      );
    }
  }
  setGroupInvalid(key, groupRule) {
    this.groupFields[key].isValid = false;
    this.groupFields[key].errorMessage = this.getGroupErrorMessage(groupRule);
  }
  setGroupValid(key, groupRule) {
    this.groupFields[key].isValid = true;
    this.groupFields[key].successMessage = this.getGroupSuccessMessage(groupRule);
  }
  getElemValue(elem) {
    switch (elem.type) {
      case "checkbox":
        return elem.checked;
      case "file":
        return elem.files;
      default:
        return elem.value;
    }
  }
  validateGroupRule(key, elems, groupRule) {
    switch (groupRule.rule) {
      case GroupRules.Required: {
        if (elems.every((elem) => !elem.checked)) {
          this.setGroupInvalid(key, groupRule);
        } else {
          this.setGroupValid(key, groupRule);
        }
      }
    }
  }
  validateFieldRule(key, elem, fieldRule, afterInputChanged = false) {
    const ruleValue = fieldRule.value;
    const elemValue = this.getElemValue(elem);
    if (fieldRule.plugin) {
      const result = fieldRule.plugin(
        elemValue,
        this.getCompatibleFields()
      );
      if (!result) {
        this.setFieldInvalid(key, fieldRule);
      }
      return;
    }
    switch (fieldRule.rule) {
      case Rules.Required: {
        if (isEmpty(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.Email: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isEmail(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MaxLength: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (isLengthMoreThanMax(elemValue, ruleValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MinLength: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (isLengthLessThanMin(elemValue, ruleValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.Password: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isPassword(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.StrongPassword: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isStrongPassword(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.Number: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isNumber(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.Integer: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isInteger(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MaxNumber: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        const num = +elemValue;
        if (Number.isNaN(num) || isNumberMoreThanMax(num, ruleValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MinNumber: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        const num = +elemValue;
        if (Number.isNaN(num) || isNumberLessThanMin(num, ruleValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.CustomRegexp: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        let regexp;
        try {
          regexp = new RegExp(ruleValue);
        } catch (e) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] should be a valid regexp. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        const str = String(elemValue);
        if (str !== "" && !regexp.test(str)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MinFilesCount: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length < ruleValue) {
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        break;
      }
      case Rules.MaxFilesCount: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length > ruleValue) {
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        break;
      }
      case Rules.Files: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        if (typeof ruleValue !== "object") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be an object. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        const filesConfig = ruleValue.files;
        if (typeof filesConfig !== "object") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be an object with files array. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        const isFilePropsInvalid = (file, fileConfig) => {
          const minSizeInvalid = Number.isFinite(fileConfig.minSize) && file.size < fileConfig.minSize;
          const maxSizeInvalid = Number.isFinite(fileConfig.maxSize) && file.size > fileConfig.maxSize;
          const nameInvalid = Array.isArray(fileConfig.names) && !fileConfig.names.includes(file.name);
          const extInvalid = Array.isArray(fileConfig.extensions) && !fileConfig.extensions.includes(
            file.name.split(".")[file.name.split(".").length - 1]
          );
          const typeInvalid = Array.isArray(fileConfig.types) && !fileConfig.types.includes(file.type);
          return minSizeInvalid || maxSizeInvalid || nameInvalid || extInvalid || typeInvalid;
        };
        if (typeof elemValue === "object" && elemValue !== null) {
          for (let fileIdx = 0, len = elemValue.length; fileIdx < len; ++fileIdx) {
            const file = elemValue.item(fileIdx);
            if (!file) {
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            const filesInvalid = isFilePropsInvalid(file, filesConfig);
            if (filesInvalid) {
              this.setFieldInvalid(key, fieldRule);
              break;
            }
          }
        }
        break;
      }
      default: {
        if (typeof fieldRule.validator !== "function") {
          console.error(
            `Validator for custom rule for [${key}] field should be a function. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        const result = fieldRule.validator(
          elemValue,
          this.getCompatibleFields()
        );
        if (typeof result !== "boolean" && typeof result !== "function") {
          console.error(
            `Validator return value for [${key}] field should be boolean or function. It will be cast to boolean.`
          );
        }
        if (typeof result === "function") {
          if (afterInputChanged) {
            this.fields[key].asyncCheckPending = true;
          } else {
            this.fields[key].asyncCheckPending = false;
            const promise = result();
            if (!isPromise(promise)) {
              console.error(
                `Validator function for custom rule for [${key}] field should return a Promise. This field will be always invalid.`
              );
              this.setFieldInvalid(key, fieldRule);
              return;
            }
            return promise.then((resp) => {
              if (!resp) {
                this.setFieldInvalid(key, fieldRule);
              }
            }).catch(() => {
              this.setFieldInvalid(key, fieldRule);
            });
          }
        }
        if (!result) {
          this.setFieldInvalid(key, fieldRule);
        }
      }
    }
  }
  isFormValid() {
    let isValid = true;
    for (let i = 0, len = Object.values(this.fields).length; i < len; ++i) {
      const item = Object.values(this.fields)[i];
      if (item.isValid === void 0) {
        isValid = void 0;
        break;
      }
      if (item.isValid === false) {
        isValid = false;
        break;
      }
    }
    for (let i = 0, len = Object.values(this.groupFields).length; i < len; ++i) {
      const item = Object.values(this.groupFields)[i];
      if (item.isValid === void 0) {
        isValid = void 0;
        break;
      }
      if (item.isValid === false) {
        isValid = false;
        break;
      }
    }
    return isValid;
  }
  validateField(key, afterInputChanged = false) {
    var _a;
    const field = this.fields[key];
    field.isValid = true;
    const promises = [];
    [...field.rules].reverse().forEach((rule) => {
      const res = this.validateFieldRule(
        key,
        field.elem,
        rule,
        afterInputChanged
      );
      if (isPromise(res)) {
        promises.push(res);
      }
    });
    if (field.isValid) {
      this.setFieldValid(key, (_a = field.config) == null ? void 0 : _a.successMessage);
    }
    return Promise.allSettled(promises).finally(() => {
      var _a2;
      if (afterInputChanged) {
        (_a2 = this.onValidateCallback) == null ? void 0 : _a2.call(this, {
          isValid: this.isFormValid(),
          isSubmitted: this.isSubmitted,
          fields: this.getCompatibleFields(),
          groups: { ...this.groupFields }
        });
      }
    });
  }
  revalidateField(fieldSelector) {
    if (typeof fieldSelector !== "string" && !isElement(fieldSelector)) {
      throw Error(
        `Field selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    const key = this.getKeyByFieldSelector(fieldSelector);
    if (!key || !this.fields[key]) {
      console.error(`Field not found. Check the field selector.`);
      return Promise.reject();
    }
    return new Promise((resolve) => {
      this.validateField(key, true).finally(() => {
        this.clearFieldStyle(key);
        this.clearFieldLabel(key);
        this.renderFieldError(key, true);
        resolve(!!this.fields[key].isValid);
      });
    });
  }
  revalidateGroup(groupSelector) {
    if (typeof groupSelector !== "string" && !isElement(groupSelector)) {
      throw Error(
        `Group selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    const key = this.getKeyByFieldSelector(groupSelector);
    if (!key || !this.groupFields[key]) {
      console.error(`Group not found. Check the group selector.`);
      return Promise.reject();
    }
    return new Promise((resolve) => {
      this.validateGroup(key).finally(() => {
        this.clearFieldLabel(key);
        this.renderGroupError(key, true);
        resolve(!!this.groupFields[key].isValid);
      });
    });
  }
  validateGroup(key, afterInputChanged = false) {
    const group = this.groupFields[key];
    const promises = [];
    [...group.rules].reverse().forEach((rule) => {
      const res = this.validateGroupRule(key, group.elems, rule);
      if (isPromise(res)) {
        promises.push(res);
      }
    });
    return Promise.allSettled(promises).finally(() => {
      var _a;
      if (afterInputChanged) {
        (_a = this.onValidateCallback) == null ? void 0 : _a.call(this, {
          isValid: this.isFormValid(),
          isSubmitted: this.isSubmitted,
          fields: this.getCompatibleFields(),
          groups: { ...this.groupFields }
        });
      }
    });
  }
  focusInvalidField() {
    for (const key in this.fields) {
      const field = this.fields[key];
      if (!field.isValid) {
        setTimeout(() => field.elem.focus(), 0);
        break;
      }
    }
  }
  afterSubmitValidation(forceRevalidation = false) {
    this.renderErrors(forceRevalidation);
    if (this.globalConfig.focusInvalidField) {
      this.focusInvalidField();
    }
  }
  validate(forceRevalidation = false) {
    return new Promise((resolve) => {
      const promises = [];
      Object.keys(this.fields).forEach((key) => {
        const promise = this.validateField(key);
        if (isPromise(promise)) {
          promises.push(promise);
        }
      });
      Object.keys(this.groupFields).forEach((key) => {
        const promise = this.validateGroup(key);
        if (isPromise(promise)) {
          promises.push(promise);
        }
      });
      Promise.allSettled(promises).then(() => {
        var _a;
        this.afterSubmitValidation(forceRevalidation);
        (_a = this.onValidateCallback) == null ? void 0 : _a.call(this, {
          isValid: this.isFormValid(),
          isSubmitted: this.isSubmitted,
          fields: this.getCompatibleFields(),
          groups: { ...this.groupFields }
        });
        resolve(!!promises.length);
      });
    });
  }
  revalidate() {
    return new Promise((resolve) => {
      this.validateHandler(void 0, true).finally(() => {
        if (this.globalConfig.focusInvalidField) {
          this.focusInvalidField();
        }
        resolve(this.isValid);
      });
    });
  }
  validateHandler(ev, forceRevalidation = false) {
    if (this.globalConfig.lockForm) {
      this.lockForm();
    }
    return this.validate(forceRevalidation).finally(() => {
      var _a, _b;
      if (this.globalConfig.lockForm) {
        this.unlockForm();
      }
      if (this.isValid) {
        (_a = this.onSuccessCallback) == null ? void 0 : _a.call(this, ev);
      } else {
        (_b = this.onFailCallback) == null ? void 0 : _b.call(this, this.getCompatibleFields(), this.groupFields);
      }
    });
  }
  setForm(form) {
    this.form = form;
    this.form.setAttribute("novalidate", "novalidate");
    this.removeListener("submit", this.form, this.formSubmitHandler);
    this.addListener("submit", this.form, this.formSubmitHandler);
  }
  addListener(type, elem, handler) {
    elem.addEventListener(type, handler);
    this.eventListeners.push({ type, elem, func: handler });
  }
  removeListener(type, elem, handler) {
    elem.removeEventListener(type, handler);
    this.eventListeners = this.eventListeners.filter(
      (item) => item.type !== type || item.elem !== elem
    );
  }
  addField(fieldSelector, rules, config) {
    if (typeof fieldSelector !== "string" && !isElement(fieldSelector)) {
      throw Error(
        `Field selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    let elem;
    if (typeof fieldSelector === "string") {
      elem = this.form.querySelector(fieldSelector);
    } else {
      elem = fieldSelector;
    }
    if (!elem) {
      throw Error(
        `Field doesn't exist in the DOM! Please check the field selector.`
      );
    }
    if (!Array.isArray(rules) || !rules.length) {
      throw Error(
        `Rules argument should be an array and should contain at least 1 element.`
      );
    }
    rules.forEach((item) => {
      if (!("rule" in item || "validator" in item || "plugin" in item)) {
        throw Error(
          `Rules argument must contain at least one rule or validator property.`
        );
      }
      if (!item.validator && !item.plugin && (!item.rule || !Object.values(Rules).includes(item.rule))) {
        throw Error(
          `Rule should be one of these types: ${Object.values(Rules).join(
            ", "
          )}. Provided value: ${item.rule}`
        );
      }
    });
    const key = this.setKeyByFieldSelector(fieldSelector);
    this.fields[key] = {
      elem,
      rules,
      isValid: void 0,
      touched: false,
      config
    };
    this.setListeners(elem);
    if (this.isSubmitted || this.globalConfig.validateBeforeSubmitting) {
      this.validateField(key);
    }
    return this;
  }
  removeField(fieldSelector) {
    if (typeof fieldSelector !== "string" && !isElement(fieldSelector)) {
      throw Error(
        `Field selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    const key = this.getKeyByFieldSelector(fieldSelector);
    if (!key || !this.fields[key]) {
      console.error(`Field not found. Check the field selector.`);
      return this;
    }
    const type = this.getListenerType(this.fields[key].elem.type);
    this.removeListener(type, this.fields[key].elem, this.handlerChange);
    this.clearErrors();
    delete this.fields[key];
    return this;
  }
  removeGroup(group) {
    if (typeof group !== "string") {
      throw Error(
        `Group selector is not valid. Please specify a string selector.`
      );
    }
    const key = this.getKeyByFieldSelector(group);
    if (!key || !this.groupFields[key]) {
      console.error(`Group not found. Check the group selector.`);
      return this;
    }
    this.groupFields[key].elems.forEach((elem) => {
      const type = this.getListenerType(elem.type);
      this.removeListener(type, elem, this.handlerChange);
    });
    this.clearErrors();
    delete this.groupFields[key];
    return this;
  }
  addRequiredGroup(groupField, errorMessage, config, successMessage) {
    if (typeof groupField !== "string" && !isElement(groupField)) {
      throw Error(
        `Group selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    let elem;
    if (typeof groupField === "string") {
      elem = this.form.querySelector(groupField);
    } else {
      elem = groupField;
    }
    if (!elem) {
      throw Error(`Group selector not found! Please check the group selector.`);
    }
    const inputs = elem.querySelectorAll("input");
    const childrenInputs = Array.from(inputs).filter((input) => {
      const parent = getClosestParent(this.groupFields, getNodeParents(input));
      if (!parent) {
        return true;
      }
      return parent[1].elems.find((elem2) => elem2 !== input);
    });
    const key = this.setKeyByFieldSelector(groupField);
    this.groupFields[key] = {
      rules: [
        {
          rule: GroupRules.Required,
          errorMessage,
          successMessage
        }
      ],
      groupElem: elem,
      elems: childrenInputs,
      touched: false,
      isValid: void 0,
      config
    };
    inputs.forEach((input) => {
      this.setListeners(input);
    });
    return this;
  }
  getListenerType(type) {
    switch (type) {
      case "checkbox":
      case "select-one":
      case "file":
      case "radio": {
        return "change";
      }
      default: {
        return "input";
      }
    }
  }
  setListeners(elem) {
    const type = this.getListenerType(elem.type);
    this.removeListener(type, elem, this.handlerChange);
    this.addListener(type, elem, this.handlerChange);
  }
  clearFieldLabel(key) {
    var _a, _b;
    (_a = this.errorLabels[key]) == null ? void 0 : _a.remove();
    (_b = this.successLabels[key]) == null ? void 0 : _b.remove();
  }
  clearFieldStyle(key) {
    var _a, _b, _c, _d;
    const field = this.fields[key];
    const errorStyle = ((_a = field.config) == null ? void 0 : _a.errorFieldStyle) || this.globalConfig.errorFieldStyle;
    Object.keys(errorStyle).forEach((key2) => {
      field.elem.style[key2] = "";
    });
    const successStyle = ((_b = field.config) == null ? void 0 : _b.successFieldStyle) || this.globalConfig.successFieldStyle || {};
    Object.keys(successStyle).forEach((key2) => {
      field.elem.style[key2] = "";
    });
    field.elem.classList.remove(
      ...getClassList(
        ((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass
      ),
      ...getClassList(
        ((_d = field.config) == null ? void 0 : _d.successFieldCssClass) || this.globalConfig.successFieldCssClass
      )
    );
  }
  clearErrors() {
    var _a, _b;
    Object.keys(this.errorLabels).forEach(
      (key) => this.errorLabels[key].remove()
    );
    Object.keys(this.successLabels).forEach(
      (key) => this.successLabels[key].remove()
    );
    for (const key in this.fields) {
      this.clearFieldStyle(key);
    }
    for (const key in this.groupFields) {
      const group = this.groupFields[key];
      const errorStyle = ((_a = group.config) == null ? void 0 : _a.errorFieldStyle) || this.globalConfig.errorFieldStyle;
      Object.keys(errorStyle).forEach((key2) => {
        group.elems.forEach((elem) => {
          var _a2;
          elem.style[key2] = "";
          elem.classList.remove(
            ...getClassList(
              ((_a2 = group.config) == null ? void 0 : _a2.errorFieldCssClass) || this.globalConfig.errorFieldCssClass
            )
          );
        });
      });
      const successStyle = ((_b = group.config) == null ? void 0 : _b.successFieldStyle) || this.globalConfig.successFieldStyle || {};
      Object.keys(successStyle).forEach((key2) => {
        group.elems.forEach((elem) => {
          var _a2;
          elem.style[key2] = "";
          elem.classList.remove(
            ...getClassList(
              ((_a2 = group.config) == null ? void 0 : _a2.successFieldCssClass) || this.globalConfig.successFieldCssClass
            )
          );
        });
      });
    }
    this.tooltips = [];
  }
  isTooltip() {
    return !!this.globalConfig.tooltip;
  }
  lockForm() {
    const elems = this.form.querySelectorAll(
      "input, textarea, button, select"
    );
    for (let i = 0, len = elems.length; i < len; ++i) {
      elems[i].setAttribute(
        "data-just-validate-fallback-disabled",
        elems[i].disabled ? "true" : "false"
      );
      elems[i].setAttribute("disabled", "disabled");
      elems[i].style.pointerEvents = "none";
      elems[i].style.webkitFilter = "grayscale(100%)";
      elems[i].style.filter = "grayscale(100%)";
    }
  }
  unlockForm() {
    const elems = this.form.querySelectorAll(
      "input, textarea, button, select"
    );
    for (let i = 0, len = elems.length; i < len; ++i) {
      if (elems[i].getAttribute("data-just-validate-fallback-disabled") !== "true") {
        elems[i].removeAttribute("disabled");
      }
      elems[i].style.pointerEvents = "";
      elems[i].style.webkitFilter = "";
      elems[i].style.filter = "";
    }
  }
  renderTooltip(elem, errorLabel, position) {
    var _a;
    const { top, left, width, height } = elem.getBoundingClientRect();
    const errorLabelRect = errorLabel.getBoundingClientRect();
    const pos = position || ((_a = this.globalConfig.tooltip) == null ? void 0 : _a.position);
    switch (pos) {
      case "left": {
        errorLabel.style.top = `${top + height / 2 - errorLabelRect.height / 2}px`;
        errorLabel.style.left = `${left - errorLabelRect.width - TOOLTIP_ARROW_HEIGHT}px`;
        break;
      }
      case "top": {
        errorLabel.style.top = `${top - errorLabelRect.height - TOOLTIP_ARROW_HEIGHT}px`;
        errorLabel.style.left = `${left + width / 2 - errorLabelRect.width / 2}px`;
        break;
      }
      case "right": {
        errorLabel.style.top = `${top + height / 2 - errorLabelRect.height / 2}px`;
        errorLabel.style.left = `${left + width + TOOLTIP_ARROW_HEIGHT}px`;
        break;
      }
      case "bottom": {
        errorLabel.style.top = `${top + height + TOOLTIP_ARROW_HEIGHT}px`;
        errorLabel.style.left = `${left + width / 2 - errorLabelRect.width / 2}px`;
        break;
      }
    }
    errorLabel.dataset.direction = pos;
    const refresh = () => {
      this.renderTooltip(elem, errorLabel, position);
    };
    return {
      refresh
    };
  }
  createErrorLabelElem(key, errorMessage, config) {
    const errorLabel = document.createElement("div");
    errorLabel.innerHTML = errorMessage;
    const customErrorLabelStyle = this.isTooltip() ? config == null ? void 0 : config.errorLabelStyle : (config == null ? void 0 : config.errorLabelStyle) || this.globalConfig.errorLabelStyle;
    Object.assign(errorLabel.style, customErrorLabelStyle);
    errorLabel.classList.add(
      ...getClassList(
        (config == null ? void 0 : config.errorLabelCssClass) || this.globalConfig.errorLabelCssClass
      ),
      "just-validate-error-label"
    );
    if (this.isTooltip()) {
      errorLabel.dataset.tooltip = "true";
    }
    if (this.globalConfig.testingMode) {
      errorLabel.dataset.testId = `error-label-${key}`;
    }
    this.errorLabels[key] = errorLabel;
    return errorLabel;
  }
  createSuccessLabelElem(key, successMessage, config) {
    if (successMessage === void 0) {
      return null;
    }
    const successLabel = document.createElement("div");
    successLabel.innerHTML = successMessage;
    const customSuccessLabelStyle = (config == null ? void 0 : config.successLabelStyle) || this.globalConfig.successLabelStyle;
    Object.assign(successLabel.style, customSuccessLabelStyle);
    successLabel.classList.add(
      ...getClassList(
        (config == null ? void 0 : config.successLabelCssClass) || this.globalConfig.successLabelCssClass
      ),
      "just-validate-success-label"
    );
    if (this.globalConfig.testingMode) {
      successLabel.dataset.testId = `success-label-${key}`;
    }
    this.successLabels[key] = successLabel;
    return successLabel;
  }
  renderErrorsContainer(label, errorsContainer) {
    const container = errorsContainer || this.globalConfig.errorsContainer;
    if (typeof container === "string") {
      const elem = this.form.querySelector(container);
      if (elem) {
        elem.appendChild(label);
        return true;
      } else {
        console.error(
          `Error container with ${container} selector not found. Errors will be rendered as usual`
        );
      }
    }
    if (container instanceof Element) {
      container.appendChild(label);
      return true;
    }
    if (container !== void 0) {
      console.error(
        `Error container not found. It should be a string or existing Element. Errors will be rendered as usual`
      );
    }
    return false;
  }
  renderGroupLabel(elem, label, errorsContainer, isSuccess) {
    if (!isSuccess) {
      const renderedInErrorsContainer = this.renderErrorsContainer(
        label,
        errorsContainer
      );
      if (renderedInErrorsContainer) {
        return;
      }
    }
    elem.appendChild(label);
  }
  renderFieldLabel(elem, label, errorsContainer, isSuccess) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!isSuccess) {
      const renderedInErrorsContainer = this.renderErrorsContainer(
        label,
        errorsContainer
      );
      if (renderedInErrorsContainer) {
        return;
      }
    }
    if (elem.type === "checkbox" || elem.type === "radio") {
      const labelElem = document.querySelector(
        `label[for="${elem.getAttribute("id")}"]`
      );
      if (((_b = (_a = elem.parentElement) == null ? void 0 : _a.tagName) == null ? void 0 : _b.toLowerCase()) === "label") {
        (_d = (_c = elem.parentElement) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.appendChild(label);
      } else if (labelElem) {
        (_e = labelElem.parentElement) == null ? void 0 : _e.appendChild(label);
      } else {
        (_f = elem.parentElement) == null ? void 0 : _f.appendChild(label);
      }
    } else {
      (_g = elem.parentElement) == null ? void 0 : _g.appendChild(label);
    }
  }
  showLabels(fields, isError) {
    Object.keys(fields).forEach((fieldName, i) => {
      const error = fields[fieldName];
      const key = this.getKeyByFieldSelector(fieldName);
      if (!key || !this.fields[key]) {
        console.error(`Field not found. Check the field selector.`);
        return;
      }
      const field = this.fields[key];
      field.isValid = !isError;
      this.clearFieldStyle(key);
      this.clearFieldLabel(key);
      this.renderFieldError(key, false, error);
      if (i === 0 && this.globalConfig.focusInvalidField) {
        setTimeout(() => field.elem.focus(), 0);
      }
    });
  }
  showErrors(fields) {
    if (typeof fields !== "object") {
      throw Error(
        "[showErrors]: Errors should be an object with key: value format"
      );
    }
    this.showLabels(fields, true);
  }
  showSuccessLabels(fields) {
    if (typeof fields !== "object") {
      throw Error(
        "[showSuccessLabels]: Labels should be an object with key: value format"
      );
    }
    this.showLabels(fields, false);
  }
  renderFieldError(key, forced = false, message) {
    var _a, _b, _c, _d, _e, _f;
    const field = this.fields[key];
    if (field.isValid === false) {
      this.isValid = false;
    }
    if (field.isValid === void 0 || !forced && !this.isSubmitted && !field.touched && message === void 0) {
      return;
    }
    if (field.isValid) {
      if (!field.asyncCheckPending) {
        const successLabel = this.createSuccessLabelElem(
          key,
          message !== void 0 ? message : field.successMessage,
          field.config
        );
        if (successLabel) {
          this.renderFieldLabel(
            field.elem,
            successLabel,
            (_a = field.config) == null ? void 0 : _a.errorsContainer,
            true
          );
        }
        field.elem.classList.add(
          ...getClassList(
            ((_b = field.config) == null ? void 0 : _b.successFieldCssClass) || this.globalConfig.successFieldCssClass
          )
        );
      }
      return;
    }
    field.elem.classList.add(
      ...getClassList(
        ((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass
      )
    );
    const errorLabel = this.createErrorLabelElem(
      key,
      message !== void 0 ? message : field.errorMessage,
      field.config
    );
    this.renderFieldLabel(
      field.elem,
      errorLabel,
      (_d = field.config) == null ? void 0 : _d.errorsContainer
    );
    if (this.isTooltip()) {
      this.tooltips.push(
        this.renderTooltip(
          field.elem,
          errorLabel,
          (_f = (_e = field.config) == null ? void 0 : _e.tooltip) == null ? void 0 : _f.position
        )
      );
    }
  }
  renderGroupError(key, force = true) {
    var _a, _b, _c, _d;
    const group = this.groupFields[key];
    if (group.isValid === false) {
      this.isValid = false;
    }
    if (group.isValid === void 0 || !force && !this.isSubmitted && !group.touched) {
      return;
    }
    if (group.isValid) {
      group.elems.forEach((elem) => {
        var _a2, _b2;
        Object.assign(
          elem.style,
          ((_a2 = group.config) == null ? void 0 : _a2.successFieldStyle) || this.globalConfig.successFieldStyle
        );
        elem.classList.add(
          ...getClassList(
            ((_b2 = group.config) == null ? void 0 : _b2.successFieldCssClass) || this.globalConfig.successFieldCssClass
          )
        );
      });
      const successLabel = this.createSuccessLabelElem(
        key,
        group.successMessage,
        group.config
      );
      if (successLabel) {
        this.renderGroupLabel(
          group.groupElem,
          successLabel,
          (_a = group.config) == null ? void 0 : _a.errorsContainer,
          true
        );
      }
      return;
    }
    this.isValid = false;
    group.elems.forEach((elem) => {
      var _a2, _b2;
      Object.assign(
        elem.style,
        ((_a2 = group.config) == null ? void 0 : _a2.errorFieldStyle) || this.globalConfig.errorFieldStyle
      );
      elem.classList.add(
        ...getClassList(
          ((_b2 = group.config) == null ? void 0 : _b2.errorFieldCssClass) || this.globalConfig.errorFieldCssClass
        )
      );
    });
    const errorLabel = this.createErrorLabelElem(
      key,
      group.errorMessage,
      group.config
    );
    this.renderGroupLabel(
      group.groupElem,
      errorLabel,
      (_b = group.config) == null ? void 0 : _b.errorsContainer
    );
    if (this.isTooltip()) {
      this.tooltips.push(
        this.renderTooltip(
          group.groupElem,
          errorLabel,
          (_d = (_c = group.config) == null ? void 0 : _c.tooltip) == null ? void 0 : _d.position
        )
      );
    }
  }
  renderErrors(forceRevalidation = false) {
    if (!this.isSubmitted && !forceRevalidation && !this.globalConfig.validateBeforeSubmitting) {
      return;
    }
    this.clearErrors();
    this.isValid = true;
    for (const key in this.groupFields) {
      this.renderGroupError(key);
    }
    for (const key in this.fields) {
      this.renderFieldError(key);
    }
  }
  destroy() {
    this.eventListeners.forEach((event) => {
      this.removeListener(event.type, event.elem, event.func);
    });
    Object.keys(this.customStyleTags).forEach((key) => {
      this.customStyleTags[key].remove();
    });
    this.clearErrors();
    if (this.globalConfig.lockForm) {
      this.unlockForm();
    }
  }
  refresh() {
    this.destroy();
    if (!this.form) {
      console.error("Cannot initialize the library! Form is not defined");
    } else {
      this.initialize(this.form, this.globalConfig);
      Object.keys(this.fields).forEach((key) => {
        const fieldSelector = this.getFieldSelectorByKey(key);
        if (fieldSelector) {
          this.addField(
            fieldSelector,
            [...this.fields[key].rules],
            this.fields[key].config
          );
        }
      });
    }
  }
  setCurrentLocale(locale) {
    if (typeof locale !== "string" && locale !== void 0) {
      console.error("Current locale should be a string");
      return;
    }
    this.currentLocale = locale;
    if (this.isSubmitted) {
      this.validate();
    }
  }
  onSuccess(callback) {
    this.onSuccessCallback = callback;
    return this;
  }
  onFail(callback) {
    this.onFailCallback = callback;
    return this;
  }
  onValidate(callback) {
    this.onValidateCallback = callback;
    return this;
  }
}



/***/ }),

/***/ "./node_modules/object-is/implementation.js":
/*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ "./node_modules/object-is/index.js":
/*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/object-is/polyfill.js":
/*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ "./node_modules/object-is/shim.js":
/*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "./node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};


/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var inputmask_lib_inputmask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inputmask/lib/inputmask */ "./node_modules/inputmask/lib/inputmask.js");
/* harmony import */ var just_validate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! just-validate */ "./node_modules/just-validate/dist/just-validate.es.js");
// import Swiper from 'swiper';
// import {Navigation, Pagination} from 'swiper/modules';

var swiper = new Swiper('.swiper', {
  slidesPerView: 1,
  spaceBetween: 10,
  autoplay: {
    delay: 3000
  },
  speed: 2500,
  navigation: {
    nextEl: '.swiper-button-next',
    prevEl: '.swiper-button-prev'
  },
  breakpoints: {
    600: {
      spaceBetween: 50
    }
  }
});
var swiper2 = new Swiper('.certificates__slider', {
  autoplay: {
    delay: 3000
  },
  speed: 2500,
  navigation: {
    nextEl: '.swiper-button-next',
    prevEl: '.swiper-button-prev'
  },
  breakpoints: {
    320: {
      slidesPerView: 1
    },
    520: {
      slidesPerView: 3
    },
    992: {
      slidesPerView: 4
    }
  }
});
Fancybox.bind("[data-fancybox]", {});

// Spoilers
var spoilersArray = document.querySelectorAll('[data-spoilers]');
if (spoilersArray.length > 0) {
  // Инициализация
  var initSpoilers = function initSpoilers(spoilersArray) {
    var matchMedia = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    spoilersArray.forEach(function (spoilersBlock) {
      spoilersBlock = matchMedia ? spoilersBlock.item : spoilersBlock;
      if (matchMedia.matches || !matchMedia) {
        spoilersBlock.classList.add('_init');
        initSpoilerBody(spoilersBlock);
        spoilersBlock.addEventListener("click", setSpoilerAction);
      } else {
        spoilersBlock.classList.remove('_init');
        initSpoilerBody(spoilersBlock, false);
        spoilersBlock.removeEventListener("click", setSpoilerAction);
      }
    });
  }; // Работа с контентом
  var initSpoilerBody = function initSpoilerBody(spoilersBlock) {
    var hideSpoilerBody = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var spoilerTitles = spoilersBlock.querySelectorAll('[data-spoiler]');
    if (spoilerTitles.length > 0) {
      spoilerTitles.forEach(function (spoilerTitle) {
        if (hideSpoilerBody) {
          spoilerTitle.removeAttribute('tabindex');
          if (!spoilerTitle.classList.contains('_active')) {
            spoilerTitle.nextElementSibling.hidden = true;
          }
        } else {
          spoilerTitle.setAttribute('tabindex', '-1');
          spoilerTitle.nextElementSibling.hidden = false;
        }
      });
    }
  };
  var setSpoilerAction = function setSpoilerAction(e) {
    var el = e.target;
    if (el.hasAttribute('data-spoiler') || el.closest('[data-spoiler]')) {
      var spoilerTitle = el.hasAttribute('data-spoiler') ? el : el.closest('[data-spoiler]');
      var spoilersBlock = spoilerTitle.closest('[data-spoilers]');
      var oneSpoiler = spoilersBlock.hasAttribute('data-one-spoiler') ? true : false;
      if (!spoilersBlock.querySelectorAll('._slide').length) {
        if (oneSpoiler && !spoilerTitle.classList.contains('_active')) {
          hideSpoilersBody(spoilersBlock);
        }
        spoilerTitle.classList.toggle('_active');
        _slideToggle(spoilerTitle.nextElementSibling, 500);
      }
      e.preventDefault();
    }
  };
  var hideSpoilersBody = function hideSpoilersBody(spoilersBlock) {
    var spoilerActiveTitle = spoilersBlock.querySelector('[data-spoiler]._active');
    if (spoilerActiveTitle) {
      spoilerActiveTitle.classList.remove('_active');
      _slideUp(spoilerActiveTitle.nextElementSibling, 500);
    }
  };
  // Получение обычных спойлеров
  var spoilersRegular = Array.from(spoilersArray).filter(function (item, index, self) {
    return !item.dataset.spoilers.split(",")[0];
  });
  // Инициализация обычных спойлеров
  if (spoilersRegular.length > 0) {
    initSpoilers(spoilersRegular);
  }

  // Получение спойлеров с медиа запросами
  var spoilersMedia = Array.from(spoilersArray).filter(function (item, index, self) {
    return item.dataset.spoilers.split(",")[0];
  });

  // Инициализация спойлеров с медиа запросами
  if (spoilersMedia.length > 0) {
    var breakpointsArray = [];
    spoilersMedia.forEach(function (item) {
      var params = item.dataset.spoilers;
      var breakpoint = {};
      var paramsArray = params.split(",");
      breakpoint.value = paramsArray[0];
      breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : "max";
      breakpoint.item = item;
      breakpointsArray.push(breakpoint);
    });

    // Получаем уникальные брейкпоинты
    var mediaQueries = breakpointsArray.map(function (item) {
      return '(' + item.type + "-width: " + item.value + "px)," + item.value + ',' + item.type;
    });
    mediaQueries = mediaQueries.filter(function (item, index, self) {
      return self.indexOf(item) === index;
    });

    // Работаем с каждым брейкпоинтом
    mediaQueries.forEach(function (breakpoint) {
      var paramsArray = breakpoint.split(",");
      var mediaBreakpoint = paramsArray[1];
      var mediaType = paramsArray[2];
      var matchMedia = window.matchMedia(paramsArray[0]);

      // Объекты с нужными условиями
      var spoilersArray = breakpointsArray.filter(function (item) {
        if (item.value === mediaBreakpoint && item.type === mediaType) {
          return true;
        }
      });
      // Событие
      matchMedia.addListener(function () {
        initSpoilers(spoilersArray, matchMedia);
      });
      initSpoilers(spoilersArray, matchMedia);
    });
  }
}

// SlideToggle
var _slideUp = function _slideUp(target) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  if (!target.classList.contains('_slide')) {
    target.classList.add('_slide');
    target.style.transitionProperty = 'height, margin, padding';
    target.style.transitionDuration = duration + 'ms';
    target.style.height = target.offsetHeight + 'px';
    target.offsetHeight;
    target.style.overflow = 'hidden';
    target.style.height = 0;
    target.style.paddingTop = 0;
    target.style.paddingBottom = 0;
    target.style.marginTop = 0;
    target.style.marginBottom = 0;
    window.setTimeout(function () {
      target.hidden = true;
      target.style.removeProperty('height');
      target.style.removeProperty('padding-top');
      target.style.removeProperty('padding-bottom');
      target.style.removeProperty('margin-top');
      target.style.removeProperty('margin-bottom');
      target.style.removeProperty('overflow');
      target.style.removeProperty('transition-duration');
      target.style.removeProperty('transition-property');
      target.classList.remove('_slide');
    }, duration);
  }
};
var _slideDown = function _slideDown(target) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  if (!target.classList.contains('_slide')) {
    target.classList.add('_slide');
    if (target.hidden) {
      target.hidden = false;
    }
    var height = target.offsetHeight;
    target.style.overflow = 'hidden';
    target.style.height = 0;
    target.style.paddingTop = 0;
    target.style.paddingBottom = 0;
    target.style.marginTop = 0;
    target.style.marginBottom = 0;
    target.offsetHeight;
    target.style.transitionProperty = "height, margin, padding";
    target.style.transitionDuration = duration + 'ms';
    target.style.height = height + 'px';
    target.style.removeProperty('padding-top');
    target.style.removeProperty('padding-bottom');
    target.style.removeProperty('margin-top');
    target.style.removeProperty('margin-bottom');
    window.setTimeout(function () {
      target.style.removeProperty('height');
      target.style.removeProperty('overflow');
      target.style.removeProperty('transition-duration');
      target.style.removeProperty('transition-property');
      target.classList.remove('_slide');
    }, duration);
  }
};
var _slideToggle = function _slideToggle(target) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  if (target.hidden) {
    return _slideDown(target, duration);
  } else {
    return _slideUp(target, duration);
  }
};


})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQyxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvS0FBb0s7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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Ozs7Ozs7O0FDaEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOzs7Ozs7Ozs7OztBQ3ZMN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7O0FBRWE7O0FBRWIsd0JBQXdCLG1CQUFPLENBQUMsMERBQWM7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMsNEVBQXVCO0FBQ3pELHNCQUFzQixtQkFBTyxDQUFDLG9FQUFtQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBZ0I7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7OztBQUd6QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7O0FDN1VEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEsT0FBTyxvQkFBb0IsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBLFFBQVEsU0FBUyxPQUFPO0FBQ3hCLFFBQVEsT0FBTztBQUNmLFFBQVE7QUFDUixRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsSUFBSSxPQUFPO0FBQ1gsaUJBQWlCLE9BQU87QUFDeEIscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrR0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQixrSEFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVztBQUNYLEVBQUUsT0FBTztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxxR0FBc0M7O0FBRXRDLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxxQ0FBcUM7QUFDeEUsNEJBQTRCLE9BQU8sc0RBQXNEO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7Ozs7Ozs7Ozs7OztBQzFzQk47O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtEQUFVO0FBQ2hDLDJCQUEyQixtQkFBTyxDQUFDLDhFQUF3QjtBQUMzRCxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBcUI7QUFDN0MsV0FBVyxtQkFBTyxDQUFDLDBDQUFNOztBQUV6QjtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHNFQUF1Qjs7QUFFcEQsNENBQTRDLHFCQUFNO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBZ0I7O0FBRTNDO0FBQ0EsNkJBQTZCO0FBQzdCLDBEQUEwRDtBQUMxRDtBQUNBOzs7Ozs7Ozs7Ozs7QUN0RGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHFCQUFNOztBQUVsRDtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7VUMxQkE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTs7QUFFQSxJQUFNQSxNQUFNLEdBQUcsSUFBSUMsTUFBTSxDQUFDLFNBQVMsRUFBRTtFQUNwQ0MsYUFBYSxFQUFFLENBQUM7RUFDaEJDLFlBQVksRUFBRSxFQUFFO0VBQ2hCQyxRQUFRLEVBQUU7SUFDVEMsS0FBSyxFQUFFO0VBQ1IsQ0FBQztFQUNEQyxLQUFLLEVBQUUsSUFBSTtFQUNYQyxVQUFVLEVBQUU7SUFDWEMsTUFBTSxFQUFFLHFCQUFxQjtJQUM3QkMsTUFBTSxFQUFFO0VBQ1QsQ0FBQztFQUVEQyxXQUFXLEVBQUU7SUFDWixHQUFHLEVBQUU7TUFDSlAsWUFBWSxFQUFFO0lBQ2Y7RUFDRDtBQUNELENBQUMsQ0FBQztBQUVGLElBQU1RLE9BQU8sR0FBRyxJQUFJVixNQUFNLENBQUMsdUJBQXVCLEVBQUU7RUFDbkRHLFFBQVEsRUFBRTtJQUNUQyxLQUFLLEVBQUU7RUFDUixDQUFDO0VBQ0RDLEtBQUssRUFBRSxJQUFJO0VBQ1hDLFVBQVUsRUFBRTtJQUNYQyxNQUFNLEVBQUUscUJBQXFCO0lBQzdCQyxNQUFNLEVBQUU7RUFDVCxDQUFDO0VBQ0RDLFdBQVcsRUFBRTtJQUNaLEdBQUcsRUFBRTtNQUNKUixhQUFhLEVBQUU7SUFDaEIsQ0FBQztJQUNELEdBQUcsRUFBRTtNQUNKQSxhQUFhLEVBQUU7SUFDaEIsQ0FBQztJQUNELEdBQUcsRUFBRTtNQUNKQSxhQUFhLEVBQUU7SUFDaEI7RUFDRDtBQUNELENBQUMsQ0FBQztBQUVGVSxRQUFRLENBQUNDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUMsQ0FBQzs7QUFHcEM7QUFDQSxJQUFNQyxhQUFhLEdBQUdDLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUM7QUFDbEUsSUFBSUYsYUFBYSxDQUFDRyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0VBeUQ3QjtFQUFBLElBQ1NDLFlBQVksR0FBckIsU0FBU0EsWUFBWUEsQ0FBQ0osYUFBYSxFQUFzQjtJQUFBLElBQXBCSyxVQUFVLEdBQUFDLFNBQUEsQ0FBQUgsTUFBQSxRQUFBRyxTQUFBLFFBQUFDLFNBQUEsR0FBQUQsU0FBQSxNQUFHLEtBQUs7SUFDdEROLGFBQWEsQ0FBQ1EsT0FBTyxDQUFDLFVBQUFDLGFBQWEsRUFBSTtNQUN0Q0EsYUFBYSxHQUFHSixVQUFVLEdBQUdJLGFBQWEsQ0FBQ0MsSUFBSSxHQUFHRCxhQUFhO01BQy9ELElBQUlKLFVBQVUsQ0FBQ00sT0FBTyxJQUFJLENBQUNOLFVBQVUsRUFBRTtRQUN0Q0ksYUFBYSxDQUFDRyxTQUFTLENBQUNDLEdBQUcsQ0FBQyxPQUFPLENBQUM7UUFDcENDLGVBQWUsQ0FBQ0wsYUFBYSxDQUFDO1FBQzlCQSxhQUFhLENBQUNNLGdCQUFnQixDQUFDLE9BQU8sRUFBRUMsZ0JBQWdCLENBQUM7TUFDMUQsQ0FBQyxNQUFNO1FBQ05QLGFBQWEsQ0FBQ0csU0FBUyxDQUFDSyxNQUFNLENBQUMsT0FBTyxDQUFDO1FBQ3ZDSCxlQUFlLENBQUNMLGFBQWEsRUFBRSxLQUFLLENBQUM7UUFDckNBLGFBQWEsQ0FBQ1MsbUJBQW1CLENBQUMsT0FBTyxFQUFFRixnQkFBZ0IsQ0FBQztNQUM3RDtJQUNELENBQUMsQ0FBQztFQUNILENBQUMsRUFFRDtFQUFBLElBQ1NGLGVBQWUsR0FBeEIsU0FBU0EsZUFBZUEsQ0FBQ0wsYUFBYSxFQUEwQjtJQUFBLElBQXhCVSxlQUFlLEdBQUFiLFNBQUEsQ0FBQUgsTUFBQSxRQUFBRyxTQUFBLFFBQUFDLFNBQUEsR0FBQUQsU0FBQSxNQUFHLElBQUk7SUFDN0QsSUFBTWMsYUFBYSxHQUFHWCxhQUFhLENBQUNQLGdCQUFnQixDQUFDLGdCQUFnQixDQUFDO0lBQ3RFLElBQUlrQixhQUFhLENBQUNqQixNQUFNLEdBQUcsQ0FBQyxFQUFFO01BQzdCaUIsYUFBYSxDQUFDWixPQUFPLENBQUMsVUFBQWEsWUFBWSxFQUFJO1FBQ3JDLElBQUlGLGVBQWUsRUFBRTtVQUNwQkUsWUFBWSxDQUFDQyxlQUFlLENBQUMsVUFBVSxDQUFDO1VBQ3hDLElBQUksQ0FBQ0QsWUFBWSxDQUFDVCxTQUFTLENBQUNXLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNoREYsWUFBWSxDQUFDRyxrQkFBa0IsQ0FBQ0MsTUFBTSxHQUFHLElBQUk7VUFDOUM7UUFDRCxDQUFDLE1BQU07VUFDTkosWUFBWSxDQUFDSyxZQUFZLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQztVQUMzQ0wsWUFBWSxDQUFDRyxrQkFBa0IsQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7UUFDL0M7TUFDRCxDQUFDLENBQUM7SUFDSDtFQUNELENBQUM7RUFBQSxJQUVRVCxnQkFBZ0IsR0FBekIsU0FBU0EsZ0JBQWdCQSxDQUFDVyxDQUFDLEVBQUU7SUFDNUIsSUFBTUMsRUFBRSxHQUFHRCxDQUFDLENBQUNFLE1BQU07SUFDbkIsSUFBSUQsRUFBRSxDQUFDRSxZQUFZLENBQUMsY0FBYyxDQUFDLElBQUlGLEVBQUUsQ0FBQ0csT0FBTyxDQUFDLGdCQUFnQixDQUFDLEVBQUU7TUFDcEUsSUFBTVYsWUFBWSxHQUFHTyxFQUFFLENBQUNFLFlBQVksQ0FBQyxjQUFjLENBQUMsR0FBR0YsRUFBRSxHQUFHQSxFQUFFLENBQUNHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztNQUN4RixJQUFNdEIsYUFBYSxHQUFHWSxZQUFZLENBQUNVLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztNQUM3RCxJQUFNQyxVQUFVLEdBQUd2QixhQUFhLENBQUNxQixZQUFZLENBQUMsa0JBQWtCLENBQUMsR0FBRyxJQUFJLEdBQUcsS0FBSztNQUNoRixJQUFJLENBQUNyQixhQUFhLENBQUNQLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDQyxNQUFNLEVBQUU7UUFDdEQsSUFBSTZCLFVBQVUsSUFBSSxDQUFDWCxZQUFZLENBQUNULFNBQVMsQ0FBQ1csUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1VBQzlEVSxnQkFBZ0IsQ0FBQ3hCLGFBQWEsQ0FBQztRQUNoQztRQUNBWSxZQUFZLENBQUNULFNBQVMsQ0FBQ3NCLE1BQU0sQ0FBQyxTQUFTLENBQUM7UUFDeENDLFlBQVksQ0FBQ2QsWUFBWSxDQUFDRyxrQkFBa0IsRUFBRSxHQUFHLENBQUM7TUFDbkQ7TUFDQUcsQ0FBQyxDQUFDUyxjQUFjLEVBQUU7SUFDbkI7RUFDRCxDQUFDO0VBQUEsSUFFUUgsZ0JBQWdCLEdBQXpCLFNBQVNBLGdCQUFnQkEsQ0FBQ3hCLGFBQWEsRUFBRTtJQUN4QyxJQUFNNEIsa0JBQWtCLEdBQUc1QixhQUFhLENBQUM2QixhQUFhLENBQUMsd0JBQXdCLENBQUM7SUFDaEYsSUFBSUQsa0JBQWtCLEVBQUU7TUFDdkJBLGtCQUFrQixDQUFDekIsU0FBUyxDQUFDSyxNQUFNLENBQUMsU0FBUyxDQUFDO01BQzlDc0IsUUFBUSxDQUFDRixrQkFBa0IsQ0FBQ2Isa0JBQWtCLEVBQUUsR0FBRyxDQUFDO0lBQ3JEO0VBQ0QsQ0FBQztFQWpIRDtFQUNBLElBQU1nQixlQUFlLEdBQUdDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDMUMsYUFBYSxDQUFDLENBQUMyQyxNQUFNLENBQUMsVUFBVWpDLElBQUksRUFBRWtDLEtBQUssRUFBRUMsSUFBSSxFQUFFO0lBQ3JGLE9BQU8sQ0FBQ25DLElBQUksQ0FBQ29DLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzVDLENBQUMsQ0FBQztFQUNGO0VBQ0EsSUFBSVIsZUFBZSxDQUFDckMsTUFBTSxHQUFHLENBQUMsRUFBRTtJQUMvQkMsWUFBWSxDQUFDb0MsZUFBZSxDQUFDO0VBQzlCOztFQUVBO0VBQ0EsSUFBTVMsYUFBYSxHQUFHUixLQUFLLENBQUNDLElBQUksQ0FBQzFDLGFBQWEsQ0FBQyxDQUFDMkMsTUFBTSxDQUFDLFVBQVVqQyxJQUFJLEVBQUVrQyxLQUFLLEVBQUVDLElBQUksRUFBRTtJQUNuRixPQUFPbkMsSUFBSSxDQUFDb0MsT0FBTyxDQUFDQyxRQUFRLENBQUNDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDM0MsQ0FBQyxDQUFDOztFQUVGO0VBQ0EsSUFBSUMsYUFBYSxDQUFDOUMsTUFBTSxHQUFHLENBQUMsRUFBRTtJQUM3QixJQUFNK0MsZ0JBQWdCLEdBQUcsRUFBRTtJQUMzQkQsYUFBYSxDQUFDekMsT0FBTyxDQUFDLFVBQUFFLElBQUksRUFBSTtNQUM3QixJQUFNeUMsTUFBTSxHQUFHekMsSUFBSSxDQUFDb0MsT0FBTyxDQUFDQyxRQUFRO01BQ3BDLElBQU1LLFVBQVUsR0FBRyxDQUFDLENBQUM7TUFDckIsSUFBTUMsV0FBVyxHQUFHRixNQUFNLENBQUNILEtBQUssQ0FBQyxHQUFHLENBQUM7TUFDckNJLFVBQVUsQ0FBQ0UsS0FBSyxHQUFHRCxXQUFXLENBQUMsQ0FBQyxDQUFDO01BQ2pDRCxVQUFVLENBQUNHLElBQUksR0FBR0YsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHQSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUNHLElBQUksRUFBRSxHQUFHLEtBQUs7TUFDaEVKLFVBQVUsQ0FBQzFDLElBQUksR0FBR0EsSUFBSTtNQUN0QndDLGdCQUFnQixDQUFDTyxJQUFJLENBQUNMLFVBQVUsQ0FBQztJQUNsQyxDQUFDLENBQUM7O0lBRUY7SUFDQSxJQUFJTSxZQUFZLEdBQUdSLGdCQUFnQixDQUFDUyxHQUFHLENBQUMsVUFBVWpELElBQUksRUFBRTtNQUN2RCxPQUFPLEdBQUcsR0FBR0EsSUFBSSxDQUFDNkMsSUFBSSxHQUFHLFVBQVUsR0FBRzdDLElBQUksQ0FBQzRDLEtBQUssR0FBRyxNQUFNLEdBQUc1QyxJQUFJLENBQUM0QyxLQUFLLEdBQUcsR0FBRyxHQUFHNUMsSUFBSSxDQUFDNkMsSUFBSTtJQUN6RixDQUFDLENBQUM7SUFDRkcsWUFBWSxHQUFHQSxZQUFZLENBQUNmLE1BQU0sQ0FBQyxVQUFVakMsSUFBSSxFQUFFa0MsS0FBSyxFQUFFQyxJQUFJLEVBQUU7TUFDL0QsT0FBT0EsSUFBSSxDQUFDZSxPQUFPLENBQUNsRCxJQUFJLENBQUMsS0FBS2tDLEtBQUs7SUFDcEMsQ0FBQyxDQUFDOztJQUVGO0lBQ0FjLFlBQVksQ0FBQ2xELE9BQU8sQ0FBQyxVQUFBNEMsVUFBVSxFQUFJO01BQ2xDLElBQU1DLFdBQVcsR0FBR0QsVUFBVSxDQUFDSixLQUFLLENBQUMsR0FBRyxDQUFDO01BQ3pDLElBQU1hLGVBQWUsR0FBR1IsV0FBVyxDQUFDLENBQUMsQ0FBQztNQUN0QyxJQUFNUyxTQUFTLEdBQUdULFdBQVcsQ0FBQyxDQUFDLENBQUM7TUFDaEMsSUFBTWhELFVBQVUsR0FBRzBELE1BQU0sQ0FBQzFELFVBQVUsQ0FBQ2dELFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7TUFFcEQ7TUFDQSxJQUFNckQsYUFBYSxHQUFHa0QsZ0JBQWdCLENBQUNQLE1BQU0sQ0FBQyxVQUFVakMsSUFBSSxFQUFFO1FBQzdELElBQUlBLElBQUksQ0FBQzRDLEtBQUssS0FBS08sZUFBZSxJQUFJbkQsSUFBSSxDQUFDNkMsSUFBSSxLQUFLTyxTQUFTLEVBQUU7VUFDOUQsT0FBTyxJQUFJO1FBQ1o7TUFDRCxDQUFDLENBQUM7TUFDRjtNQUNBekQsVUFBVSxDQUFDMkQsV0FBVyxDQUFDLFlBQVk7UUFDbEM1RCxZQUFZLENBQUNKLGFBQWEsRUFBRUssVUFBVSxDQUFDO01BQ3hDLENBQUMsQ0FBQztNQUNGRCxZQUFZLENBQUNKLGFBQWEsRUFBRUssVUFBVSxDQUFDO0lBQ3hDLENBQUMsQ0FBQztFQUNIO0FBNEREOztBQUdBO0FBQ0EsSUFBSWtDLFFBQVEsR0FBRyxTQUFYQSxRQUFRQSxDQUFJVixNQUFNLEVBQXFCO0VBQUEsSUFBbkJvQyxRQUFRLEdBQUEzRCxTQUFBLENBQUFILE1BQUEsUUFBQUcsU0FBQSxRQUFBQyxTQUFBLEdBQUFELFNBQUEsTUFBRyxHQUFHO0VBQ3JDLElBQUksQ0FBQ3VCLE1BQU0sQ0FBQ2pCLFNBQVMsQ0FBQ1csUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO0lBQ3pDTSxNQUFNLENBQUNqQixTQUFTLENBQUNDLEdBQUcsQ0FBQyxRQUFRLENBQUM7SUFDOUJnQixNQUFNLENBQUNxQyxLQUFLLENBQUNDLGtCQUFrQixHQUFHLHlCQUF5QjtJQUMzRHRDLE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ0Usa0JBQWtCLEdBQUdILFFBQVEsR0FBRyxJQUFJO0lBQ2pEcEMsTUFBTSxDQUFDcUMsS0FBSyxDQUFDRyxNQUFNLEdBQUd4QyxNQUFNLENBQUN5QyxZQUFZLEdBQUcsSUFBSTtJQUNoRHpDLE1BQU0sQ0FBQ3lDLFlBQVk7SUFDbkJ6QyxNQUFNLENBQUNxQyxLQUFLLENBQUNLLFFBQVEsR0FBRyxRQUFRO0lBQ2hDMUMsTUFBTSxDQUFDcUMsS0FBSyxDQUFDRyxNQUFNLEdBQUcsQ0FBQztJQUN2QnhDLE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ00sVUFBVSxHQUFHLENBQUM7SUFDM0IzQyxNQUFNLENBQUNxQyxLQUFLLENBQUNPLGFBQWEsR0FBRyxDQUFDO0lBQzlCNUMsTUFBTSxDQUFDcUMsS0FBSyxDQUFDUSxTQUFTLEdBQUcsQ0FBQztJQUMxQjdDLE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ1MsWUFBWSxHQUFHLENBQUM7SUFDN0JaLE1BQU0sQ0FBQ2EsVUFBVSxDQUFDLFlBQU07TUFDdkIvQyxNQUFNLENBQUNKLE1BQU0sR0FBRyxJQUFJO01BQ3BCSSxNQUFNLENBQUNxQyxLQUFLLENBQUNXLGNBQWMsQ0FBQyxRQUFRLENBQUM7TUFDckNoRCxNQUFNLENBQUNxQyxLQUFLLENBQUNXLGNBQWMsQ0FBQyxhQUFhLENBQUM7TUFDMUNoRCxNQUFNLENBQUNxQyxLQUFLLENBQUNXLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQztNQUM3Q2hELE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ1csY0FBYyxDQUFDLFlBQVksQ0FBQztNQUN6Q2hELE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ1csY0FBYyxDQUFDLGVBQWUsQ0FBQztNQUM1Q2hELE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ1csY0FBYyxDQUFDLFVBQVUsQ0FBQztNQUN2Q2hELE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ1csY0FBYyxDQUFDLHFCQUFxQixDQUFDO01BQ2xEaEQsTUFBTSxDQUFDcUMsS0FBSyxDQUFDVyxjQUFjLENBQUMscUJBQXFCLENBQUM7TUFDbERoRCxNQUFNLENBQUNqQixTQUFTLENBQUNLLE1BQU0sQ0FBQyxRQUFRLENBQUM7SUFDbEMsQ0FBQyxFQUFFZ0QsUUFBUSxDQUFDO0VBQ2I7QUFDRCxDQUFDO0FBQ0QsSUFBSWEsVUFBVSxHQUFHLFNBQWJBLFVBQVVBLENBQUlqRCxNQUFNLEVBQXFCO0VBQUEsSUFBbkJvQyxRQUFRLEdBQUEzRCxTQUFBLENBQUFILE1BQUEsUUFBQUcsU0FBQSxRQUFBQyxTQUFBLEdBQUFELFNBQUEsTUFBRyxHQUFHO0VBQ3ZDLElBQUksQ0FBQ3VCLE1BQU0sQ0FBQ2pCLFNBQVMsQ0FBQ1csUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO0lBQ3pDTSxNQUFNLENBQUNqQixTQUFTLENBQUNDLEdBQUcsQ0FBQyxRQUFRLENBQUM7SUFDOUIsSUFBSWdCLE1BQU0sQ0FBQ0osTUFBTSxFQUFFO01BQ2xCSSxNQUFNLENBQUNKLE1BQU0sR0FBRyxLQUFLO0lBQ3RCO0lBQ0EsSUFBSTRDLE1BQU0sR0FBR3hDLE1BQU0sQ0FBQ3lDLFlBQVk7SUFDaEN6QyxNQUFNLENBQUNxQyxLQUFLLENBQUNLLFFBQVEsR0FBRyxRQUFRO0lBQ2hDMUMsTUFBTSxDQUFDcUMsS0FBSyxDQUFDRyxNQUFNLEdBQUcsQ0FBQztJQUN2QnhDLE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ00sVUFBVSxHQUFHLENBQUM7SUFDM0IzQyxNQUFNLENBQUNxQyxLQUFLLENBQUNPLGFBQWEsR0FBRyxDQUFDO0lBQzlCNUMsTUFBTSxDQUFDcUMsS0FBSyxDQUFDUSxTQUFTLEdBQUcsQ0FBQztJQUMxQjdDLE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ1MsWUFBWSxHQUFHLENBQUM7SUFDN0I5QyxNQUFNLENBQUN5QyxZQUFZO0lBQ25CekMsTUFBTSxDQUFDcUMsS0FBSyxDQUFDQyxrQkFBa0IsR0FBRyx5QkFBeUI7SUFDM0R0QyxNQUFNLENBQUNxQyxLQUFLLENBQUNFLGtCQUFrQixHQUFHSCxRQUFRLEdBQUcsSUFBSTtJQUNqRHBDLE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ0csTUFBTSxHQUFHQSxNQUFNLEdBQUcsSUFBSTtJQUNuQ3hDLE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ1csY0FBYyxDQUFDLGFBQWEsQ0FBQztJQUMxQ2hELE1BQU0sQ0FBQ3FDLEtBQUssQ0FBQ1csY0FBYyxDQUFDLGdCQUFnQixDQUFDO0lBQzdDaEQsTUFBTSxDQUFDcUMsS0FBSyxDQUFDVyxjQUFjLENBQUMsWUFBWSxDQUFDO0lBQ3pDaEQsTUFBTSxDQUFDcUMsS0FBSyxDQUFDVyxjQUFjLENBQUMsZUFBZSxDQUFDO0lBQzVDZCxNQUFNLENBQUNhLFVBQVUsQ0FBQyxZQUFNO01BQ3ZCL0MsTUFBTSxDQUFDcUMsS0FBSyxDQUFDVyxjQUFjLENBQUMsUUFBUSxDQUFDO01BQ3JDaEQsTUFBTSxDQUFDcUMsS0FBSyxDQUFDVyxjQUFjLENBQUMsVUFBVSxDQUFDO01BQ3ZDaEQsTUFBTSxDQUFDcUMsS0FBSyxDQUFDVyxjQUFjLENBQUMscUJBQXFCLENBQUM7TUFDbERoRCxNQUFNLENBQUNxQyxLQUFLLENBQUNXLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQztNQUNsRGhELE1BQU0sQ0FBQ2pCLFNBQVMsQ0FBQ0ssTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUNsQyxDQUFDLEVBQUVnRCxRQUFRLENBQUM7RUFDYjtBQUNELENBQUM7QUFDRCxJQUFJOUIsWUFBWSxHQUFHLFNBQWZBLFlBQVlBLENBQUlOLE1BQU0sRUFBcUI7RUFBQSxJQUFuQm9DLFFBQVEsR0FBQTNELFNBQUEsQ0FBQUgsTUFBQSxRQUFBRyxTQUFBLFFBQUFDLFNBQUEsR0FBQUQsU0FBQSxNQUFHLEdBQUc7RUFDekMsSUFBSXVCLE1BQU0sQ0FBQ0osTUFBTSxFQUFFO0lBQ2xCLE9BQU9xRCxVQUFVLENBQUNqRCxNQUFNLEVBQUVvQyxRQUFRLENBQUM7RUFDcEMsQ0FBQyxNQUFNO0lBQ04sT0FBTzFCLFFBQVEsQ0FBQ1YsTUFBTSxFQUFFb0MsUUFBUSxDQUFDO0VBQ2xDO0FBQ0QsQ0FBQztBQUcrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZXM2LW9iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZ29wZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9oYXMtcHJvcGVydHktZGVzY3JpcHRvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svbGliL2NhblVzZURPTS5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lucHV0bWFzay9saWIvZGVmaW5pdGlvbnMuanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaW5wdXRtYXNrL2xpYi9kZXBlbmRlbmN5TGlicy9kYXRhLmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lucHV0bWFzay9saWIvZGVwZW5kZW5jeUxpYnMvZXZlbnRzLmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lucHV0bWFzay9saWIvZGVwZW5kZW5jeUxpYnMvZXh0ZW5kLmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lucHV0bWFzay9saWIvZGVwZW5kZW5jeUxpYnMvaW5wdXRtYXNrLmRlcGVuZGVuY3lMaWIuanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaW5wdXRtYXNrL2xpYi9lbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svbGliL2VzY2FwZVJlZ2V4LmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lucHV0bWFzay9saWIvZXZlbnRoYW5kbGVycy5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svbGliL2V2ZW50cnVsZXIuanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaW5wdXRtYXNrL2xpYi9nbG9iYWwvd2luZG93LmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lucHV0bWFzay9saWIvaW5wdXRIYW5kbGluZy5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svbGliL2lucHV0bWFzay5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svbGliL2tleWNvZGUuanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaW5wdXRtYXNrL2xpYi9tYXNrLWxleGVyLmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lucHV0bWFzay9saWIvbWFzay5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svbGliL21hc2t0b2tlbi5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svbGliL3Bvc2l0aW9uaW5nLmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lucHV0bWFzay9saWIvdmFsaWRhdGlvbi10ZXN0cy5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svbGliL3ZhbGlkYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaXMtYXJndW1lbnRzL2luZGV4LmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lzLWNhbGxhYmxlL2luZGV4LmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaXMtbmFuL2luZGV4LmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vc2hpbS5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9pcy10eXBlZC1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qdXN0LXZhbGlkYXRlL2Rpc3QvanVzdC12YWxpZGF0ZS5lcy5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvc2hpbS5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3doaWNoLXR5cGVkLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vc2xhZ3JhY2gtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9zbGFncmFjaC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3NsYWdyYWNoLXRlbXBsYXRlLy4vc3JjL2pzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9lcnJvcnMnKSxcbiAgICBfcmVxdWlyZSRjb2RlcyA9IF9yZXF1aXJlLmNvZGVzLFxuICAgIEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfQU1CSUdVT1VTX0FSR1VNRU5ULFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1ZBTFVFLFxuICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUztcblxudmFyIEFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yJyk7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsLycpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogcmVxdWlyZSgnZXM2LW9iamVjdC1hc3NpZ24nKS5hc3NpZ247XG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiByZXF1aXJlKCdvYmplY3QtaXMnKTtcbnZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpO1xudmFyIGlzRGVlcEVxdWFsO1xudmFyIGlzRGVlcFN0cmljdEVxdWFsO1xudmFyIHBhcnNlRXhwcmVzc2lvbkF0O1xudmFyIGZpbmROb2RlQXJvdW5kO1xudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGxhenlMb2FkQ29tcGFyaXNvbigpIHtcbiAgdmFyIGNvbXBhcmlzb24gPSByZXF1aXJlKCcuL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMnKTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdO1xuXG52YXIgZXNjYXBlRm4gPSBmdW5jdGlvbiBlc2NhcGVGbihzdHIpIHtcbiAgcmV0dXJuIG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldO1xufTtcblxudmFyIHdhcm5lZCA9IGZhbHNlOyAvLyBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG52YXIgTk9fRVhDRVBUSU9OX1NFTlRJTkVMID0ge307IC8vIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gaW5uZXJGYWlsKG9iaikge1xuICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopO1xufVxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0Rm4pIHtcbiAgdmFyIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW50ZXJuYWxNZXNzYWdlO1xuXG4gIGlmIChhcmdzTGVuID09PSAwKSB7XG4gICAgaW50ZXJuYWxNZXNzYWdlID0gJ0ZhaWxlZCc7XG4gIH0gZWxzZSBpZiAoYXJnc0xlbiA9PT0gMSkge1xuICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGlmICh3YXJuZWQgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgdmFyIHdhcm4gPSBwcm9jZXNzLmVtaXRXYXJuaW5nID8gcHJvY2Vzcy5lbWl0V2FybmluZyA6IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgd2FybignYXNzZXJ0LmZhaWwoKSB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gJyArICdQbGVhc2UgdXNlIGFzc2VydC5zdHJpY3RFcXVhbCgpIGluc3RlYWQgb3Igb25seSBwYXNzIGEgbWVzc2FnZS4nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwOTQnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc0xlbiA9PT0gMikgb3BlcmF0b3IgPSAnIT0nO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgbWVzc2FnZTtcbiAgdmFyIGVyckFyZ3MgPSB7XG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkID8gJ2ZhaWwnIDogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4gfHwgZmFpbFxuICB9O1xuXG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlcnJBcmdzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcihlcnJBcmdzKTtcblxuICBpZiAoaW50ZXJuYWxNZXNzYWdlKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBpbnRlcm5hbE1lc3NhZ2U7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG5cbiAgdGhyb3cgZXJyO1xufVxuXG5hc3NlcnQuZmFpbCA9IGZhaWw7IC8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcblxuZnVuY3Rpb24gaW5uZXJPayhmbiwgYXJnTGVuLCB2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFyIGdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcblxuICAgIGlmIChhcmdMZW4gPT09IDApIHtcbiAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IHZhbHVlLFxuICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufSAvLyBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIXZhbHVlLlxuXG5cbmZ1bmN0aW9uIG9rKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtvaywgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5vayA9IG9rOyAvLyBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGggPT0uXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBlcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90XG4vLyBlcXVhbCB3aXRoICE9LlxuXG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICchPScsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuXG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cblxuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuXG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn1cblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoIW9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90U3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIENvbXBhcmlzb24gPSBmdW5jdGlvbiBDb21wYXJpc29uKG9iaiwga2V5cywgYWN0dWFsKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBhcmlzb24pO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChhY3R1YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKG9ialtrZXldKSAmJiBvYmpba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICBfdGhpc1trZXldID0gYWN0dWFsW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpc1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtZXNzYWdlLCBrZXlzLCBmbikge1xuICBpZiAoIShrZXkgaW4gYWN0dWFsKSB8fCAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pKSB7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgb2JqZWN0cyB0byBjcmVhdGUgYSBuaWNlIG91dHB1dC5cbiAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKTtcbiAgICAgIHZhciBiID0gbmV3IENvbXBhcmlzb24oZXhwZWN0ZWQsIGtleXMsIGFjdHVhbCk7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICBleHBlY3RlZDogYixcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWw7XG4gICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiBmbi5uYW1lLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc1JlZ0V4cChleHBlY3RlZCkpIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7IC8vIGFzc2VydC5kb2VzTm90VGhyb3cgZG9lcyBub3QgYWNjZXB0IG9iamVjdHMuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdleHBlY3RlZCcsIFsnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGV4cGVjdGVkKTtcbiAgICB9IC8vIEhhbmRsZSBwcmltaXRpdmVzIHByb3Blcmx5LlxuXG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcbiAgICAvLyBhcyB3ZWxsLlxuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMucHVzaCgnbmFtZScsICdtZXNzYWdlJyk7XG4gICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZXJyb3InLCBleHBlY3RlZCwgJ21heSBub3QgYmUgYW4gZW1wdHkgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJiBleHBlY3RlZFtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1zZywga2V5cywgZm4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEd1YXJkIGluc3RhbmNlb2YgYWdhaW5zdCBhcnJvdyBmdW5jdGlvbnMgYXMgdGhleSBkb24ndCBoYXZlIGEgcHJvdG90eXBlLlxuXG5cbiAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0dWFsKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgJ0Z1bmN0aW9uJywgZm4pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzUHJvbWlzZShvYmopIHtcbiAgLy8gQWNjZXB0IG5hdGl2ZSBFUzYgcHJvbWlzZXMgYW5kIHByb21pc2VzIHRoYXQgYXJlIGltcGxlbWVudGVkIGluIGEgc2ltaWxhclxuICAvLyB3YXkuIERvIG5vdCBhY2NlcHQgdGhlbmFibGVzIHRoYXQgdXNlIGEgZnVuY3Rpb24gYXMgYG9iamAgYW5kIHRoYXQgaGF2ZSBub1xuICAvLyBgY2F0Y2hgIGhhbmRsZXIuXG4gIC8vIFRPRE86IHRoZW5hYmxlcyBhcmUgY2hlY2tlZCB1cCB1bnRpbCB0aGV5IGhhdmUgdGhlIGNvcnJlY3QgbWV0aG9kcyxcbiAgLy8gYnV0IGFjY29yZGluZyB0byBkb2N1bWVudGF0aW9uLCB0aGUgYHRoZW5gIG1ldGhvZCBzaG91bGQgcmVjZWl2ZVxuICAvLyB0aGUgYGZ1bGZpbGxgIGFuZCBgcmVqZWN0YCBhcmd1bWVudHMgYXMgd2VsbCBvciBpdCBtYXkgYmUgbmV2ZXIgcmVzb2x2ZWQuXG4gIHJldHVybiBpc1Byb21pc2Uob2JqKSB8fCBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHRQcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9taXNlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFJldHVybiBhIHJlamVjdGVkIHByb21pc2UgaWYgYHByb21pc2VGbmAgdGhyb3dzIHN5bmNocm9ub3VzbHkuXG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuKCk7IC8vIEZhaWwgaW4gY2FzZSBubyBwcm9taXNlIGlzIHJldHVybmVkLlxuXG4gICAgICBpZiAoIWNoZWNrSXNQcm9taXNlKHJlc3VsdFByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ2luc3RhbmNlIG9mIFByb21pc2UnLCAncHJvbWlzZUZuJywgcmVzdWx0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGVja0lzUHJvbWlzZShwcm9taXNlRm4pKSB7XG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3Byb21pc2VGbicsIFsnRnVuY3Rpb24nLCAnUHJvbWlzZSddLCBwcm9taXNlRm4pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBleHBlY3RzRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGFjdHVhbC5tZXNzYWdlID09PSBlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChhY3R1YWwubWVzc2FnZSwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBcXFwiXCIuY29uY2F0KGFjdHVhbCwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsICYmIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgfVxuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkge1xuICAgIHZhciBkZXRhaWxzID0gJyc7XG5cbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSkge1xuICAgICAgZGV0YWlscyArPSBcIiAoXCIuY29uY2F0KGVycm9yLm5hbWUsIFwiKVwiKTtcbiAgICB9XG5cbiAgICBkZXRhaWxzICs9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ3JlamVjdHMnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZWN0ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChlcnJvciAmJiAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvciwgbWVzc2FnZSwgc3RhY2tTdGFydEZuKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RzTm9FcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWVycm9yIHx8IGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdmFyIGRldGFpbHMgPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdkb2VzTm90UmVqZWN0JyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJHb3QgdW53YW50ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMsIFwiXFxuXCIpICsgXCJBY3R1YWwgbWVzc2FnZTogXFxcIlwiLmNvbmNhdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIlwiKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICB0aHJvdyBhY3R1YWw7XG59XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiB0aHJvd3MocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFt0aHJvd3MsIGdldEFjdHVhbChwcm9taXNlRm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LnJlamVjdHMgPSBmdW5jdGlvbiByZWplY3RzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbcmVqZWN0cywgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiBkb2VzTm90VGhyb3coZm4pIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFRocm93LCBnZXRBY3R1YWwoZm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBmdW5jdGlvbiBkb2VzTm90UmVqZWN0KGZuKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKGZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFJlamVjdCwgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgaWYgKGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ2lmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJztcblxuICAgIGlmIChfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5sZW5ndGggPT09IDAgJiYgZXJyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IGluc3BlY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3RXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogZXJyLFxuICAgICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgICBvcGVyYXRvcjogJ2lmRXJyb3InLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogaWZFcnJvclxuICAgIH0pOyAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHN0YWNrIHRyYWNlIVxuXG4gICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFjaztcblxuICAgIGlmICh0eXBlb2Ygb3JpZ1N0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlbW92ZSBhbnkgZHVwbGljYXRlZCBmcmFtZXMgZnJvbSB0aGUgZXJyb3IgZnJhbWVzIHRha2VuXG4gICAgICAvLyBmcm9tIHdpdGhpbiBgaWZFcnJvcmAgYW5kIGFkZCB0aGUgb3JpZ2luYWwgZXJyb3IgZnJhbWVzIHRvIHRoZSBuZXdseVxuICAgICAgLy8gY3JlYXRlZCBvbmVzLlxuICAgICAgdmFyIHRtcDIgPSBvcmlnU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdG1wMi5zaGlmdCgpOyAvLyBGaWx0ZXIgYWxsIGZyYW1lcyBleGlzdGluZyBpbiBlcnIuc3RhY2suXG5cbiAgICAgIHZhciB0bXAxID0gbmV3RXJyLnN0YWNrLnNwbGl0KCdcXG4nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGZyYW1lLlxuICAgICAgICB2YXIgcG9zID0gdG1wMS5pbmRleE9mKHRtcDJbaV0pO1xuXG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgLy8gT25seSBrZWVwIG5ldyBmcmFtZXMuXG4gICAgICAgICAgdG1wMSA9IHRtcDEuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdFcnIuc3RhY2sgPSBcIlwiLmNvbmNhdCh0bXAxLmpvaW4oJ1xcbicpLCBcIlxcblwiKS5jb25jYXQodG1wMi5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3RXJyO1xuICB9XG59OyAvLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuXG5cbmZ1bmN0aW9uIHN0cmljdCgpIHtcbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtzdHJpY3QsIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMDgxNzg0MGY3NzUwMzIxNjlkZGQ3MGM4NWFjMDU5ZjE4ZmZjYzgxY1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgndXRpbC8nKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Vycm9ycy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8zYjA0NDk2MmM0OGZlMzEzOTA1ODc3YTk2YjVkMDg5NGE1NDA0ZjZmXG5cbi8qIGVzbGludCBub2RlLWNvcmUvZG9jdW1lbnRlZC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2FscGhhYmV0aXplLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvcHJlZmVyLXV0aWwtZm9ybWF0LWVycm9yczogXCJlcnJvclwiICovXG4ndXNlIHN0cmljdCc7IC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XG4gIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsIFwiJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdcIik7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihhY3R1YWwpKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnaXMgaW52YWxpZCc7XG4gIGlmICh1dGlsID09PSB1bmRlZmluZWQpIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuICB2YXIgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcblxuICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDEyOCkge1xuICAgIGluc3BlY3RlZCA9IFwiXCIuY29uY2F0KGluc3BlY3RlZC5zbGljZSgwLCAxMjgpLCBcIi4uLlwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlRoZSBhcmd1bWVudCAnXCIuY29uY2F0KG5hbWUsIFwiJyBcIikuY29uY2F0KHJlYXNvbiwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQoaW5zcGVjdGVkKTtcbn0sIFR5cGVFcnJvciwgUmFuZ2VFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRScsIGZ1bmN0aW9uIChpbnB1dCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR5cGU7XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICB0eXBlID0gXCJpbnN0YW5jZSBvZiBcIi5jb25jYXQodmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IFwidHlwZSBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGlucHV0LCBcIiB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcXFwiXCIpLmNvbmNhdChuYW1lLCBcIlxcXCJcIikgKyBcIiBmdW5jdGlvbiBidXQgZ290IFwiLmNvbmNhdCh0eXBlLCBcIi5cIik7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUlTU0lOR19BUkdTJywgZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcbiAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIHZhciBtc2cgPSAnVGhlICc7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChhLCBcIlxcXCJcIik7XG4gIH0pO1xuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFyZ3VtZW50XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYW5kIFwiKS5jb25jYXQoYXJnc1sxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKTtcbiAgICAgIG1zZyArPSBcIiwgYW5kIFwiLmNvbmNhdChhcmdzW2xlbiAtIDFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2csIFwiIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xufSwgVHlwZUVycm9yKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciByZWdleEZsYWdzU3VwcG9ydGVkID0gL2EvZy5mbGFncyAhPT0gdW5kZWZpbmVkO1xuXG52YXIgYXJyYXlGcm9tU2V0ID0gZnVuY3Rpb24gYXJyYXlGcm9tU2V0KHNldCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2godmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5RnJvbU1hcCA9IGZ1bmN0aW9uIGFycmF5RnJvbU1hcChtYXApIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IHJlcXVpcmUoJ29iamVjdC1pcycpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogcmVxdWlyZSgnaXMtbmFuJyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIG9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IHJlcXVpcmUoJ3V0aWwvJykudHlwZXMsXG4gICAgaXNBbnlBcnJheUJ1ZmZlciA9IF9yZXF1aXJlJHR5cGVzLmlzQW55QXJyYXlCdWZmZXIsXG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBfcmVxdWlyZSR0eXBlcy5pc0FycmF5QnVmZmVyVmlldyxcbiAgICBpc0RhdGUgPSBfcmVxdWlyZSR0eXBlcy5pc0RhdGUsXG4gICAgaXNNYXAgPSBfcmVxdWlyZSR0eXBlcy5pc01hcCxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwLFxuICAgIGlzU2V0ID0gX3JlcXVpcmUkdHlwZXMuaXNTZXQsXG4gICAgaXNOYXRpdmVFcnJvciA9IF9yZXF1aXJlJHR5cGVzLmlzTmF0aXZlRXJyb3IsXG4gICAgaXNCb3hlZFByaW1pdGl2ZSA9IF9yZXF1aXJlJHR5cGVzLmlzQm94ZWRQcmltaXRpdmUsXG4gICAgaXNOdW1iZXJPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc051bWJlck9iamVjdCxcbiAgICBpc1N0cmluZ09iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3RyaW5nT2JqZWN0LFxuICAgIGlzQm9vbGVhbk9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQm9vbGVhbk9iamVjdCxcbiAgICBpc0JpZ0ludE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQmlnSW50T2JqZWN0LFxuICAgIGlzU3ltYm9sT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTeW1ib2xPYmplY3QsXG4gICAgaXNGbG9hdDMyQXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0MzJBcnJheSxcbiAgICBpc0Zsb2F0NjRBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xuICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCB8fCBrZXkubGVuZ3RoID4gMTApIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1NykgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhlIG1heGltdW0gc2l6ZSBmb3IgYW4gYXJyYXkgaXMgMiAqKiAzMiAtMS5cblxuXG4gIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoaXNOb25JbmRleCkuY29uY2F0KG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkuZmlsdGVyKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYmluZCh2YWx1ZSkpKTtcbn0gLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxudmFyIE9OTFlfRU5VTUVSQUJMRSA9IHVuZGVmaW5lZDtcbnZhciBrU3RyaWN0ID0gdHJ1ZTtcbnZhciBrTG9vc2UgPSBmYWxzZTtcbnZhciBrTm9JdGVyYXRvciA9IDA7XG52YXIga0lzQXJyYXkgPSAxO1xudmFyIGtJc1NldCA9IDI7XG52YXIga0lzTWFwID0gMzsgLy8gQ2hlY2sgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHNvdXJjZSBhbmQgZmxhZ3NcblxuZnVuY3Rpb24gYXJlU2ltaWxhclJlZ0V4cHMoYSwgYikge1xuICByZXR1cm4gcmVnZXhGbGFnc1N1cHBvcnRlZCA/IGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzIDogUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJGbG9hdEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGEuYnl0ZUxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICBpZiAoYVtvZmZzZXRdICE9PSBiW29mZnNldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKSwgbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlCdWZmZXJzKGJ1ZjEsIGJ1ZjIpIHtcbiAgcmV0dXJuIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpIHtcbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbDIpICYmIG9iamVjdElzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpLCBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmdPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdPYmplY3QodmFsMikgJiYgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW5PYmplY3QodmFsMikgJiYgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCaWdJbnRPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCaWdJbnRPYmplY3QodmFsMikgJiYgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbDIpICYmIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbn0gLy8gTm90ZXM6IFR5cGUgdGFncyBhcmUgaGlzdG9yaWNhbCBbW0NsYXNzXV0gcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgYnlcbi8vIEZ1bmN0aW9uVGVtcGxhdGU6OlNldENsYXNzTmFtZSgpIGluIEMrKyBvciBTeW1ib2wudG9TdHJpbmdUYWcgaW4gSlNcbi8vIGFuZCByZXRyaWV2ZWQgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgaW4gSlNcbi8vIFNlZSBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG4vLyBmb3IgYSBsaXN0IG9mIHRhZ3MgcHJlLWRlZmluZWQgaW4gdGhlIHNwZWMuXG4vLyBUaGVyZSBhcmUgc29tZSB1bnNwZWNpZmllZCB0YWdzIGluIHRoZSB3aWxkIHRvbyAoZS5nLiB0eXBlZCBhcnJheSB0YWdzKS5cbi8vIFNpbmNlIHRhZ3MgY2FuIGJlIGFsdGVyZWQsIHRoZXkgb25seSBzZXJ2ZSBmYXN0IGZhaWx1cmVzXG4vL1xuLy8gVHlwZWQgYXJyYXlzIGFuZCBidWZmZXJzIGFyZSBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGUgY29udGVudCBpbiB0aGVpclxuLy8gdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhhdCBpdCdzXG4vLyByZWFzb25hYmxlIHRvIGludGVycHJldCB0aGVpciB1bmRlcmx5aW5nIG1lbW9yeSBpbiB0aGUgc2FtZSB3YXksXG4vLyB3aGljaCBpcyBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGVpciB0eXBlIHRhZ3MuXG4vLyAoZS5nLiBhIFVpbnQ4QXJyYXkgYW5kIGEgVWludDE2QXJyYXkgd2l0aCB0aGUgc2FtZSBtZW1vcnkgY29udGVudFxuLy8gY291bGQgc3RpbGwgYmUgZGlmZmVyZW50IGJlY2F1c2UgdGhleSB3aWxsIGJlIGludGVycHJldGVkIGRpZmZlcmVudGx5KS5cbi8vXG4vLyBGb3Igc3RyaWN0IGNvbXBhcmlzb24sIG9iamVjdHMgc2hvdWxkIGhhdmVcbi8vIGEpIFRoZSBzYW1lIGJ1aWx0LWluIHR5cGUgdGFnc1xuLy8gYikgVGhlIHNhbWUgcHJvdG90eXBlcy5cblxuXG5mdW5jdGlvbiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKHZhbDEgPT09IHZhbDIpIHtcbiAgICBpZiAodmFsMSAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZTtcbiAgfSAvLyBDaGVjayBtb3JlIGNsb3NlbHkgaWYgdmFsMSBhbmQgdmFsMiBhcmUgZXF1YWwuXG5cblxuICBpZiAoc3RyaWN0KSB7XG4gICAgaWYgKF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmIG51bWJlcklzTmFOKHZhbDEpICYmIG51bWJlcklzTmFOKHZhbDIpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0JyB8fCB2YWwxID09PSBudWxsIHx8IHZhbDIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbDEgPT09IG51bGwgfHwgX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgcmV0dXJuIHZhbDEgPT0gdmFsMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbDFUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwxKTtcbiAgdmFyIHZhbDJUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwyKTtcblxuICBpZiAodmFsMVRhZyAhPT0gdmFsMlRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHNwYXJzZSBhcnJheXMgYW5kIGdlbmVyYWwgZmFzdCBwYXRoXG4gICAgaWYgKHZhbDEubGVuZ3RoICE9PSB2YWwyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZXlzMSA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIHZhciBrZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc0FycmF5LCBrZXlzMSk7XG4gIH0gLy8gW2Jyb3dzZXJpZnldIFRoaXMgdHJpZ2dlcnMgb24gY2VydGFpbiB0eXBlcyBpbiBJRSAoTWFwL1NldCkgc28gd2UgZG9uJ3RcbiAgLy8gd2FuJ3QgdG8gZWFybHkgcmV0dXJuIG91dCBvZiB0aGUgcmVzdCBvZiB0aGUgY2hlY2tzLiBIb3dldmVyIHdlIGNhbiBjaGVja1xuICAvLyBpZiB0aGUgc2Vjb25kIHZhbHVlIGlzIG9uZSBvZiB0aGVzZSB2YWx1ZXMgYW5kIHRoZSBmaXJzdCBpc24ndC5cblxuXG4gIGlmICh2YWwxVGFnID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIC8vIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG4gICAgaWYgKCFpc01hcCh2YWwxKSAmJiBpc01hcCh2YWwyKSB8fCAhaXNTZXQodmFsMSkgJiYgaXNTZXQodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEYXRlKHZhbDEpKSB7XG4gICAgaWYgKCFpc0RhdGUodmFsMikgfHwgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDEpICE9PSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsMSkpIHtcbiAgICBpZiAoIWlzUmVnRXhwKHZhbDIpIHx8ICFhcmVTaW1pbGFyUmVnRXhwcyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05hdGl2ZUVycm9yKHZhbDEpIHx8IHZhbDEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIERvIG5vdCBjb21wYXJlIHRoZSBzdGFjayBhcyBpdCBtaWdodCBkaWZmZXIgZXZlbiB0aG91Z2ggdGhlIGVycm9yIGl0c2VsZlxuICAgIC8vIGlzIG90aGVyd2lzZSBpZGVudGljYWwuXG4gICAgaWYgKHZhbDEubWVzc2FnZSAhPT0gdmFsMi5tZXNzYWdlIHx8IHZhbDEubmFtZSAhPT0gdmFsMi5uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHZhbDEpKSB7XG4gICAgaWYgKCFzdHJpY3QgJiYgKGlzRmxvYXQzMkFycmF5KHZhbDEpIHx8IGlzRmxvYXQ2NEFycmF5KHZhbDEpKSkge1xuICAgICAgaWYgKCFhcmVTaW1pbGFyRmxvYXRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFyZVNpbWlsYXJUeXBlZEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQnVmZmVyLmNvbXBhcmUgcmV0dXJucyB0cnVlLCBzbyB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGguIElmIHRoZXkgYm90aFxuICAgIC8vIG9ubHkgY29udGFpbiBudW1lcmljIGtleXMsIHdlIGRvbid0IG5lZWQgdG8gZXhhbSBmdXJ0aGVyIHRoYW4gY2hlY2tpbmdcbiAgICAvLyB0aGUgc3ltYm9scy5cblxuXG4gICAgdmFyIF9rZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICB2YXIgX2tleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoX2tleXMubGVuZ3RoICE9PSBfa2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yLCBfa2V5cyk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcbiAgICBpZiAoIWlzU2V0KHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc1NldCk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcbiAgICBpZiAoIWlzTWFwKHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc01hcCk7XG4gIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWwxKSkge1xuICAgIGlmICghYXJlRXF1YWxBcnJheUJ1ZmZlcnModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCb3hlZFByaW1pdGl2ZSh2YWwxKSAmJiAhaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZXModmFsLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwsIGspO1xuICB9KTtcbn1cblxuZnVuY3Rpb24ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywgaXRlcmF0aW9uVHlwZSwgYUtleXMpIHtcbiAgLy8gRm9yIGFsbCByZW1haW5pbmcgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXksIG9iamVjdHMgYW5kIE1hcHMsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgaGF2aW5nOlxuICAvLyBhKSBUaGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gIC8vIGIpIFRoZSBzYW1lIHNldCBvZiBrZXlzL2luZGV4ZXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlcilcbiAgLy8gYykgRXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5L2luZGV4XG4gIC8vIGQpIEZvciBTZXRzIGFuZCBNYXBzLCBlcXVhbCBjb250ZW50c1xuICAvLyBOb3RlOiB0aGlzIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIGFLZXlzID0gT2JqZWN0LmtleXModmFsMSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXModmFsMik7IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBDaGVhcCBrZXkgdGVzdFxuXG5cbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbDIsIGFLZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJpY3QgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHZhciBzeW1ib2xLZXlzQSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwxKTtcblxuICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzeW1ib2xLZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gc3ltYm9sS2V5c0FbaV07XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDEsIGtleSkpIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gc3ltYm9sS2V5c0IubGVuZ3RoICYmIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKF9zeW1ib2xLZXlzQi5sZW5ndGggIT09IDAgJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgX3N5bWJvbEtleXNCKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhS2V5cy5sZW5ndGggPT09IDAgJiYgKGl0ZXJhdGlvblR5cGUgPT09IGtOb0l0ZXJhdG9yIHx8IGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5ICYmIHZhbDEubGVuZ3RoID09PSAwIHx8IHZhbDEuc2l6ZSA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBVc2UgbWVtb3MgdG8gaGFuZGxlIGN5Y2xlcy5cblxuXG4gIGlmIChtZW1vcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVtb3MgPSB7XG4gICAgICB2YWwxOiBuZXcgTWFwKCksXG4gICAgICB2YWwyOiBuZXcgTWFwKCksXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgcHJldmVudCB1cCB0byB0d28gbWFwLmhhcyh4KSBjYWxscyBieSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZVxuICAgIC8vIGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkLiBUaGUgbWFwIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgc28gaXQgaXNcbiAgICAvLyBzYWZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb25seS5cbiAgICB2YXIgdmFsMk1lbW9BID0gbWVtb3MudmFsMS5nZXQodmFsMSk7XG5cbiAgICBpZiAodmFsMk1lbW9BICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB2YWwyTWVtb0IgPSBtZW1vcy52YWwyLmdldCh2YWwyKTtcblxuICAgICAgaWYgKHZhbDJNZW1vQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5wb3NpdGlvbisrO1xuICB9XG5cbiAgbWVtb3MudmFsMS5zZXQodmFsMSwgbWVtb3MucG9zaXRpb24pO1xuICBtZW1vcy52YWwyLnNldCh2YWwyLCBtZW1vcy5wb3NpdGlvbik7XG4gIHZhciBhcmVFcSA9IG9iakVxdWl2KHZhbDEsIHZhbDIsIHN0cmljdCwgYUtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKTtcbiAgbWVtb3MudmFsMS5kZWxldGUodmFsMSk7XG4gIG1lbW9zLnZhbDIuZGVsZXRlKHZhbDIpO1xuICByZXR1cm4gYXJlRXE7XG59XG5cbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIHN0cmljdCwgbWVtbykge1xuICAvLyBHbyBsb29raW5nLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsMiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgc2V0LmRlbGV0ZSh2YWwyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXG4vLyBTYWRseSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGNvcnJlc3BvbmRpbmcgdmFsdWVzIHByb3Blcmx5IGluIGNhc2UgdGhlXG4vLyB0eXBlIGlzIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCBvciBib29sZWFuLiBUaGUgcmVhc29uIGlzIHRoYXQgdGhvc2UgdmFsdWVzXG4vLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxuXG5cbmZ1bmN0aW9uIGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKSB7XG4gIHN3aXRjaCAoX3R5cGVvZihwcmltKSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBwcmltID0gK3ByaW07XG4gICAgLy8gTG9vc2UgZXF1YWwgZW50cmllcyBleGlzdCBvbmx5IGlmIHRoZSBzdHJpbmcgaXMgcG9zc2libGUgdG8gY29udmVydCB0b1xuICAgIC8vIGEgcmVndWxhciBudW1iZXIgYW5kIG5vdCBOYU4uXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlcklzTmFOKHByaW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZTtcbiAgcmV0dXJuIGIuaGFzKGFsdFZhbHVlKSAmJiAhYS5oYXMoYWx0VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSwgaXRlbSwgbWVtbykge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG5cbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gYWx0VmFsdWU7XG4gIH1cblxuICB2YXIgY3VyQiA9IGIuZ2V0KGFsdFZhbHVlKTtcblxuICBpZiAoY3VyQiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhhbHRWYWx1ZSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhYS5oYXMoYWx0VmFsdWUpICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKTtcbn1cblxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRoaXMgaXMgYSBsYXppbHkgaW5pdGlhdGVkIFNldCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdG8gYmUgY29tcGFyZWRcbiAgLy8gcGFpcndpc2UuXG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYVZhbHVlc1tpXTsgLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XG4gICAgLy8gaGVhdnkgc2V0cyBidXQgaXQgaXMgYSBtaW5vciBzbG93IGRvd24gZm9yIHByaW1pdGl2ZXMuIEFzIHRoZXkgYXJlIGZhc3RcbiAgICAvLyB0byBjaGVjayB0aGlzIGltcHJvdmVzIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGluc3RlYWQuXG5cbiAgICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfSAvLyBJZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlY29uZCBzZXQgaXRzIGFuIG5vdCBudWxsXG4gICAgICAvLyBvYmplY3QgKG9yIG5vbiBzdHJpY3Qgb25seTogYSBub3QgbWF0Y2hpbmcgcHJpbWl0aXZlKSB3ZSdsbCBuZWVkIHRvIGdvXG4gICAgICAvLyBodW50aW5nIGZvciBzb21ldGhpbmcgdGhhdHMgZGVlcC0oc3RyaWN0LSllcXVhbCB0byBpdC4gVG8gbWFrZSB0aGlzXG4gICAgICAvLyBPKG4gbG9nIG4pIGNvbXBsZXhpdHkgd2UgaGF2ZSB0byBjb3B5IHRoZXNlIHZhbHVlcyBpbiBhIG5ldyBzZXQgZmlyc3QuXG5cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoIWIuaGFzKHZhbCkpIHtcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzLlxuXG4gICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJWYWx1ZXMgPSBhcnJheUZyb21TZXQoYik7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYlZhbHVlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfdmFsID0gYlZhbHVlc1tfaV07IC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxuICAgICAgLy8gbWF0Y2hpbmcgYW5kIG9ubHkgaWYgaXQncyBub3QsIGdvIGh1bnRpbmcgZm9yIGl0LlxuXG4gICAgICBpZiAoX3R5cGVvZihfdmFsKSA9PT0gJ29iamVjdCcgJiYgX3ZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAhYS5oYXMoX3ZhbCkgJiYgIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRvIGJlIGFibGUgdG8gaGFuZGxlIGNhc2VzIGxpa2U6XG4gIC8vICAgTWFwKFtbe30sICdhJ10sIFt7fSwgJ2InXV0pIHZzIE1hcChbW3t9LCAnYiddLCBbe30sICdhJ11dKVxuICAvLyAuLi4gd2UgbmVlZCB0byBjb25zaWRlciAqYWxsKiBtYXRjaGluZyBrZXlzLCBub3QganVzdCB0aGUgZmlyc3Qgd2UgZmluZC5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleTIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwoa2V5MSwga2V5Miwgc3RyaWN0LCBtZW1vKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtMSwgbWFwLmdldChrZXkyKSwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgc2V0LmRlbGV0ZShrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYUVudHJpZXMgPSBhcnJheUZyb21NYXAoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcbiAgICAgICAga2V5ID0gX2FFbnRyaWVzJGlbMF0sXG4gICAgICAgIGl0ZW0xID0gX2FFbnRyaWVzJGlbMV07XG5cbiAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlIHdlIHByZXZlbnQgYW5vdGhlciBiLmhhcyhrZXkpIGNoZWNrIGluXG4gICAgICAvLyBhbG1vc3QgYWxsIHBvc3NpYmxlIGNhc2VzLlxuICAgICAgdmFyIGl0ZW0yID0gYi5nZXQoa2V5KTtcblxuICAgICAgaWYgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgICAgIC8vIGtleXMuXG5cbiAgICAgICAgaWYgKCFtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwga2V5LCBpdGVtMSwgbWVtbykpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYkVudHJpZXMgPSBhcnJheUZyb21NYXAoYik7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBiRW50cmllcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2JFbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoYkVudHJpZXNbX2kyXSwgMiksXG4gICAgICAgICAga2V5ID0gX2JFbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIGl0ZW0gPSBfYkVudHJpZXMkX2lbMV07XG5cbiAgICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAoIWEuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGEuZ2V0KGtleSksIGl0ZW0sIGZhbHNlLCBtZW1vKSkgJiYgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIGZhbHNlLCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwga2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpIHtcbiAgLy8gU2V0cyBhbmQgbWFwcyBkb24ndCBoYXZlIHRoZWlyIGVudHJpZXMgYWNjZXNzaWJsZSB2aWEgbm9ybWFsIG9iamVjdFxuICAvLyBwcm9wZXJ0aWVzLlxuICB2YXIgaSA9IDA7XG5cbiAgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc1NldCkge1xuICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzTWFwKSB7XG4gICAgaWYgKCFtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSkge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwgaSkgfHwgIWlubmVyRGVlcEVxdWFsKGFbaV0sIGJbaV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGIsIGkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFycmF5IGlzIHNwYXJzZS5cbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzQVtpXTtcblxuICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwga2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkuXG4gIC8vIFBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Q6XG5cblxuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfa2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICghaW5uZXJEZWVwRXF1YWwoYVtfa2V5XSwgYltfa2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga0xvb3NlKTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwU3RyaWN0RXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga1N0cmljdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0RlZXBFcXVhbDogaXNEZWVwRXF1YWwsXG4gIGlzRGVlcFN0cmljdEVxdWFsOiBpc0RlZXBTdHJpY3RFcXVhbFxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCIvKmdsb2JhbCB3aW5kb3csIGdsb2JhbCovXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKVxuZnVuY3Rpb24gbm93KCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgfVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbnZhciBjb25zb2xlXG52YXIgdGltZXMgPSB7fVxuXG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZVxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlXG59IGVsc2Uge1xuICAgIGNvbnNvbGUgPSB7fVxufVxuXG52YXIgZnVuY3Rpb25zID0gW1xuICAgIFtsb2csIFwibG9nXCJdLFxuICAgIFtpbmZvLCBcImluZm9cIl0sXG4gICAgW3dhcm4sIFwid2FyblwiXSxcbiAgICBbZXJyb3IsIFwiZXJyb3JcIl0sXG4gICAgW3RpbWUsIFwidGltZVwiXSxcbiAgICBbdGltZUVuZCwgXCJ0aW1lRW5kXCJdLFxuICAgIFt0cmFjZSwgXCJ0cmFjZVwiXSxcbiAgICBbZGlyLCBcImRpclwiXSxcbiAgICBbY29uc29sZUFzc2VydCwgXCJhc3NlcnRcIl1cbl1cblxuZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBmdW5jdGlvbnNbaV1cbiAgICB2YXIgZiA9IHR1cGxlWzBdXG4gICAgdmFyIG5hbWUgPSB0dXBsZVsxXVxuXG4gICAgaWYgKCFjb25zb2xlW25hbWVdKSB7XG4gICAgICAgIGNvbnNvbGVbbmFtZV0gPSBmXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVcblxuZnVuY3Rpb24gbG9nKCkge31cblxuZnVuY3Rpb24gaW5mbygpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB0aW1lKGxhYmVsKSB7XG4gICAgdGltZXNbbGFiZWxdID0gbm93KClcbn1cblxuZnVuY3Rpb24gdGltZUVuZChsYWJlbCkge1xuICAgIHZhciB0aW1lID0gdGltZXNbbGFiZWxdXG4gICAgaWYgKCF0aW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggbGFiZWw6IFwiICsgbGFiZWwpXG4gICAgfVxuXG4gICAgZGVsZXRlIHRpbWVzW2xhYmVsXVxuICAgIHZhciBkdXJhdGlvbiA9IG5vdygpIC0gdGltZVxuICAgIGNvbnNvbGUubG9nKGxhYmVsICsgXCI6IFwiICsgZHVyYXRpb24gKyBcIm1zXCIpXG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKVxuICAgIGVyci5uYW1lID0gXCJUcmFjZVwiXG4gICAgZXJyLm1lc3NhZ2UgPSB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spXG59XG5cbmZ1bmN0aW9uIGRpcihvYmplY3QpIHtcbiAgICBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qob2JqZWN0KSArIFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIGNvbnNvbGVBc3NlcnQoZXhwcmVzc2lvbikge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgYXJyID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAgIGFzc2VydC5vayhmYWxzZSwgdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJyKSlcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sKCdmb28nKSA9PT0gJ3N5bWJvbCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBvcmlnRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG5cdHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgdG9TdHIuY2FsbChmbikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IHJlcXVpcmUoJ2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpKCk7XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gb3JpZ0RlZmluZVByb3BlcnR5ICYmIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0aWYgKHByZWRpY2F0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0aWYgKG9iamVjdFtuYW1lXSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuXHR9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcbiIsIi8qKlxuICogQ29kZSByZWZhY3RvcmVkIGZyb20gTW96aWxsYSBEZXZlbG9wZXIgTmV0d29yazpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIGZpcnN0U291cmNlKSB7XG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBmaXJzdCBhcmd1bWVudCB0byBvYmplY3QnKTtcbiAgfVxuXG4gIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChuZXh0U291cmNlID09PSB1bmRlZmluZWQgfHwgbmV4dFNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGtleXNBcnJheSA9IE9iamVjdC5rZXlzKE9iamVjdChuZXh0U291cmNlKSk7XG4gICAgZm9yICh2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXgrKykge1xuICAgICAgdmFyIG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XTtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdCwgJ2Fzc2lnbicsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogYXNzaWduXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzc2lnbjogYXNzaWduLFxuICBwb2x5ZmlsbDogcG9seWZpbGxcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJpZ0ludDY0QXJyYXklJzogdHlwZW9mIEJpZ0ludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50NjRBcnJheSxcblx0JyVCaWdVaW50NjRBcnJheSUnOiB0eXBlb2YgQmlnVWludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnVWludDY0QXJyYXksXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG50cnkge1xuXHRudWxsLmVycm9yOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xufSBjYXRjaCAoZSkge1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHR2YXIgZXJyb3JQcm90byA9IGdldFByb3RvKGdldFByb3RvKGUpKTtcblx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG52YXIgJGV4ZWMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kLywgbmFtZSkgPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdgJWAgbWF5IG5vdCBiZSBwcmVzZW50IGFueXdoZXJlIGJ1dCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGludHJpbnNpYyBuYW1lJyk7XG5cdH1cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5cbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHRyeSB7XG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbmhhc1Byb3BlcnR5RGVzY3JpcHRvcnMuaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcgPSBmdW5jdGlvbiBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZygpIHtcblx0Ly8gbm9kZSB2MC42IGhhcyBhIGJ1ZyB3aGVyZSBhcnJheSBsZW5ndGhzIGNhbiBiZSBTZXQgYnV0IG5vdCBEZWZpbmVkXG5cdGlmICghaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gJGRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB2YWx1ZTogMSB9KS5sZW5ndGggIT09IDE7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJbiBGaXJlZm94IDQtMjIsIGRlZmluaW5nIGxlbmd0aCBvbiBhbiBhcnJheSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBjYW5Vc2VET00gPSAhIShcbiAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICB3aW5kb3cuZG9jdW1lbnQgJiZcbiAgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbik7XG5cbmV4cG9ydCBkZWZhdWx0IGNhblVzZURPTTtcbiIsImltcG9ydCB7a2V5c30gZnJvbSBcIi4va2V5Y29kZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdF9tYXhUZXN0UG9zOiA1MDAsXG5cdHBsYWNlaG9sZGVyOiBcIl9cIixcblx0b3B0aW9uYWxtYXJrZXI6IFtcIltcIiwgXCJdXCJdLFxuXHRxdWFudGlmaWVybWFya2VyOiBbXCJ7XCIsIFwifVwiXSxcblx0Z3JvdXBtYXJrZXI6IFtcIihcIiwgXCIpXCJdLFxuXHRhbHRlcm5hdG9ybWFya2VyOiBcInxcIixcblx0ZXNjYXBlQ2hhcjogXCJcXFxcXCIsXG5cdG1hc2s6IG51bGwsIC8vbmVlZHMgdG9iZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkIGFzIHRoZSBleHRlbmQgbWV0aG9kIGRvZXMgbm90IGNvbnNpZGVyIHByb3BzIHdpdGggdGhlIHVuZGVmaW5lZCB2YWx1ZVxuXHRyZWdleDogbnVsbCwgLy9yZWd1bGFyIGV4cHJlc3Npb24gYXMgYSBtYXNrXG5cdG9uY29tcGxldGU6ICgpID0+IHtcblx0fSwgLy9leGVjdXRlcyB3aGVuIHRoZSBtYXNrIGlzIGNvbXBsZXRlXG5cdG9uaW5jb21wbGV0ZTogKCkgPT4ge1xuXHR9LCAvL2V4ZWN1dGVzIHdoZW4gdGhlIG1hc2sgaXMgaW5jb21wbGV0ZSBhbmQgZm9jdXMgaXMgbG9zdFxuXHRvbmNsZWFyZWQ6ICgpID0+IHtcblx0fSwgLy9leGVjdXRlcyB3aGVuIHRoZSBtYXNrIGlzIGNsZWFyZWRcblx0cmVwZWF0OiAwLCAvL3JlcGV0aXRpb25zIG9mIHRoZSBtYXNrOiAqIH4gZm9yZXZlciwgb3RoZXJ3aXNlIHNwZWNpZnkgYW4gaW50ZWdlclxuXHRncmVlZHk6IGZhbHNlLCAvL3RydWU6IGFsbG9jYXRlZCBidWZmZXIgZm9yIHRoZSBtYXNrIGFuZCByZXBldGl0aW9ucyAtIGZhbHNlOiBhbGxvY2F0ZSBvbmx5IGlmIG5lZWRlZFxuXHRhdXRvVW5tYXNrOiBmYWxzZSwgLy9hdXRvbWF0aWNhbGx5IHVubWFzayB3aGVuIHJldHJpZXZpbmcgdGhlIHZhbHVlIHdpdGggJC5mbi52YWwgb3IgdmFsdWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgX19sb29rdXBHZXR0ZXJfXyBvciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcblx0cmVtb3ZlTWFza09uU3VibWl0OiBmYWxzZSwgLy9yZW1vdmUgdGhlIG1hc2sgYmVmb3JlIHN1Ym1pdHRpbmcgdGhlIGZvcm0uXG5cdGNsZWFyTWFza09uTG9zdEZvY3VzOiB0cnVlLFxuXHRpbnNlcnRNb2RlOiB0cnVlLCAvL2luc2VydCB0aGUgaW5wdXQgb3Igb3ZlcndyaXRlIHRoZSBpbnB1dFxuXHRpbnNlcnRNb2RlVmlzdWFsOiB0cnVlLCAvL3Nob3cgc2VsZWN0ZWQgY2FyZXQgd2hlbiBpbnNlcnRtb2RlID0gZmFsc2Vcblx0Y2xlYXJJbmNvbXBsZXRlOiBmYWxzZSwgLy9jbGVhciB0aGUgaW5jb21wbGV0ZSBpbnB1dCBvbiBibHVyXG5cdGFsaWFzOiBudWxsLFxuXHRvbktleURvd246ICgpID0+IHtcblx0fSwgLy9jYWxsYmFjayB0byBpbXBsZW1lbnQgYXV0b2NvbXBsZXRlIG9uIGNlcnRhaW4ga2V5cyBmb3IgZXhhbXBsZS4gYXJncyA9PiBldmVudCwgYnVmZmVyLCBjYXJldFBvcywgb3B0c1xuXHRvbkJlZm9yZU1hc2s6IG51bGwsIC8vZXhlY3V0ZXMgYmVmb3JlIG1hc2tpbmcgdGhlIGluaXRpYWwgdmFsdWUgdG8gYWxsb3cgcHJlcHJvY2Vzc2luZyBvZiB0aGUgaW5pdGlhbCB2YWx1ZS5cdGFyZ3MgPT4gaW5pdGlhbFZhbHVlLCBvcHRzID0+IHJldHVybiBwcm9jZXNzZWRWYWx1ZVxuXHRvbkJlZm9yZVBhc3RlOiBmdW5jdGlvbiAocGFzdGVkVmFsdWUsIG9wdHMpIHtcblx0XHRyZXR1cm4gdHlwZW9mIG9wdHMub25CZWZvcmVNYXNrID09PSBcImZ1bmN0aW9uXCIgPyBvcHRzLm9uQmVmb3JlTWFzay5jYWxsKHRoaXMsIHBhc3RlZFZhbHVlLCBvcHRzKSA6IHBhc3RlZFZhbHVlO1xuXHR9LCAvL2V4ZWN1dGVzIGJlZm9yZSBtYXNraW5nIHRoZSBwYXN0ZWQgdmFsdWUgdG8gYWxsb3cgcHJlcHJvY2Vzc2luZyBvZiB0aGUgcGFzdGVkIHZhbHVlLlx0YXJncyA9PiBwYXN0ZWRWYWx1ZSwgb3B0cyA9PiByZXR1cm4gcHJvY2Vzc2VkVmFsdWVcblx0b25CZWZvcmVXcml0ZTogbnVsbCwgLy9leGVjdXRlcyBiZWZvcmUgd3JpdGluZyB0byB0aGUgbWFza2VkIGVsZW1lbnQuIGFyZ3MgPT4gZXZlbnQsIG9wdHNcblx0b25Vbk1hc2s6IG51bGwsIC8vZXhlY3V0ZXMgYWZ0ZXIgdW5tYXNraW5nIHRvIGFsbG93IHBvc3Rwcm9jZXNzaW5nIG9mIHRoZSB1bm1hc2tlZHZhbHVlLlx0YXJncyA9PiBtYXNrZWRWYWx1ZSwgdW5tYXNrZWRWYWx1ZSwgb3B0c1xuXHRzaG93TWFza09uRm9jdXM6IHRydWUsIC8vc2hvdyB0aGUgbWFzay1wbGFjZWhvbGRlciB3aGVuIHRoZSBpbnB1dCBoYXMgZm9jdXNcblx0c2hvd01hc2tPbkhvdmVyOiB0cnVlLCAvL3Nob3cgdGhlIG1hc2stcGxhY2Vob2xkZXIgd2hlbiBob3ZlcmluZyB0aGUgZW1wdHkgaW5wdXRcblx0b25LZXlWYWxpZGF0aW9uOiAoKSA9PiB7XG5cdH0sIC8vZXhlY3V0ZXMgb24gZXZlcnkga2V5LXByZXNzIHdpdGggdGhlIHJlc3VsdCBvZiBpc1ZhbGlkLiBQYXJhbXM6IGtleSwgcmVzdWx0LCBvcHRzXG5cdHNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXI6IFwiIFwiLCAvL2EgY2hhcmFjdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHNraXAgYW4gb3B0aW9uYWwgcGFydCBvZiBhIG1hc2tcblx0bnVtZXJpY0lucHV0OiBmYWxzZSwgLy9udW1lcmljSW5wdXQgaW5wdXQgZGlyZWN0aW9uIHN0eWxlIChpbnB1dCBzaGlmdHMgdG8gdGhlIGxlZnQgd2hpbGUgaG9sZGluZyB0aGUgY2FyZXQgcG9zaXRpb24pXG5cdHJpZ2h0QWxpZ246IGZhbHNlLCAvL2FsaWduIHRvIHRoZSByaWdodFxuXHR1bmRvT25Fc2NhcGU6IHRydWUsIC8vcHJlc3NpbmcgZXNjYXBlIHJldmVydHMgdGhlIHZhbHVlIHRvIHRoZSB2YWx1ZSBiZWZvcmUgZm9jdXNcblx0Ly9udW1lcmljIGJhc2ljIHByb3BlcnRpZXNcblx0cmFkaXhQb2ludDogXCJcIiwgLy9cIi5cIiwgLy8gfCBcIixcIlxuXHRfcmFkaXhEYW5jZTogZmFsc2UsIC8vZGFuY2UgYXJvdW5kIHRoZSByYWRpeFBvaW50XG5cdGdyb3VwU2VwYXJhdG9yOiBcIlwiLCAvL1wiLFwiLCAvLyB8IFwiLlwiXG5cdC8vbnVtZXJpYyBiYXNpYyBwcm9wZXJ0aWVzXG5cdGtlZXBTdGF0aWM6IG51bGwsIC8vdHJ5IHRvIGtlZXAgdGhlIG1hc2sgc3RhdGljIHdoaWxlIHR5cGluZy4gRGVjaXNpb25zIHRvIGFsdGVyIHRoZSBtYXNrIHdpbGwgYmUgcG9zcG9uZWQgaWYgcG9zc2libGVcblx0cG9zaXRpb25DYXJldE9uVGFiOiB0cnVlLCAvL3doZW4gZW5hYmxlZCB0aGUgY2FyZXQgcG9zaXRpb24gaXMgc2V0IGFmdGVyIHRoZSBsYXRlc3QgdmFsaWQgcG9zaXRpb24gb24gVEFCXG5cdHRhYlRocm91Z2g6IGZhbHNlLCAvL2FsbG93cyBmb3IgdGFiYmluZyB0aHJvdWdoIHRoZSBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIG1hc2tlZCBmaWVsZFxuXHRzdXBwb3J0c0lucHV0VHlwZTogW1widGV4dFwiLCBcInRlbFwiLCBcInVybFwiLCBcInBhc3N3b3JkXCIsIFwic2VhcmNoXCJdLCAvL2xpc3Qgd2l0aCB0aGUgc3VwcG9ydGVkIGlucHV0IHR5cGVzXG5cdC8vc3BlY2lmeSBrZXlDb2RlcyB3aGljaCBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgaW4gdGhlIGtleXByZXNzIGV2ZW50LCBvdGhlcndpc2UgdGhlIHByZXZlbnREZWZhdWx0IHdpbGwgc3RvcCB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIGVzcGVjaWFsbHkgaW4gRkZcblx0aWdub3JhYmxlczogW1xuXHRcdGtleXMuQmFja3NwYWNlLFxuXHRcdGtleXMuVGFiLFxuXHRcdGtleXMuUGF1c2UsXG5cdFx0a2V5cy5Fc2NhcGUsXG5cdFx0a2V5cy5QYWdlVXAsXG5cdFx0a2V5cy5QYWdlRG93bixcblx0XHRrZXlzLkVuZCxcblx0XHRrZXlzLkhvbWUsXG5cdFx0a2V5cy5BcnJvd0xlZnQsXG5cdFx0a2V5cy5BcnJvd1VwLFxuXHRcdGtleXMuQXJyb3dSaWdodCxcblx0XHRrZXlzLkFycm93RG93bixcblx0XHRrZXlzLkluc2VydCxcblx0XHRrZXlzLkRlbGV0ZSxcblx0XHRrZXlzLkNvbnRleHRNZW51LFxuXHRcdGtleXMuRjEsXG5cdFx0a2V5cy5GMixcblx0XHRrZXlzLkYzLFxuXHRcdGtleXMuRjQsXG5cdFx0a2V5cy5GNSxcblx0XHRrZXlzLkY2LFxuXHRcdGtleXMuRjcsXG5cdFx0a2V5cy5GOCxcblx0XHRrZXlzLkY5LFxuXHRcdGtleXMuRjEwLFxuXHRcdGtleXMuRjExLFxuXHRcdGtleXMuRjEyLFxuXHRcdGtleXMuUHJvY2Vzcyxcblx0XHRrZXlzLlVuaWRlbnRpZmllZCxcblx0XHRrZXlzLlNoaWZ0LFxuXHRcdGtleXMuQ29udHJvbCxcblx0XHRrZXlzLkFsdCxcblx0XHRrZXlzLlRhYixcblx0XHRrZXlzLkFsdEdyYXBoLFxuXHRcdGtleXMuQ2Fwc0xvY2tcblx0XSxcblx0aXNDb21wbGV0ZTogbnVsbCwgLy9vdmVycmlkZSBmb3IgaXNDb21wbGV0ZSAtIGFyZ3MgPT4gYnVmZmVyLCBvcHRzIC0gcmV0dXJuIHRydWUgfHwgZmFsc2Vcblx0cHJlVmFsaWRhdGlvbjogbnVsbCwgLy9ob29rIHRvIHByZVZhbGlkYXRlIHRoZSBpbnB1dC4gIFVzZWZ1bGwgZm9yIHZhbGlkYXRpbmcgcmVnYXJkbGVzcyB0aGUgZGVmaW5pdGlvbi5cdGFyZ3MgPT4gYnVmZmVyLCBwb3MsIGNoYXIsIGlzU2VsZWN0aW9uLCBvcHRzLCBtYXNrc2V0LCBjYXJldFBvcywgc3RyaWN0ID0+IHJldHVybiB0cnVlL2ZhbHNlL2NvbW1hbmQgb2JqZWN0XG5cdHBvc3RWYWxpZGF0aW9uOiBudWxsLCAvL2hvb2sgdG8gcG9zdFZhbGlkYXRlIHRoZSByZXN1bHQgZnJvbSBpc1ZhbGlkLlx0VXNlZnVsbCBmb3IgdmFsaWRhdGluZyB0aGUgZW50cnkgYXMgYSB3aG9sZS5cdGFyZ3MgPT4gYnVmZmVyLCBwb3MsIGMsIGN1cnJlbnRSZXN1bHQsIG9wdHMsIG1hc2tzZXQsIHN0cmljdCwgZnJvbUNoZWNrdmFsID0+IHJldHVybiB0cnVlL2ZhbHNlL2pzb25cblx0c3RhdGljRGVmaW5pdGlvblN5bWJvbDogdW5kZWZpbmVkLCAvL3NwZWNpZnkgYSBkZWZpbml0aW9uU3ltYm9sIGZvciBzdGF0aWMgY29udGVudCwgdXNlZCB0byBtYWtlIG1hdGNoZXMgZm9yIGFsdGVybmF0b3JzXG5cdGppdE1hc2tpbmc6IGZhbHNlLCAvL2p1c3QgaW4gdGltZSBtYXNraW5nIH4gb25seSBtYXNrIHdoaWxlIHR5cGluZywgY2FuIG4gKG51bWJlciksIHRydWUgb3IgZmFsc2Vcblx0bnVsbGFibGU6IHRydWUsIC8vcmV0dXJuIG5vdGhpbmcgaW5zdGVhZCBvZiB0aGUgYnVmZmVydGVtcGxhdGUgd2hlbiB0aGUgdXNlciBoYXNuJ3QgZW50ZXJlZCBhbnl0aGluZy5cblx0aW5wdXRFdmVudE9ubHk6IGZhbHNlLCAvL2RldiBvcHRpb24gLSB0ZXN0aW5nIGlucHV0ZmFsbGJhY2sgYmVoYXZpb3Jcblx0bm9WYWx1ZVBhdGNoaW5nOiBmYWxzZSwgLy9kaXNhYmxlIHZhbHVlIHByb3BlcnR5IHBhdGNoaW5nXG5cdHBvc2l0aW9uQ2FyZXRPbkNsaWNrOiBcImx2cFwiLCAvL25vbmUsIGx2cCAoYmFzZWQgb24gdGhlIGxhc3QgdmFsaWQgcG9zaXRpb24gKGRlZmF1bHQpLCByYWRpeEZvY3VzIChwb3NpdGlvbiBjYXJldCB0byByYWRpeHBvaW50IG9uIGluaXRpYWwgY2xpY2spLCBzZWxlY3QgKHNlbGVjdCB0aGUgd2hvbGUgaW5wdXQpLCBpZ25vcmUgKGlnbm9yZSB0aGUgY2xpY2sgYW5kIGNvbnRpbnVlIHRoZSBtYXNrKVxuXHRjYXNpbmc6IG51bGwsIC8vbWFzay1sZXZlbCBjYXNpbmcuIE9wdGlvbnM6IG51bGwsIFwidXBwZXJcIiwgXCJsb3dlclwiIG9yIFwidGl0bGVcIiBvciBjYWxsYmFjayBhcmdzID0+IGVsZW0sIHRlc3QsIHBvcywgdmFsaWRQb3NpdGlvbnMgcmV0dXJuIGNoYXJWYWx1ZVxuXHRpbnB1dG1vZGU6IFwidGV4dFwiLCAvL3NwZWNpZnkgdGhlIGlucHV0bW9kZVxuXHRpbXBvcnREYXRhQXR0cmlidXRlczogdHJ1ZSwgLy9pbXBvcnQgZGF0YS1pbnB1dG1hc2sgYXR0cmlidXRlc1xuXHRzaGlmdFBvc2l0aW9uczogdHJ1ZSwgLy9zaGlmdCBwb3NpdGlvbiBvZiB0aGUgbWFzayBlbnRyaWVzIG9uIGVudHJ5IGFuZCBkZWxldGlvbi5cblx0dXNlUHJvdG90eXBlRGVmaW5pdGlvbnM6IHRydWUsIC8vdXNlIHRoZSBkZWZhdWx0IGRlZmluZWQgZGVmaW5pdGlvbnMgZnJvbSB0aGUgcHJvdG90eXBlXG5cdHZhbGlkYXRpb25FdmVudFRpbWVPdXQ6IDMwMDAsIC8vVGltZSB0byBzaG93IHZhbGlkYXRpb24gZXJyb3Igb24gZm9ybSBzdWJtaXRcblx0c3Vic3RpdHV0ZXM6IHt9IC8vZGVmaW5lIGNoYXJhY3RlciBzdWJzdGl0dXRlc1xufTtcbiIsImV4cG9ydCBkZWZhdWx0IHtcblx0XCI5XCI6IHsgLy9cXHVGRjExLVxcdUZGMTkgIzE2MDZcblx0XHR2YWxpZGF0b3I6IFwiWzAtOVxcdUZGMTAtXFx1RkYxOV1cIixcblx0XHRkZWZpbml0aW9uU3ltYm9sOiBcIipcIlxuXHR9LFxuXHRcImFcIjogeyAvL1xcdTA0MTAtXFx1MDQ0RlxcdTA0MDFcXHUwNDUxXFx1MDBDMC1cXHUwMEZGXFx1MDBCNSAjNzZcblx0XHR2YWxpZGF0b3I6IFwiW0EtWmEtelxcdTA0MTAtXFx1MDQ0RlxcdTA0MDFcXHUwNDUxXFx1MDBDMC1cXHUwMEZGXFx1MDBCNV1cIixcblx0XHRkZWZpbml0aW9uU3ltYm9sOiBcIipcIlxuXHR9LFxuXHRcIipcIjoge1xuXHRcdHZhbGlkYXRvcjogXCJbMC05XFx1RkYxMC1cXHVGRjE5QS1aYS16XFx1MDQxMC1cXHUwNDRGXFx1MDQwMVxcdTA0NTFcXHUwMEMwLVxcdTAwRkZcXHUwMEI1XVwiXG5cdH1cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG93bmVyLCBrZXksIHZhbHVlKSB7XG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG93bmVyLl9fZGF0YSA/IG93bmVyLl9fZGF0YVtrZXldIDogbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvd25lci5fX2RhdGEgPSBvd25lci5fX2RhdGEgfHwge307XG5cdFx0b3duZXIuX19kYXRhW2tleV0gPSB2YWx1ZTtcblx0fVxufSIsImltcG9ydCBleHRlbmQgZnJvbSBcIi4vZXh0ZW5kXCI7XG5pbXBvcnQgd2luZG93IGZyb20gXCIuLi9nbG9iYWwvd2luZG93XCI7XG5pbXBvcnQgRGVwZW5kZW5jeUxpYiBmcm9tIFwiLi9pbnB1dG1hc2suZGVwZW5kZW5jeUxpYlwiO1xuaW1wb3J0IGNhblVzZURPTSBmcm9tIFwiLi4vY2FuVXNlRE9NXCI7XG5cbmV4cG9ydCB7b24sIG9mZiwgdHJpZ2dlciwgRXZlbnR9O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChlbGVtKSB7XG5cdHJldHVybiBlbGVtIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxubGV0IEV2ZW50O1xuaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuXHRFdmVudCA9IHdpbmRvdy5DdXN0b21FdmVudDtcbn0gZWxzZSB7XG5cdGlmIChjYW5Vc2VET00pIHtcblx0XHRFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zKSB7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgY29tcG9zZWQ6IHRydWUsIGRldGFpbDogdW5kZWZpbmVkfTtcblx0XHRcdHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuXHRcdFx0ZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcblx0XHRcdHJldHVybiBldnQ7XG5cdFx0fTtcblx0XHRFdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuXHR9XG59XG5cblxuZnVuY3Rpb24gb24oZXZlbnRzLCBoYW5kbGVyKSB7XG5cdGZ1bmN0aW9uIGFkZEV2ZW50KGV2LCBuYW1lc3BhY2UpIHtcblx0XHQvL3JlZ2lzdGVyIGRvbWV2ZW50XG5cdFx0aWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikgeyAvLyBhbGwgYnJvd3NlcnMgZXhjZXB0IElFIGJlZm9yZSB2ZXJzaW9uIDlcblx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldiwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkgeyAvLyBJRSBiZWZvcmUgdmVyc2lvbiA5XG5cdFx0XHRlbGVtLmF0dGFjaEV2ZW50KGBvbiR7ZXZ9YCwgaGFuZGxlcik7XG5cdFx0fVxuXHRcdGV2ZW50UmVnaXN0cnlbZXZdID0gZXZlbnRSZWdpc3RyeVtldl0gfHwge307XG5cdFx0ZXZlbnRSZWdpc3RyeVtldl1bbmFtZXNwYWNlXSA9IGV2ZW50UmVnaXN0cnlbZXZdW25hbWVzcGFjZV0gfHwgW107XG5cdFx0ZXZlbnRSZWdpc3RyeVtldl1bbmFtZXNwYWNlXS5wdXNoKGhhbmRsZXIpO1xuXHR9XG5cblx0aWYgKGlzVmFsaWRFbGVtZW50KHRoaXNbMF0pKSB7XG5cdFx0dmFyIGV2ZW50UmVnaXN0cnkgPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnksXG5cdFx0XHRlbGVtID0gdGhpc1swXTtcblxuXHRcdGV2ZW50cy5zcGxpdChcIiBcIikuZm9yRWFjaCgoZXZlbnQpID0+IHtcblx0XHRcdGNvbnN0IFtldiwgbmFtZXNwYWNlID0gXCJnbG9iYWxcIl0gPSBldmVudC5zcGxpdChcIi5cIik7XG5cdFx0XHRhZGRFdmVudChldiwgbmFtZXNwYWNlKTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gb2ZmKGV2ZW50cywgaGFuZGxlcikge1xuXHR2YXIgZXZlbnRSZWdpc3RyeSwgZWxlbTtcblxuXHRmdW5jdGlvbiByZW1vdmVFdmVudChldiwgbmFtZXNwYWNlLCBoYW5kbGVyKSB7XG5cdFx0aWYgKGV2IGluIGV2ZW50UmVnaXN0cnkgPT09IHRydWUpIHtcblx0XHRcdC8vdW5iaW5kIHRvIGRvbSBldmVudHNcblx0XHRcdGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHsgLy8gYWxsIGJyb3dzZXJzIGV4Y2VwdCBJRSBiZWZvcmUgdmVyc2lvbiA5XG5cdFx0XHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0fSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7IC8vIElFIGJlZm9yZSB2ZXJzaW9uIDlcblx0XHRcdFx0ZWxlbS5kZXRhY2hFdmVudChgb24ke2V2fWAsIGhhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIikge1xuXHRcdFx0XHRmb3IgKHZhciBubXNwIGluIGV2ZW50UmVnaXN0cnlbZXZdKSB7XG5cdFx0XHRcdFx0ZXZlbnRSZWdpc3RyeVtldl1bbm1zcF0uc3BsaWNlKGV2ZW50UmVnaXN0cnlbZXZdW25tc3BdLmluZGV4T2YoaGFuZGxlciksIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRldmVudFJlZ2lzdHJ5W2V2XVtuYW1lc3BhY2VdLnNwbGljZShldmVudFJlZ2lzdHJ5W2V2XVtuYW1lc3BhY2VdLmluZGV4T2YoaGFuZGxlciksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmVOYW1lc3BhY2UoZXYsIG5hbWVzcGFjZSkge1xuXHRcdHZhciBldnRzID0gW10sXG5cdFx0XHRobmR4LCBobmRMO1xuXHRcdGlmIChldi5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZvciAoaG5keCA9IDAsIGhuZEwgPSBldmVudFJlZ2lzdHJ5W2V2XVtuYW1lc3BhY2VdLmxlbmd0aDsgaG5keCA8IGhuZEw7IGhuZHgrKykge1xuXHRcdFx0XHRcdGV2dHMucHVzaCh7XG5cdFx0XHRcdFx0XHRldjogZXYsXG5cdFx0XHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZSAmJiBuYW1lc3BhY2UubGVuZ3RoID4gMCA/IG5hbWVzcGFjZSA6IFwiZ2xvYmFsXCIsXG5cdFx0XHRcdFx0XHRoYW5kbGVyOiBldmVudFJlZ2lzdHJ5W2V2XVtuYW1lc3BhY2VdW2huZHhdXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV2dHMucHVzaCh7XG5cdFx0XHRcdFx0ZXY6IGV2LFxuXHRcdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlICYmIG5hbWVzcGFjZS5sZW5ndGggPiAwID8gbmFtZXNwYWNlIDogXCJnbG9iYWxcIixcblx0XHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobmFtZXNwYWNlLmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGV2TmR4IGluIGV2ZW50UmVnaXN0cnkpIHtcblx0XHRcdFx0Zm9yICh2YXIgbm1zcCBpbiBldmVudFJlZ2lzdHJ5W2V2TmR4XSkge1xuXHRcdFx0XHRcdGlmIChubXNwID09PSBuYW1lc3BhY2UpIHtcblx0XHRcdFx0XHRcdGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChobmR4ID0gMCwgaG5kTCA9IGV2ZW50UmVnaXN0cnlbZXZOZHhdW25tc3BdLmxlbmd0aDsgaG5keCA8IGhuZEw7IGhuZHgrKykge1xuXHRcdFx0XHRcdFx0XHRcdGV2dHMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRldjogZXZOZHgsXG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lc3BhY2U6IG5tc3AsXG5cdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVyOiBldmVudFJlZ2lzdHJ5W2V2TmR4XVtubXNwXVtobmR4XVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRldnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdGV2OiBldk5keCxcblx0XHRcdFx0XHRcdFx0XHRuYW1lc3BhY2U6IG5tc3AsXG5cdFx0XHRcdFx0XHRcdFx0aGFuZGxlcjogaGFuZGxlclxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZ0cztcblx0fVxuXG5cdGlmIChpc1ZhbGlkRWxlbWVudCh0aGlzWzBdKSAmJiBldmVudHMpIHtcblx0XHRldmVudFJlZ2lzdHJ5ID0gdGhpc1swXS5ldmVudFJlZ2lzdHJ5O1xuXHRcdGVsZW0gPSB0aGlzWzBdO1xuXG5cdFx0ZXZlbnRzLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChldmVudCkgPT4ge1xuXHRcdFx0Y29uc3QgW2V2LCBuYW1lc3BhY2VdID0gZXZlbnQuc3BsaXQoXCIuXCIpO1xuXHRcdFx0cmVzb2x2ZU5hbWVzcGFjZShldiwgbmFtZXNwYWNlKS5mb3JFYWNoKCh7ZXY6IGV2MSwgaGFuZGxlcjogaGFuZGxlcjEsIG5hbWVzcGFjZTogbmFtZXNwYWNlMX0pID0+IHtcblx0XHRcdFx0cmVtb3ZlRXZlbnQoZXYxLCBuYW1lc3BhY2UxLCBoYW5kbGVyMSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdHJpZ2dlcihldmVudHMgLyogLCBhcmdzLi4uICovKSB7XG5cdGlmIChpc1ZhbGlkRWxlbWVudCh0aGlzWzBdKSkge1xuXHRcdHZhciBldmVudFJlZ2lzdHJ5ID0gdGhpc1swXS5ldmVudFJlZ2lzdHJ5LFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF07XG5cdFx0dmFyIF9ldmVudHMgPSB0eXBlb2YgZXZlbnRzID09PSBcInN0cmluZ1wiID8gZXZlbnRzLnNwbGl0KFwiIFwiKSA6IFtldmVudHMudHlwZV07XG5cdFx0Zm9yICh2YXIgZW5keCA9IDA7IGVuZHggPCBfZXZlbnRzLmxlbmd0aDsgZW5keCsrKSB7XG5cdFx0XHR2YXIgbnNFdmVudCA9IF9ldmVudHNbZW5keF0uc3BsaXQoXCIuXCIpLFxuXHRcdFx0XHRldiA9IG5zRXZlbnRbMF0sXG5cdFx0XHRcdG5hbWVzcGFjZSA9IG5zRXZlbnRbMV0gfHwgXCJnbG9iYWxcIjtcblx0XHRcdGlmIChkb2N1bWVudCAhPT0gdW5kZWZpbmVkICYmIG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIikge1xuXHRcdFx0XHQvL3RyaWdnZXIgZG9tZXZlbnRcblx0XHRcdFx0dmFyIGV2bnQsIGksIHBhcmFtcyA9IHtcblx0XHRcdFx0XHRidWJibGVzOiB0cnVlLFxuXHRcdFx0XHRcdGNhbmNlbGFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29tcG9zZWQ6IHRydWUsXG5cdFx0XHRcdFx0ZGV0YWlsOiBhcmd1bWVudHNbMV1cblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gVGhlIGN1c3RvbSBldmVudCB0aGF0IHdpbGwgYmUgY3JlYXRlZFxuXHRcdFx0XHRpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0c3dpdGNoIChldikge1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwiaW5wdXRcIjpcblx0XHRcdFx0XHRcdFx0XHRwYXJhbXMuaW5wdXRUeXBlID0gXCJpbnNlcnRUZXh0XCI7XG5cdFx0XHRcdFx0XHRcdFx0ZXZudCA9IG5ldyBJbnB1dEV2ZW50KGV2LCBwYXJhbXMpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdGV2bnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXYsIHBhcmFtcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0ZXZudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG5cdFx0XHRcdFx0XHRldm50LmluaXRDdXN0b21FdmVudChldiwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGV2ZW50cy50eXBlKSBleHRlbmQoZXZudCwgZXZlbnRzKTtcblx0XHRcdFx0XHRlbGVtLmRpc3BhdGNoRXZlbnQoZXZudCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXZudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG5cdFx0XHRcdFx0ZXZudC5ldmVudFR5cGUgPSBldjtcblx0XHRcdFx0XHRldm50LmRldGFpbCA9IGFyZ3VtZW50c1sxXTtcblx0XHRcdFx0XHRpZiAoZXZlbnRzLnR5cGUpIGV4dGVuZChldm50LCBldmVudHMpO1xuXHRcdFx0XHRcdGVsZW0uZmlyZUV2ZW50KFwib25cIiArIGV2bnQuZXZlbnRUeXBlLCBldm50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChldmVudFJlZ2lzdHJ5W2V2XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXS50eXBlID8gYXJndW1lbnRzWzBdIDogRGVwZW5kZW5jeUxpYi5FdmVudChhcmd1bWVudHNbMF0pO1xuXHRcdFx0XHRhcmd1bWVudHNbMF0uZGV0YWlsID0gYXJndW1lbnRzLnNsaWNlKDEpO1xuXG5cdFx0XHRcdGNvbnN0IHJlZ2lzdHJ5ID0gZXZlbnRSZWdpc3RyeVtldl0sXG5cdFx0XHRcdFx0aGFuZGxlcnMgPSBuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgPyBPYmplY3QudmFsdWVzKHJlZ2lzdHJ5KS5mbGF0KCkgOiByZWdpc3RyeVtuYW1lc3BhY2VdO1xuXHRcdFx0XHRoYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlci5hcHBseShlbGVtLCBhcmd1bWVudHMpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdGxldCBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1tpXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkgIT0gbnVsbCkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yIChuYW1lIGluIG9wdGlvbnMpIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0W25hbWVdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1tuYW1lXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICh0YXJnZXQgPT09IGNvcHkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoZGVlcCAmJiBjb3B5ICYmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29weSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIgfHwgKGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjb3B5KSkpKSB7XG5cdFx0XHRcdFx0aWYgKGNvcHlJc0FycmF5KSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgPT09IFwiW29iamVjdCBPYmplY3RdXCIgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBleHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNvcHkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufSIsIi8qXG4gSW5wdXQgTWFzayBwbHVnaW4gZGVwZW5kZW5jeUxpYlxuIGh0dHA6Ly9naXRodWIuY29tL1JvYmluSGVyYm90cy9qcXVlcnkuaW5wdXRtYXNrXG4gQ29weXJpZ2h0IChjKSBSb2JpbiBIZXJib3RzXG4gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuaW1wb3J0IGV4dGVuZCBmcm9tIFwiLi9leHRlbmRcIjtcbmltcG9ydCB3aW5kb3cgZnJvbSBcIi4uL2dsb2JhbC93aW5kb3dcIjtcbmltcG9ydCBkYXRhIGZyb20gXCIuL2RhdGFcIjtcbmltcG9ydCB7IG9uLCBvZmYsIHRyaWdnZXIsIEV2ZW50fSBmcm9tIFwiLi9ldmVudHNcIjtcblxuY29uc3QgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbmZ1bmN0aW9uIERlcGVuZGVuY3lMaWIoZWxlbSkge1xuXHRpZiAoZWxlbSBpbnN0YW5jZW9mIERlcGVuZGVuY3lMaWIpIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVwZW5kZW5jeUxpYikpIHtcblx0XHRyZXR1cm4gbmV3IERlcGVuZGVuY3lMaWIoZWxlbSk7XG5cdH1cblx0aWYgKGVsZW0gIT09IHVuZGVmaW5lZCAmJiBlbGVtICE9PSBudWxsICYmIGVsZW0gIT09IHdpbmRvdykge1xuXHRcdHRoaXNbMF0gPSBlbGVtLm5vZGVOYW1lID8gZWxlbSA6IChlbGVtWzBdICE9PSB1bmRlZmluZWQgJiYgZWxlbVswXS5ub2RlTmFtZSA/IGVsZW1bMF0gOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW0pKTtcblx0XHRpZiAodGhpc1swXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNbMF0gIT09IG51bGwpIHtcblx0XHRcdHRoaXNbMF0uZXZlbnRSZWdpc3RyeSA9IHRoaXNbMF0uZXZlbnRSZWdpc3RyeSB8fCB7fTtcblx0XHR9XG5cdH1cbn1cblxuRGVwZW5kZW5jeUxpYi5wcm90b3R5cGUgPSB7XG5cdG9uOiBvbixcblx0b2ZmOiBvZmYsXG5cdHRyaWdnZXI6IHRyaWdnZXJcbn07XG5cbi8vc3RhdGljXG5EZXBlbmRlbmN5TGliLmV4dGVuZCA9IGV4dGVuZDtcbkRlcGVuZGVuY3lMaWIuZGF0YSA9IGRhdGE7XG5EZXBlbmRlbmN5TGliLkV2ZW50ID0gRXZlbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IERlcGVuZGVuY3lMaWI7XG4iLCJpbXBvcnQgd2luZG93IGZyb20gXCIuL2dsb2JhbC93aW5kb3dcIjtcblxuY29uc3QgdWEgPSAod2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgXCJcIixcbiAgICBpZSA9ICh1YS5pbmRleE9mKFwiTVNJRSBcIikgPiAwKSB8fCAodWEuaW5kZXhPZihcIlRyaWRlbnQvXCIpID4gMCksXG4gICAgbW9iaWxlID0gKG5hdmlnYXRvci51c2VyQWdlbnREYXRhICYmIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLm1vYmlsZSkgfHwgKHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cykgfHwgXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3csIC8vbm90IGVudGlyZWx5IGNvcnJlY3QgYnV0IHdpbGwgY3VycmVudGx5IGRvXG4gICAgaXBob25lID0gL2lwaG9uZS9pLnRlc3QodWEpO1xuXG5leHBvcnQge2llLCBtb2JpbGUsIGlwaG9uZX07XG4iLCJjb25zdCAgZXNjYXBlUmVnZXhSZWdleCA9IG5ldyBSZWdFeHAoXCIoXFxcXFwiICsgW1wiL1wiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLCBcIj9cIiwgXCJ8XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIFwiXFxcXFwiLCBcIiRcIiwgXCJeXCJdLmpvaW4oXCJ8XFxcXFwiKSArIFwiKVwiLCBcImdpbVwiKTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKGVzY2FwZVJlZ2V4UmVnZXgsIFwiXFxcXCQxXCIpO1xufSIsImltcG9ydCB7XG4gICAgY2FyZXQsIGRldGVybWluZU5ld0NhcmV0UG9zaXRpb24sXG4gICAgZ2V0QnVmZmVyLCBnZXRCdWZmZXJUZW1wbGF0ZSxcbiAgICBnZXRMYXN0VmFsaWRQb3NpdGlvbiwgaXNNYXNrLFxuICAgIHJlc2V0TWFza1NldCxcbiAgICBzZWVrTmV4dCxcbiAgICBzZWVrUHJldmlvdXMsXG4gICAgdHJhbnNsYXRlUG9zaXRpb25cbn0gZnJvbSBcIi4vcG9zaXRpb25pbmdcIjtcbmltcG9ydCB7a2V5c30gZnJvbSBcIi4va2V5Y29kZS5qc1wiO1xuaW1wb3J0IHtpcGhvbmUsIG1vYmlsZX0gZnJvbSBcIi4vZW52aXJvbm1lbnRcIjtcbmltcG9ydCB7aGFuZGxlUmVtb3ZlLCBpc0NvbXBsZXRlLCBpc1NlbGVjdGlvbiwgaXNWYWxpZH0gZnJvbSBcIi4vdmFsaWRhdGlvblwiO1xuaW1wb3J0IHthcHBseUlucHV0VmFsdWUsIGNoZWNrVmFsLCBjbGVhck9wdGlvbmFsVGFpbCwgSGFuZGxlTmF0aXZlUGxhY2Vob2xkZXIsIHdyaXRlQnVmZmVyfSBmcm9tIFwiLi9pbnB1dEhhbmRsaW5nXCI7XG5pbXBvcnQge2dldFBsYWNlaG9sZGVyLCBnZXRUZXN0fSBmcm9tIFwiLi92YWxpZGF0aW9uLXRlc3RzXCI7XG5cbmV4cG9ydCB7RXZlbnRIYW5kbGVyc307XG5cbnZhciBFdmVudEhhbmRsZXJzID0ge1xuICAgIGtleUV2ZW50OiBmdW5jdGlvbiAoZSwgY2hlY2t2YWwsIHdyaXRlT3V0LCBzdHJpY3QsIG5keCkge1xuICAgICAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLmlucHV0bWFzaywgb3B0cyA9IGlucHV0bWFzay5vcHRzLCAkID0gaW5wdXRtYXNrLmRlcGVuZGVuY3lMaWIsXG4gICAgICAgICAgICBtYXNrc2V0ID0gaW5wdXRtYXNrLm1hc2tzZXQ7XG5cbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcyxcbiAgICAgICAgICAgICRpbnB1dCA9ICQoaW5wdXQpLFxuICAgICAgICAgICAgYyA9IGUua2V5LFxuICAgICAgICAgICAgcG9zID0gY2FyZXQuY2FsbChpbnB1dG1hc2ssIGlucHV0KTtcblxuICAgICAgICB2YXIga2RSZXN1bHQgPSBvcHRzLm9uS2V5RG93bi5jYWxsKHRoaXMsIGUsIGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzayksIHBvcywgb3B0cyk7XG4gICAgICAgIGlmIChrZFJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4ga2RSZXN1bHQ7XG5cbiAgICAgICAgLy9iYWNrc3BhY2UsIGRlbGV0ZSwgYW5kIGVzY2FwZSBnZXQgc3BlY2lhbCB0cmVhdG1lbnRcbiAgICAgICAgaWYgKGMgPT09IGtleXMuQmFja3NwYWNlIHx8IGMgPT09IGtleXMuRGVsZXRlIHx8IChpcGhvbmUgJiYgYyA9PT0ga2V5cy5CQUNLU1BBQ0VfU0FGQVJJKSB8fCAoZS5jdHJsS2V5ICYmIGMgPT09IGtleXMueCAmJiAhKFwib25jdXRcIiBpbiBpbnB1dCkpKSB7IC8vYmFja3NwYWNlL2RlbGV0ZVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvL3N0b3AgZGVmYXVsdCBhY3Rpb24gYnV0IGFsbG93IHByb3BhZ2F0aW9uXG4gICAgICAgICAgICBoYW5kbGVSZW1vdmUuY2FsbChpbnB1dG1hc2ssIGlucHV0LCBjLCBwb3MpO1xuICAgICAgICAgICAgd3JpdGVCdWZmZXIoaW5wdXQsIGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzaywgdHJ1ZSksIG1hc2tzZXQucCwgZSwgaW5wdXQuaW5wdXRtYXNrLl92YWx1ZUdldCgpICE9PSBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLmpvaW4oXCJcIikpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IGtleXMuRW5kIHx8IGMgPT09IGtleXMuUGFnZURvd24pIHsgLy93aGVuIEVORCBvciBQQUdFX0RPV04gcHJlc3NlZCBzZXQgcG9zaXRpb24gYXQgbGFzdG1hdGNoXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgY2FyZXRQb3MgPSBzZWVrTmV4dC5jYWxsKGlucHV0bWFzaywgZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChpbnB1dG1hc2spKTtcbiAgICAgICAgICAgIGNhcmV0LmNhbGwoaW5wdXRtYXNrLCBpbnB1dCwgZS5zaGlmdEtleSA/IHBvcy5iZWdpbiA6IGNhcmV0UG9zLCBjYXJldFBvcywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGMgPT09IGtleXMuSG9tZSAmJiAhZS5zaGlmdEtleSkgfHwgYyA9PT0ga2V5cy5QYWdlVXApIHsgLy9Ib21lIG9yIHBhZ2VfdXBcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNhcmV0LmNhbGwoaW5wdXRtYXNrLCBpbnB1dCwgMCwgZS5zaGlmdEtleSA/IHBvcy5iZWdpbiA6IDAsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCgob3B0cy51bmRvT25Fc2NhcGUgJiYgYyA9PT0ga2V5cy5Fc2NhcGUpIHx8IChmYWxzZSAmJiBjID09PSBrZXlzLnogJiYgZS5jdHJsS2V5KSkgJiYgZS5hbHRLZXkgIT09IHRydWUpIHsgLy9lc2NhcGUgJiYgdW5kbyAmJiAjNzYyXG4gICAgICAgICAgICBjaGVja1ZhbChpbnB1dCwgdHJ1ZSwgZmFsc2UsIGlucHV0bWFzay51bmRvVmFsdWUuc3BsaXQoXCJcIikpO1xuICAgICAgICAgICAgJGlucHV0LnRyaWdnZXIoXCJjbGlja1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSBrZXlzLkluc2VydCAmJiAhKGUuc2hpZnRLZXkgfHwgZS5jdHJsS2V5KSAmJiBpbnB1dG1hc2sudXNlck9wdGlvbnMuaW5zZXJ0TW9kZSA9PT0gdW5kZWZpbmVkKSB7IC8vaW5zZXJ0XG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0aW9uLmNhbGwoaW5wdXRtYXNrLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5pbnNlcnRNb2RlID0gIW9wdHMuaW5zZXJ0TW9kZTtcbiAgICAgICAgICAgICAgICBjYXJldC5jYWxsKGlucHV0bWFzaywgaW5wdXQsIHBvcy5iZWdpbiwgcG9zLmJlZ2luKTtcbiAgICAgICAgICAgIH0gZWxzZSBvcHRzLmluc2VydE1vZGUgPSAhb3B0cy5pbnNlcnRNb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMudGFiVGhyb3VnaCA9PT0gdHJ1ZSAmJiBjID09PSBrZXlzLlRhYikge1xuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwb3MuZW5kID0gc2Vla1ByZXZpb3VzLmNhbGwoaW5wdXRtYXNrLCBwb3MuZW5kLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VGVzdC5jYWxsKGlucHV0bWFzaywgcG9zLmVuZCAtIDEpLm1hdGNoLnN0YXRpYyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MuZW5kLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcy5iZWdpbiA9IHNlZWtQcmV2aW91cy5jYWxsKGlucHV0bWFzaywgcG9zLmVuZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5iZWdpbiA+PSAwICYmIHBvcy5lbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuY2FsbChpbnB1dG1hc2ssIGlucHV0LCBwb3MuYmVnaW4sIHBvcy5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zLmJlZ2luID0gc2Vla05leHQuY2FsbChpbnB1dG1hc2ssIHBvcy5iZWdpbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcG9zLmVuZCA9IHNlZWtOZXh0LmNhbGwoaW5wdXRtYXNrLCBwb3MuYmVnaW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MuZW5kIDwgbWFza3NldC5tYXNrTGVuZ3RoKSBwb3MuZW5kLS07XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5iZWdpbiA8PSBtYXNrc2V0Lm1hc2tMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5jYWxsKGlucHV0bWFzaywgaW5wdXQsIHBvcy5iZWdpbiwgcG9zLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBpZiAob3B0cy5pbnNlcnRNb2RlVmlzdWFsICYmIG9wdHMuaW5zZXJ0TW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0ga2V5cy5BcnJvd1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcmV0UG9zID0gY2FyZXQuY2FsbChpbnB1dG1hc2ssIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0LmNhbGwoaW5wdXRtYXNrLCBpbnB1dCwgY2FyZXRQb3MuYmVnaW4pO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IGtleXMuQXJyb3dMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcmV0UG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiB0cmFuc2xhdGVQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywgaW5wdXQuaW5wdXRtYXNrLmNhcmV0UG9zLmJlZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHRyYW5zbGF0ZVBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCBpbnB1dC5pbnB1dG1hc2suY2FyZXRQb3MuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dG1hc2suaXNSVEwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5jYWxsKGlucHV0bWFzaywgaW5wdXQsIGNhcmV0UG9zLmJlZ2luICsgKGNhcmV0UG9zLmJlZ2luID09PSBtYXNrc2V0Lm1hc2tMZW5ndGggPyAwIDogMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5jYWxsKGlucHV0bWFzaywgaW5wdXQsIGNhcmV0UG9zLmJlZ2luIC0gKGNhcmV0UG9zLmJlZ2luID09PSAwID8gMCA6IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRtYXNrLmlzQ29tcG9zaW5nID0gKGMgPT0ga2V5cy5Qcm9jZXNzIHx8IGMgPT0ga2V5cy5VbmlkZW50aWZpZWQpO1xuICAgICAgICBpbnB1dG1hc2suaWdub3JhYmxlID0gb3B0cy5pZ25vcmFibGVzLmluY2x1ZGVzKGMpO1xuICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVycy5rZXlwcmVzc0V2ZW50LmNhbGwodGhpcywgZSwgY2hlY2t2YWwsIHdyaXRlT3V0LCBzdHJpY3QsIG5keCk7XG4gICAgfSxcbiAgICBrZXlwcmVzc0V2ZW50OiBmdW5jdGlvbiAoZSwgY2hlY2t2YWwsIHdyaXRlT3V0LCBzdHJpY3QsIG5keCkge1xuICAgICAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLmlucHV0bWFzayB8fCB0aGlzLCBvcHRzID0gaW5wdXRtYXNrLm9wdHMsICQgPSBpbnB1dG1hc2suZGVwZW5kZW5jeUxpYixcbiAgICAgICAgICAgIG1hc2tzZXQgPSBpbnB1dG1hc2subWFza3NldDtcblxuICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dG1hc2suZWwsXG4gICAgICAgICAgICAkaW5wdXQgPSAkKGlucHV0KSxcbiAgICAgICAgICAgIGMgPSBlLmtleTtcblxuICAgICAgICBpZiAoY2hlY2t2YWwgIT09IHRydWUgJiYgKCEoZS5jdHJsS2V5ICYmIGUuYWx0S2V5KSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBpbnB1dG1hc2suaWdub3JhYmxlKSkpIHtcbiAgICAgICAgICAgIGlmIChjID09PSBrZXlzLkVudGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0bWFzay51bmRvVmFsdWUgIT09IGlucHV0bWFzay5fdmFsdWVHZXQodHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRtYXNrLnVuZG9WYWx1ZSA9IGlucHV0bWFzay5fdmFsdWVHZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dC50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lucHV0bWFzay5za2lwSW5wdXRFdmVudCA9IHRydWU7IC8vc2tpcCB0aGUgaW5wdXQgYXMgb3RoZXJ3aXNlIHRoZSBza2lwcGVkIGNoYXIgY291bGQgYmUgcGlja2VkIHVwIGZvciB2YWxpZGF0aW9uIGJ5IHRoZSBpbnB1dGZhbGxiYWNrXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYykge1xuICAgICAgICAgICAgLy9zcGVjaWFsIHRyZWF0IHRoZSBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgLy8gaWYgKChrID09PSA0NCB8fCBrID09PSA0NikgJiYgZS5sb2NhdGlvbiA9PT0gMyAmJiBvcHRzLnJhZGl4UG9pbnQgIT09IFwiXCIpIGsgPSBvcHRzLnJhZGl4UG9pbnQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBjaGVja3ZhbCA/IHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IG5keCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBuZHhcbiAgICAgICAgICAgICAgICB9IDogY2FyZXQuY2FsbChpbnB1dG1hc2ssIGlucHV0KSxcbiAgICAgICAgICAgICAgICBmb3J3YXJkUG9zaXRpb247XG5cbiAgICAgICAgICAgIC8vYWxsb3cgZm9yIGNoYXJhY3RlciBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgIGMgPSBvcHRzLnN1YnN0aXR1dGVzW2NdIHx8IGM7XG4gICAgICAgICAgICBtYXNrc2V0LndyaXRlT3V0QnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWxSZXN1bHQgPSBpc1ZhbGlkLmNhbGwoaW5wdXRtYXNrLCBwb3MsIGMsIHN0cmljdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2hlY2t2YWwpO1xuICAgICAgICAgICAgaWYgKHZhbFJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXNldE1hc2tTZXQuY2FsbChpbnB1dG1hc2ssIHRydWUpO1xuICAgICAgICAgICAgICAgIGZvcndhcmRQb3NpdGlvbiA9IHZhbFJlc3VsdC5jYXJldCAhPT0gdW5kZWZpbmVkID8gdmFsUmVzdWx0LmNhcmV0IDogc2Vla05leHQuY2FsbChpbnB1dG1hc2ssIHZhbFJlc3VsdC5wb3MuYmVnaW4gPyB2YWxSZXN1bHQucG9zLmJlZ2luIDogdmFsUmVzdWx0LnBvcyk7XG4gICAgICAgICAgICAgICAgbWFza3NldC5wID0gZm9yd2FyZFBvc2l0aW9uOyAvL25lZWRlZCBmb3IgY2hlY2t2YWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yd2FyZFBvc2l0aW9uID0gKChvcHRzLm51bWVyaWNJbnB1dCAmJiB2YWxSZXN1bHQuY2FyZXQgPT09IHVuZGVmaW5lZCkgPyBzZWVrUHJldmlvdXMuY2FsbChpbnB1dG1hc2ssIGZvcndhcmRQb3NpdGlvbikgOiBmb3J3YXJkUG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHdyaXRlT3V0ICE9PSBmYWxzZSkge1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMub25LZXlWYWxpZGF0aW9uLmNhbGwoaW5wdXQsIGMsIHZhbFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tzZXQud3JpdGVPdXRCdWZmZXIgJiYgdmFsUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCdWZmZXIoaW5wdXQsIGJ1ZmZlciwgZm9yd2FyZFBvc2l0aW9uLCBlLCBjaGVja3ZhbCAhPT0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChjaGVja3ZhbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWxSZXN1bHQgIT09IGZhbHNlKSB2YWxSZXN1bHQuZm9yd2FyZFBvc2l0aW9uID0gZm9yd2FyZFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHBhc3RlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMuaW5wdXRtYXNrLCBvcHRzID0gaW5wdXRtYXNrLm9wdHM7XG5cbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dG1hc2suX3ZhbHVlR2V0KHRydWUpLFxuICAgICAgICAgICAgY2FyZXRQb3MgPSBjYXJldC5jYWxsKGlucHV0bWFzaywgaW5wdXQpLFxuICAgICAgICAgICAgdGVtcFZhbHVlO1xuXG4gICAgICAgIGlmIChpbnB1dG1hc2suaXNSVEwpIHtcbiAgICAgICAgICAgIHRlbXBWYWx1ZSA9IGNhcmV0UG9zLmVuZDtcbiAgICAgICAgICAgIGNhcmV0UG9zLmVuZCA9IHRyYW5zbGF0ZVBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCBjYXJldFBvcy5iZWdpbik7XG4gICAgICAgICAgICBjYXJldFBvcy5iZWdpbiA9IHRyYW5zbGF0ZVBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCB0ZW1wVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlQmVmb3JlQ2FyZXQgPSBpbnB1dFZhbHVlLnN1YnN0cigwLCBjYXJldFBvcy5iZWdpbiksXG4gICAgICAgICAgICB2YWx1ZUFmdGVyQ2FyZXQgPSBpbnB1dFZhbHVlLnN1YnN0cihjYXJldFBvcy5lbmQsIGlucHV0VmFsdWUubGVuZ3RoKTtcblxuICAgICAgICBpZiAodmFsdWVCZWZvcmVDYXJldCA9PSAoaW5wdXRtYXNrLmlzUlRMID8gZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpbnB1dG1hc2spLnNsaWNlKCkucmV2ZXJzZSgpIDogZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpbnB1dG1hc2spKS5zbGljZSgwLCBjYXJldFBvcy5iZWdpbikuam9pbihcIlwiKSkgdmFsdWVCZWZvcmVDYXJldCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZUFmdGVyQ2FyZXQgPT0gKGlucHV0bWFzay5pc1JUTCA/IGdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoaW5wdXRtYXNrKS5zbGljZSgpLnJldmVyc2UoKSA6IGdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoaW5wdXRtYXNrKSkuc2xpY2UoY2FyZXRQb3MuZW5kKS5qb2luKFwiXCIpKSB2YWx1ZUFmdGVyQ2FyZXQgPSBcIlwiO1xuXG4gICAgICAgIGlmICh3aW5kb3cuY2xpcGJvYXJkRGF0YSAmJiB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKSB7IC8vIElFXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gdmFsdWVCZWZvcmVDYXJldCArIHdpbmRvdy5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpICsgdmFsdWVBZnRlckNhcmV0O1xuICAgICAgICB9IGVsc2UgaWYgKGUuY2xpcGJvYXJkRGF0YSAmJiBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHZhbHVlQmVmb3JlQ2FyZXQgKyBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgKyB2YWx1ZUFmdGVyQ2FyZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvL2FsbG93IG5hdGl2ZSBwYXN0ZSBldmVudCBhcyBmYWxsYmFjayB+IG1hc2tpbmcgd2lsbCBjb250aW51ZSBieSBpbnB1dGZhbGxiYWNrXG5cbiAgICAgICAgdmFyIHBhc3RlVmFsdWUgPSBpbnB1dFZhbHVlO1xuICAgICAgICBpZiAoaW5wdXRtYXNrLmlzUlRMKSB7XG4gICAgICAgICAgICBwYXN0ZVZhbHVlID0gcGFzdGVWYWx1ZS5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpbnB1dG1hc2spKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3RlVmFsdWVbMF0gPT09IGMpXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlVmFsdWUuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhc3RlVmFsdWUgPSBwYXN0ZVZhbHVlLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uQmVmb3JlUGFzdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcGFzdGVWYWx1ZSA9IG9wdHMub25CZWZvcmVQYXN0ZS5jYWxsKGlucHV0bWFzaywgcGFzdGVWYWx1ZSwgb3B0cyk7XG4gICAgICAgICAgICBpZiAocGFzdGVWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhc3RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwYXN0ZVZhbHVlID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbChpbnB1dCwgdHJ1ZSwgZmFsc2UsIHBhc3RlVmFsdWUudG9TdHJpbmcoKS5zcGxpdChcIlwiKSwgZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuICAgIGlucHV0RmFsbEJhY2tFdmVudDogZnVuY3Rpb24gKGUpIHsgLy9mYWxsYmFjayB3aGVuIGtleXByZXNzIGlzIG5vdCB0cmlnZ2VyZWRcbiAgICAgICAgY29uc3QgaW5wdXRtYXNrID0gdGhpcy5pbnB1dG1hc2ssIG9wdHMgPSBpbnB1dG1hc2sub3B0cywgJCA9IGlucHV0bWFzay5kZXBlbmRlbmN5TGliO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhlLmlucHV0VHlwZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gYW5hbHlzZUNoYW5nZXMoaW5wdXRWYWx1ZSwgYnVmZmVyLCBjYXJldFBvcykge1xuICAgICAgICAgICAgdmFyIGZyb250UGFydCA9IGlucHV0VmFsdWUuc3Vic3RyKDAsIGNhcmV0UG9zLmJlZ2luKS5zcGxpdChcIlwiKSxcbiAgICAgICAgICAgICAgICBiYWNrUGFydCA9IGlucHV0VmFsdWUuc3Vic3RyKGNhcmV0UG9zLmJlZ2luKS5zcGxpdChcIlwiKSxcbiAgICAgICAgICAgICAgICBmcm9udEJ1ZmZlclBhcnQgPSBidWZmZXIuc3Vic3RyKDAsIGNhcmV0UG9zLmJlZ2luKS5zcGxpdChcIlwiKSxcbiAgICAgICAgICAgICAgICBiYWNrQnVmZmVyUGFydCA9IGJ1ZmZlci5zdWJzdHIoY2FyZXRQb3MuYmVnaW4pLnNwbGl0KFwiXCIpO1xuXG4gICAgICAgICAgICB2YXIgZnBsID0gZnJvbnRQYXJ0Lmxlbmd0aCA+PSBmcm9udEJ1ZmZlclBhcnQubGVuZ3RoID8gZnJvbnRQYXJ0Lmxlbmd0aCA6IGZyb250QnVmZmVyUGFydC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYnBsID0gYmFja1BhcnQubGVuZ3RoID49IGJhY2tCdWZmZXJQYXJ0Lmxlbmd0aCA/IGJhY2tQYXJ0Lmxlbmd0aCA6IGJhY2tCdWZmZXJQYXJ0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBibCwgaSwgYWN0aW9uID0gXCJcIiwgZGF0YSA9IFtdLCBtYXJrZXIgPSBcIn5cIiwgcGxhY2Vob2xkZXI7XG5cbiAgICAgICAgICAgIC8vYWxpZ24gYnVmZmVyc1xuICAgICAgICAgICAgd2hpbGUgKGZyb250UGFydC5sZW5ndGggPCBmcGwpIGZyb250UGFydC5wdXNoKG1hcmtlcik7XG4gICAgICAgICAgICB3aGlsZSAoZnJvbnRCdWZmZXJQYXJ0Lmxlbmd0aCA8IGZwbCkgZnJvbnRCdWZmZXJQYXJ0LnB1c2gobWFya2VyKTtcbiAgICAgICAgICAgIHdoaWxlIChiYWNrUGFydC5sZW5ndGggPCBicGwpIGJhY2tQYXJ0LnVuc2hpZnQobWFya2VyKTtcbiAgICAgICAgICAgIHdoaWxlIChiYWNrQnVmZmVyUGFydC5sZW5ndGggPCBicGwpIGJhY2tCdWZmZXJQYXJ0LnVuc2hpZnQobWFya2VyKTtcblxuICAgICAgICAgICAgdmFyIG5ld0J1ZmZlciA9IGZyb250UGFydC5jb25jYXQoYmFja1BhcnQpO1xuICAgICAgICAgICAgdmFyIG9sZEJ1ZmZlciA9IGZyb250QnVmZmVyUGFydC5jb25jYXQoYmFja0J1ZmZlclBhcnQpO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk4gXCIgKyBuZXdCdWZmZXIpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJPIFwiICsgb2xkQnVmZmVyKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgYmwgPSBuZXdCdWZmZXIubGVuZ3RoOyBpIDwgYmw7IGkrKykge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0UGxhY2Vob2xkZXIuY2FsbChpbnB1dG1hc2ssIHRyYW5zbGF0ZVBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCBpKSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc2VydFRleHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRCdWZmZXJbaSAtIDFdID09PSBuZXdCdWZmZXJbaV0gJiYgY2FyZXRQb3MuYmVnaW4gPT0gbmV3QnVmZmVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gobmV3QnVmZmVyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBibDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3QnVmZmVyW2ldID09PSBtYXJrZXIpIHsgLy9leHRlbmQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3MuZW5kKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrb3V0IGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gYmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0J1ZmZlcltpXSA9PT0gbWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3MuZW5kKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYnJlYWtvdXQgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBibDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0J1ZmZlcltpXSAhPT0gb2xkQnVmZmVyW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChuZXdCdWZmZXJbaSArIDFdID09PSBtYXJrZXIgfHwgbmV3QnVmZmVyW2kgKyAxXSA9PT0gcGxhY2Vob2xkZXIgfHwgbmV3QnVmZmVyW2kgKyAxXSA9PT0gdW5kZWZpbmVkKSAmJiAoKG9sZEJ1ZmZlcltpXSA9PT0gcGxhY2Vob2xkZXIgJiYgb2xkQnVmZmVyW2kgKyAxXSA9PT0gbWFya2VyKSB8fCBvbGRCdWZmZXJbaV0gPT09IG1hcmtlcikpIHsgIC8vYmFzaWMgaW5zZXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IFwiaW5zZXJ0VGV4dFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gobmV3QnVmZmVyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3MuYmVnaW4tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3MuZW5kLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRCdWZmZXJbaSArIDFdID09PSBtYXJrZXIgJiYgb2xkQnVmZmVyW2ldID09PSBuZXdCdWZmZXJbaSArIDFdKSB7IC8vaW5zZXJ0IGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gXCJpbnNlcnRUZXh0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChuZXdCdWZmZXJbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvcy5iZWdpbi0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvcy5lbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld0J1ZmZlcltpXSAhPT0gcGxhY2Vob2xkZXIgJiYgbmV3QnVmZmVyW2ldICE9PSBtYXJrZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5ld0J1ZmZlcltpICsgMV0gPT09IG1hcmtlciB8fCAob2xkQnVmZmVyW2ldICE9PSBuZXdCdWZmZXJbaV0gJiYgb2xkQnVmZmVyW2kgKyAxXSA9PT0gbmV3QnVmZmVyW2kgKyAxXSAvKnNpbmdsZSBjaGFyIHJlcGxhY2VtZW50Ki8pKSkgeyAvL3JlcGxhY2Ugc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChuZXdCdWZmZXJbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvcy5iZWdpbi0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3QnVmZmVyW2ldID09PSBtYXJrZXIpIHsgIC8vZGVsZXRlfmJhY2tzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXNrLmNhbGwoaW5wdXRtYXNrLCB0cmFuc2xhdGVQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywgaSksIHRydWUpIHx8IG9sZEJ1ZmZlcltpXSA9PT0gb3B0cy5yYWRpeFBvaW50KSBjYXJldFBvcy5lbmQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gYmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgY2FyZXQ6IGNhcmV0UG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dC5pbnB1dG1hc2suX3ZhbHVlR2V0KHRydWUpLFxuICAgICAgICAgICAgYnVmZmVyID0gKGlucHV0bWFzay5pc1JUTCA/IGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzaykuc2xpY2UoKS5yZXZlcnNlKCkgOiBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spKS5qb2luKFwiXCIpLFxuICAgICAgICAgICAgY2FyZXRQb3MgPSBjYXJldC5jYWxsKGlucHV0bWFzaywgaW5wdXQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKSxcbiAgICAgICAgICAgIGNoYW5nZXM7XG5cbiAgICAgICAgaWYgKGJ1ZmZlciAhPT0gaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgY2hhbmdlcyA9IGFuYWx5c2VDaGFuZ2VzKGlucHV0VmFsdWUsIGJ1ZmZlciwgY2FyZXRQb3MpO1xuICAgICAgICAgICAgaWYgKChpbnB1dC5pbnB1dG1hc2suc2hhZG93Um9vdCB8fCBpbnB1dC5vd25lckRvY3VtZW50KS5hY3RpdmVFbGVtZW50ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZUJ1ZmZlcihpbnB1dCwgZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKSk7XG4gICAgICAgICAgICBjYXJldC5jYWxsKGlucHV0bWFzaywgaW5wdXQsIGNhcmV0UG9zLmJlZ2luLCBjYXJldFBvcy5lbmQsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBKYXBhbmVzZSBJTUUgaGFjayAjMjY2MlxuICAgICAgICAgICAgaWYgKCFtb2JpbGUgJiYgaW5wdXRtYXNrLnNraXBOZXh0SW5zZXJ0ICYmIGUuaW5wdXRUeXBlID09PSBcImluc2VydFRleHRcIiAmJiBjaGFuZ2VzLmFjdGlvbiA9PT0gXCJpbnNlcnRUZXh0XCIgJiYgaW5wdXRtYXNrLmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuaW5wdXRUeXBlID09PSBcImluc2VydENvbXBvc2l0aW9uVGV4dFwiICYmIGNoYW5nZXMuYWN0aW9uID09PSBcImluc2VydFRleHRcIiAmJiBpbnB1dG1hc2suaXNDb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICBpbnB1dG1hc2suc2tpcE5leHRJbnNlcnQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dG1hc2suc2tpcE5leHRJbnNlcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChjaGFuZ2VzLmFjdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnNlcnRUZXh0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIG5keCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXByZXNzID0gbmV3ICQuRXZlbnQoXCJrZXlwcmVzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXByZXNzLmtleSA9IGVudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRtYXNrLmlnbm9yYWJsZSA9IGZhbHNlOyAvL21ha2Ugc3VyZSBpZ25vcmFibGUgaXMgaWdub3JlZCA7LSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEV2ZW50SGFuZGxlcnMua2V5cHJlc3NFdmVudC5jYWxsKGlucHV0LCBrZXlwcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgIC8vIzIxOTUgdHJpZ2dlciBrZXl1cCB0byBoZWxwIHNvbWUgb3RoZXIgcGx1Z2lucyB0byB0cmFjayBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1hc2suJGVsLnRyaWdnZXIoXCJrZXl1cFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50QmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleWRvd24gPSBuZXcgJC5FdmVudChcImtleWRvd25cIik7XG4gICAgICAgICAgICAgICAgICAgIGtleWRvd24ua2V5ID0ga2V5cy5CYWNrc3BhY2U7XG4gICAgICAgICAgICAgICAgICAgIEV2ZW50SGFuZGxlcnMua2V5RXZlbnQuY2FsbChpbnB1dCwga2V5ZG93bik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5SW5wdXRWYWx1ZShpbnB1dCwgaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LmNhbGwoaW5wdXRtYXNrLCBpbnB1dCwgY2FyZXRQb3MuYmVnaW4sIGNhcmV0UG9zLmVuZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldFZhbHVlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMuaW5wdXRtYXNrO1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLFxuICAgICAgICAgICAgdmFsdWUgPSAoZSAmJiBlLmRldGFpbCkgPyBlLmRldGFpbFswXSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBpbnB1dC5pbnB1dG1hc2suX3ZhbHVlR2V0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHlJbnB1dFZhbHVlKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKChlLmRldGFpbCAmJiBlLmRldGFpbFsxXSAhPT0gdW5kZWZpbmVkKSB8fCBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FyZXQuY2FsbChpbnB1dG1hc2ssIGlucHV0LCBlLmRldGFpbCA/IGUuZGV0YWlsWzFdIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAsXG4gICAgZm9jdXNFdmVudDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3QgaW5wdXRtYXNrID0gdGhpcy5pbnB1dG1hc2ssIG9wdHMgPSBpbnB1dG1hc2sub3B0cztcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcyxcbiAgICAgICAgICAgIG5wdFZhbHVlID0gaW5wdXRtYXNrPy5fdmFsdWVHZXQoKTtcblxuICAgICAgICBpZiAob3B0cy5zaG93TWFza09uRm9jdXMpIHtcbiAgICAgICAgICAgIGlmIChucHRWYWx1ZSAhPT0gZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKS5qb2luKFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVCdWZmZXIoaW5wdXQsIGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzayksIHNlZWtOZXh0LmNhbGwoaW5wdXRtYXNrLCBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaykpKTtcbiAgICAgICAgICAgIH0gLyplbHNlIGlmIChtb3VzZUVudGVyID09PSBmYWxzZSkgeyAvL29ubHkgZXhlY3V0ZWQgb24gZm9jdXMgd2l0aG91dCBtb3VzZWVudGVyXG5cdFx0XHRcdFx0Y2FyZXQoaW5wdXQsIHNlZWtOZXh0KGdldExhc3RWYWxpZFBvc2l0aW9uKCkpKTtcblx0XHRcdFx0fSovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucG9zaXRpb25DYXJldE9uVGFiID09PSB0cnVlICYmIGlucHV0bWFzay5tb3VzZUVudGVyID09PSBmYWxzZSAmJiAoIWlzQ29tcGxldGUuY2FsbChpbnB1dG1hc2ssIGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzaykpIHx8IGdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICBFdmVudEhhbmRsZXJzLmNsaWNrRXZlbnQuYXBwbHkoaW5wdXQsIFtlLCB0cnVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRtYXNrLnVuZG9WYWx1ZSA9IGlucHV0bWFzaz8uX3ZhbHVlR2V0KHRydWUpO1xuICAgIH0sXG4gICAgaW52YWxpZEV2ZW50OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmlucHV0bWFzay52YWxpZGF0aW9uRXZlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbW91c2VsZWF2ZUV2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMuaW5wdXRtYXNrLCBvcHRzID0gaW5wdXRtYXNrLm9wdHM7XG5cbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcztcbiAgICAgICAgaW5wdXRtYXNrLm1vdXNlRW50ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdHMuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgJiYgKGlucHV0LmlucHV0bWFzay5zaGFkb3dSb290IHx8IGlucHV0Lm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICBIYW5kbGVOYXRpdmVQbGFjZWhvbGRlcihpbnB1dCwgaW5wdXRtYXNrLm9yaWdpbmFsUGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjbGlja0V2ZW50OiBmdW5jdGlvbiAoZSwgdGFiYmVkKSB7XG4gICAgICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMuaW5wdXRtYXNrO1xuICAgICAgICBpbnB1dG1hc2suY2xpY2tlZCsrO1xuXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXM7XG4gICAgICAgIGlmICgoaW5wdXQuaW5wdXRtYXNrLnNoYWRvd1Jvb3QgfHwgaW5wdXQub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCA9PT0gaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBuZXdDYXJldFBvc2l0aW9uID0gZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywgY2FyZXQuY2FsbChpbnB1dG1hc2ssIGlucHV0KSwgdGFiYmVkKTtcbiAgICAgICAgICAgIGlmIChuZXdDYXJldFBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjYXJldC5jYWxsKGlucHV0bWFzaywgaW5wdXQsIG5ld0NhcmV0UG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjdXRFdmVudDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3QgaW5wdXRtYXNrID0gdGhpcy5pbnB1dG1hc2ssIG1hc2tzZXQgPSBpbnB1dG1hc2subWFza3NldDtcblxuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLFxuICAgICAgICAgICAgcG9zID0gY2FyZXQuY2FsbChpbnB1dG1hc2ssIGlucHV0KTtcblxuICAgICAgICAvL2NvcnJlY3QgY2xpcGJvYXJkRGF0YVxuICAgICAgICB2YXIgY2xpcERhdGEgPSBpbnB1dG1hc2suaXNSVEwgPyBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLnNsaWNlKHBvcy5lbmQsIHBvcy5iZWdpbikgOiBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLnNsaWNlKHBvcy5iZWdpbiwgcG9zLmVuZCksXG4gICAgICAgICAgICBjbGlwRGF0YVRleHQgPSBpbnB1dG1hc2suaXNSVEwgPyBjbGlwRGF0YS5yZXZlcnNlKCkuam9pbihcIlwiKSA6IGNsaXBEYXRhLmpvaW4oXCJcIik7XG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZCkgd2luZG93Lm5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGNsaXBEYXRhVGV4dCk7XG4gICAgICAgIGVsc2UgaWYgKHdpbmRvdy5jbGlwYm9hcmREYXRhICYmIHdpbmRvdy5jbGlwYm9hcmREYXRhLmdldERhdGEpIHsgLy8gSUVcbiAgICAgICAgICAgIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsIGNsaXBEYXRhVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlUmVtb3ZlLmNhbGwoaW5wdXRtYXNrLCBpbnB1dCwga2V5cy5EZWxldGUsIHBvcyk7XG4gICAgICAgIHdyaXRlQnVmZmVyKGlucHV0LCBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLCBtYXNrc2V0LnAsIGUsIGlucHV0bWFzay51bmRvVmFsdWUgIT09IGlucHV0bWFzay5fdmFsdWVHZXQodHJ1ZSkpO1xuICAgIH0sXG4gICAgYmx1ckV2ZW50OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLmlucHV0bWFzaywgb3B0cyA9IGlucHV0bWFzay5vcHRzLCAkID0gaW5wdXRtYXNrLmRlcGVuZGVuY3lMaWI7XG4gICAgICAgIGlucHV0bWFzay5jbGlja2VkID0gMDtcblxuICAgICAgICB2YXIgJGlucHV0ID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGlucHV0ID0gdGhpcztcbiAgICAgICAgaWYgKGlucHV0LmlucHV0bWFzaykge1xuICAgICAgICAgICAgSGFuZGxlTmF0aXZlUGxhY2Vob2xkZXIoaW5wdXQsIGlucHV0bWFzay5vcmlnaW5hbFBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHZhciBucHRWYWx1ZSA9IGlucHV0LmlucHV0bWFzay5fdmFsdWVHZXQoKSxcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGlmIChucHRWYWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmNsZWFyTWFza09uTG9zdEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaykgPT09IC0xICYmIG5wdFZhbHVlID09PSBnZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaykuam9pbihcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vY2xlYXJvdXQgb3B0aW9uYWwgdGFpbCBvZiB0aGUgbWFza1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJPcHRpb25hbFRhaWwuY2FsbChpbnB1dG1hc2ssIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcGxldGUuY2FsbChpbnB1dG1hc2ssIGJ1ZmZlcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LnRyaWdnZXIoXCJpbmNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuY2xlYXJJbmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldE1hc2tTZXQuY2FsbChpbnB1dG1hc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuY2xlYXJNYXNrT25Mb3N0Rm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpbnB1dG1hc2spLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdyaXRlQnVmZmVyKGlucHV0LCBidWZmZXIsIHVuZGVmaW5lZCwgZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnB1dG1hc2sudW5kb1ZhbHVlICE9PSBpbnB1dG1hc2suX3ZhbHVlR2V0KHRydWUpKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRtYXNrLnVuZG9WYWx1ZSA9IGlucHV0bWFzay5fdmFsdWVHZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgJGlucHV0LnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLFxuICAgIG1vdXNlZW50ZXJFdmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLmlucHV0bWFzaywge3Nob3dNYXNrT25Ib3Zlcn0gPSBpbnB1dG1hc2sub3B0cztcblxuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzO1xuICAgICAgICBpbnB1dG1hc2subW91c2VFbnRlciA9IHRydWU7XG4gICAgICAgIGlmICgoaW5wdXQuaW5wdXRtYXNrLnNoYWRvd1Jvb3QgfHwgaW5wdXQub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXJUZW1wbGF0ZSA9IChpbnB1dG1hc2suaXNSVEwgPyBnZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaykuc2xpY2UoKS5yZXZlcnNlKCkgOiBnZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaykpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICBpZiAoc2hvd01hc2tPbkhvdmVyKSB7XG4gICAgICAgICAgICAgICAgSGFuZGxlTmF0aXZlUGxhY2Vob2xkZXIoaW5wdXQsIGJ1ZmZlclRlbXBsYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAsXG4gICAgc3VibWl0RXZlbnQ6IGZ1bmN0aW9uICgpIHsgLy90cmlnZ2VyIGNoYW5nZSBvbiBzdWJtaXQgaWYgYW55XG4gICAgICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMuaW5wdXRtYXNrLCBvcHRzID0gaW5wdXRtYXNrLm9wdHM7XG5cbiAgICAgICAgaWYgKGlucHV0bWFzay51bmRvVmFsdWUgIT09IGlucHV0bWFzay5fdmFsdWVHZXQodHJ1ZSkpIHtcbiAgICAgICAgICAgIGlucHV0bWFzay4kZWwudHJpZ2dlcihcImNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoLypvcHRzLmNsZWFyTWFza09uTG9zdEZvY3VzICYmICovZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChpbnB1dG1hc2spID09PSAtMSAmJiBpbnB1dG1hc2suX3ZhbHVlR2V0ICYmIGlucHV0bWFzay5fdmFsdWVHZXQoKSA9PT0gZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpbnB1dG1hc2spLmpvaW4oXCJcIikpIHtcbiAgICAgICAgICAgIGlucHV0bWFzay5fdmFsdWVTZXQoXCJcIik7IC8vY2xlYXIgbWFza3RlbXBsZXRlIG9uIHN1Ym1pdCBhbmQgc3RpbGwgaGFzIGZvY3VzXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuY2xlYXJJbmNvbXBsZXRlICYmIGlzQ29tcGxldGUuY2FsbChpbnB1dG1hc2ssIGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzaykpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaW5wdXRtYXNrLl92YWx1ZVNldChcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yZW1vdmVNYXNrT25TdWJtaXQpIHtcbiAgICAgICAgICAgIGlucHV0bWFzay5fdmFsdWVTZXQoaW5wdXRtYXNrLnVubWFza2VkdmFsdWUoKSwgdHJ1ZSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlcihpbnB1dG1hc2suZWwsIGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzaykpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLFxuICAgIHJlc2V0RXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgaW5wdXRtYXNrID0gdGhpcy5pbnB1dG1hc2s7XG5cbiAgICAgICAgaW5wdXRtYXNrLnJlZnJlc2hWYWx1ZSA9IHRydWU7IC8vaW5kaWNhdGUgYSBmb3JjZWQgcmVmcmVzaCB3aGVuIHRoZXJlIGlzIGEgY2FsbCB0byB0aGUgdmFsdWUgYmVmb3JlIGxlYXZpbmcgdGhlIHRyaWdnZXJpbmcgZXZlbnQgZm5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcHBseUlucHV0VmFsdWUoaW5wdXRtYXNrLmVsLCBpbnB1dG1hc2suX3ZhbHVlR2V0KHRydWUpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxufTtcbiIsImltcG9ydCBJbnB1dG1hc2sgZnJvbSBcIi4vaW5wdXRtYXNrXCI7XG5pbXBvcnQge2tleXN9IGZyb20gXCIuL2tleWNvZGUuanNcIjtcbmltcG9ydCB7Z2V0QnVmZmVyVGVtcGxhdGV9IGZyb20gXCIuL3Bvc2l0aW9uaW5nXCI7XG5pbXBvcnQge0hhbmRsZU5hdGl2ZVBsYWNlaG9sZGVyfSBmcm9tIFwiLi9pbnB1dEhhbmRsaW5nXCI7XG5cbmV4cG9ydCB7RXZlbnRSdWxlcn07XG5cbnZhciBFdmVudFJ1bGVyID0ge1xuICAgIG9uOiBmdW5jdGlvbiAoaW5wdXQsIGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0ICQgPSBpbnB1dC5pbnB1dG1hc2suZGVwZW5kZW5jeUxpYjtcblxuICAgICAgICB2YXIgZXYgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgICAgIGUgPSBlLm9yaWdpbmFsRXZlbnQgfHwgZTsgLy9nZXQgb3JpZ2luYWwgZXZlbnQgZnJvbSBqcXVlcnkgZXZlbmJ0XG4gICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGUudHlwZSk7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIGFyZ3MsIGlucHV0bWFzayA9IHRoYXQuaW5wdXRtYXNrLCBvcHRzID0gaW5wdXRtYXNrID8gaW5wdXRtYXNrLm9wdHMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaW5wdXRtYXNrID09PSB1bmRlZmluZWQgJiYgdGhpcy5ub2RlTmFtZSAhPT0gXCJGT1JNXCIpIHsgLy9oYXBwZW5zIHdoZW4gY2xvbmluZyBhbiBvYmplY3Qgd2l0aCBqcXVlcnkuY2xvbmVcbiAgICAgICAgICAgICAgICB2YXIgaW1PcHRzID0gJC5kYXRhKHRoYXQsIFwiX2lucHV0bWFza19vcHRzXCIpO1xuICAgICAgICAgICAgICAgICQodGhhdCkub2ZmKCk7IC8vdW5iaW5kIGFsbCBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAoaW1PcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIChuZXcgSW5wdXRtYXNrKGltT3B0cykpLm1hc2sodGhhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghW1wic3VibWl0XCIsIFwicmVzZXRcIiwgXCJzZXR2YWx1ZVwiXS5pbmNsdWRlcyhlLnR5cGUpICYmIHRoaXMubm9kZU5hbWUgIT09IFwiRk9STVwiICYmICh0aGF0LmRpc2FibGVkIHx8ICh0aGF0LnJlYWRPbmx5ICYmICEoZS50eXBlID09PSBcImtleWRvd25cIiAmJiAoZS5jdHJsS2V5ICYmIGUua2V5ID09PSBrZXlzLmMpIHx8IChvcHRzLnRhYlRocm91Z2ggPT09IGZhbHNlICYmIGUua2V5ID09PSBrZXlzLlRhYikpKSkpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0bWFzay5za2lwSW5wdXRFdmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0bWFzay5za2lwSW5wdXRFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChtb2JpbGUpIHsgLy90aGlzIGNhdXNlcyBwcm9ibGVtIHNlZSAjMjIyMFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXHRhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgLy9uZWVkZWQgZm9yIGNhcmV0IHNlbGVjdGlvbiB3aGVuIGVudGVyaW5nIGEgY2hhciBvbiBBbmRyb2lkIDggLSAjMTgxOFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXHRcdGV2ZW50SGFuZGxlci5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFx0XHRjYXJldCh0aGF0LCB0aGF0LmlucHV0bWFzay5jYXJldFBvcywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFx0fSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcdHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2xpY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvY3VzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRtYXNrLnZhbGlkYXRpb25FdmVudCkgeyAvLyAjODQxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRtYXNrLnZhbGlkYXRpb25FdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIYW5kbGVOYXRpdmVQbGFjZWhvbGRlcihpbnB1dCwgKGlucHV0bWFzay5pc1JUTCA/IGdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoaW5wdXRtYXNrKS5zbGljZSgpLnJldmVyc2UoKSA6IGdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoaW5wdXRtYXNrKSkuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0cy52YWxpZGF0aW9uRXZlbnRUaW1lT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IC8vbmVlZGVkIGZvciBDaHJvbWUgfiBpbml0aWFsIHNlbGVjdGlvbiBjbGVhcnMgYWZ0ZXIgdGhlIGNsaWNrZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmlucHV0bWFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgaW5wdXRtYXNrLnJlbW92ZSgpYCB3YXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLypmYWxzZSovOyAvLyMyNDIzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWwgPSBldmVudEhhbmRsZXIuYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChbXCJzdWJtaXRcIiwgXCJyZXNldFwiXS5pbmNsdWRlcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBldiA9IGV2LmJpbmQoaW5wdXQpOyAvL2JpbmQgY3JlYXRlcyBhIG5ldyBldmVudGhhbmRsZXIgKHdyYXApXG4gICAgICAgICAgICBpZiAoaW5wdXQuZm9ybSAhPT0gbnVsbCkgJChpbnB1dC5mb3JtKS5vbihldmVudE5hbWUsIGV2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQoaW5wdXQpLm9uKGV2ZW50TmFtZSwgZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9rZWVwIGluc3RhbmNlIG9mIHRoZSBldmVudFxuICAgICAgICBpbnB1dC5pbnB1dG1hc2suZXZlbnRzW2V2ZW50TmFtZV0gPSBpbnB1dC5pbnB1dG1hc2suZXZlbnRzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgICAgIGlucHV0LmlucHV0bWFzay5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGV2KTtcblxuICAgIH0sXG4gICAgb2ZmOiBmdW5jdGlvbiAoaW5wdXQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChpbnB1dC5pbnB1dG1hc2sgJiYgaW5wdXQuaW5wdXRtYXNrLmV2ZW50cykge1xuICAgICAgICAgICAgY29uc3QgJCA9IGlucHV0LmlucHV0bWFzay5kZXBlbmRlbmN5TGliO1xuICAgICAgICAgICAgbGV0IGV2ZW50cyA9IGlucHV0LmlucHV0bWFzay5ldmVudHM7XG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBldmVudHNbZXZlbnRdID0gaW5wdXQuaW5wdXRtYXNrLmV2ZW50c1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV2QXJyID0gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKGV2QXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ID0gZXZBcnIucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbXCJzdWJtaXRcIiwgXCJyZXNldFwiLF0uaW5jbHVkZXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmZvcm0gIT09IG51bGwpICQoaW5wdXQuZm9ybSkub2ZmKGV2ZW50TmFtZSwgZXYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChpbnB1dCkub2ZmKGV2ZW50TmFtZSwgZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnB1dC5pbnB1dG1hc2suZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiaW1wb3J0IGNhblVzZURPTSBmcm9tIFwiLi4vY2FuVXNlRE9NXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNhblVzZURPTSA/IHdpbmRvdyA6IHt9O1xuIiwiaW1wb3J0IHtrZXlzfSBmcm9tIFwiLi9rZXljb2RlLmpzXCI7XG5pbXBvcnQge2dldE1hc2tUZW1wbGF0ZSwgZ2V0UGxhY2Vob2xkZXIsIGdldFRlc3R9IGZyb20gXCIuL3ZhbGlkYXRpb24tdGVzdHNcIjtcbmltcG9ydCB7XG4gICAgY2FyZXQsXG4gICAgZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbixcbiAgICBnZXRCdWZmZXIsIGdldEJ1ZmZlclRlbXBsYXRlLFxuICAgIGdldExhc3RWYWxpZFBvc2l0aW9uLFxuICAgIGlzTWFzayxcbiAgICByZXNldE1hc2tTZXQsXG4gICAgc2Vla05leHRcbn0gZnJvbSBcIi4vcG9zaXRpb25pbmdcIjtcbmltcG9ydCB7aXNDb21wbGV0ZSwgcmVmcmVzaEZyb21CdWZmZXJ9IGZyb20gXCIuL3ZhbGlkYXRpb25cIjtcbmltcG9ydCB7aWV9IGZyb20gXCIuL2Vudmlyb25tZW50XCI7XG5pbXBvcnQge0V2ZW50SGFuZGxlcnN9IGZyb20gXCIuL2V2ZW50aGFuZGxlcnNcIjtcblxuXG5leHBvcnQge2FwcGx5SW5wdXRWYWx1ZSwgY2xlYXJPcHRpb25hbFRhaWwsIGNoZWNrVmFsLCBIYW5kbGVOYXRpdmVQbGFjZWhvbGRlciwgdW5tYXNrZWR2YWx1ZSwgd3JpdGVCdWZmZXJ9O1xuXG5mdW5jdGlvbiBhcHBseUlucHV0VmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgY29uc3QgaW5wdXRtYXNrID0gaW5wdXQgPyBpbnB1dC5pbnB1dG1hc2sgOiB0aGlzLCBvcHRzID0gaW5wdXRtYXNrLm9wdHM7XG5cbiAgICBpbnB1dC5pbnB1dG1hc2sucmVmcmVzaFZhbHVlID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBvcHRzLm9uQmVmb3JlTWFzayA9PT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IG9wdHMub25CZWZvcmVNYXNrLmNhbGwoaW5wdXRtYXNrLCB2YWx1ZSwgb3B0cykgfHwgdmFsdWU7XG4gICAgdmFsdWUgPSAodmFsdWUgfHwgXCJcIikudG9TdHJpbmcoKS5zcGxpdChcIlwiKTtcbiAgICBjaGVja1ZhbChpbnB1dCwgdHJ1ZSwgZmFsc2UsIHZhbHVlKTtcbiAgICBpbnB1dG1hc2sudW5kb1ZhbHVlID0gaW5wdXRtYXNrLl92YWx1ZUdldCh0cnVlKTtcbiAgICBpZiAoKG9wdHMuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgfHwgb3B0cy5jbGVhckluY29tcGxldGUpICYmIGlucHV0LmlucHV0bWFzay5fdmFsdWVHZXQoKSA9PT0gZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChpbnB1dG1hc2spLmpvaW4oXCJcIikgJiYgZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChpbnB1dG1hc2spID09PSAtMSkge1xuICAgICAgICBpbnB1dC5pbnB1dG1hc2suX3ZhbHVlU2V0KFwiXCIpO1xuICAgIH1cbn1cblxuLy90b2RvIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBjbGVhck9wdGlvbmFsVGFpbChidWZmZXIpIHtcbiAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzO1xuXG4gICAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgdmFyIHRlbXBsYXRlID0gZ2V0TWFza1RlbXBsYXRlLmNhbGwoaW5wdXRtYXNrLCB0cnVlLCAwLCB0cnVlLCB1bmRlZmluZWQsIHRydWUpLCBsbW50O1xuICAgIHdoaWxlICgobG1udCA9IHRlbXBsYXRlLnNoaWZ0KCkpICE9PSB1bmRlZmluZWQpIGJ1ZmZlci5wdXNoKGxtbnQpO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsKGlucHV0LCB3cml0ZU91dCwgc3RyaWN0LCBucHR2bCwgaW5pdGlhdGluZ0V2ZW50KSB7XG4gICAgY29uc3QgaW5wdXRtYXNrID0gaW5wdXQgPyBpbnB1dC5pbnB1dG1hc2sgOiB0aGlzLFxuICAgICAgICBtYXNrc2V0ID0gaW5wdXRtYXNrLm1hc2tzZXQsXG4gICAgICAgIG9wdHMgPSBpbnB1dG1hc2sub3B0cywgJCA9IGlucHV0bWFzay5kZXBlbmRlbmN5TGliO1xuXG4gICAgdmFyIGlucHV0VmFsdWUgPSBucHR2bC5zbGljZSgpLFxuICAgICAgICBjaGFyQ29kZXMgPSBcIlwiLFxuICAgICAgICBpbml0aWFsTmR4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZCwgc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciA9IG9wdHMuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlcjtcbiAgICBvcHRzLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgPSBcIlwiOyAvL3NlZSBpc3N1ZSAjMjMxMVxuXG4gICAgZnVuY3Rpb24gaXNUZW1wbGF0ZU1hdGNoKG5keCwgY2hhckNvZGVzKSB7XG4gICAgICAgIHZhciB0YXJnZXRUZW1wbGF0ZSA9IGdldE1hc2tUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaywgdHJ1ZSwgMCkuc2xpY2UobmR4LCBzZWVrTmV4dC5jYWxsKGlucHV0bWFzaywgbmR4LCBmYWxzZSwgZmFsc2UpKS5qb2luKFwiXCIpLnJlcGxhY2UoLycvZywgXCJcIiksXG4gICAgICAgICAgICBjaGFyQ29kZU5keCA9IHRhcmdldFRlbXBsYXRlLmluZGV4T2YoY2hhckNvZGVzKTtcbiAgICAgICAgLy9zdHJpcCBzcGFjZXMgZnJvbSB0YXJnZXRUZW1wbGF0ZVxuICAgICAgICB3aGlsZSAoY2hhckNvZGVOZHggPiAwICYmIHRhcmdldFRlbXBsYXRlW2NoYXJDb2RlTmR4IC0gMV0gPT09IFwiIFwiKSBjaGFyQ29kZU5keC0tO1xuXG4gICAgICAgIHZhciBtYXRjaCA9IGNoYXJDb2RlTmR4ID09PSAwICYmICFpc01hc2suY2FsbChpbnB1dG1hc2ssIG5keClcbiAgICAgICAgICAgICYmIChnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBuZHgpLm1hdGNoLm5hdGl2ZURlZiA9PT0gY2hhckNvZGVzLmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgIHx8IChnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBuZHgpLm1hdGNoLnN0YXRpYyA9PT0gdHJ1ZSAmJiBnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBuZHgpLm1hdGNoLm5hdGl2ZURlZiA9PT0gKFwiJ1wiICsgY2hhckNvZGVzLmNoYXJBdCgwKSkpXG4gICAgICAgICAgICAgICAgfHwgKGdldFRlc3QuY2FsbChpbnB1dG1hc2ssIG5keCkubWF0Y2gubmF0aXZlRGVmID09PSBcIiBcIiAmJiAoZ2V0VGVzdC5jYWxsKGlucHV0bWFzaywgbmR4ICsgMSkubWF0Y2gubmF0aXZlRGVmID09PSBjaGFyQ29kZXMuY2hhckF0KDApXG4gICAgICAgICAgICAgICAgICAgIHx8IChnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBuZHggKyAxKS5tYXRjaC5zdGF0aWMgPT09IHRydWUgJiYgZ2V0VGVzdC5jYWxsKGlucHV0bWFzaywgbmR4ICsgMSkubWF0Y2gubmF0aXZlRGVmID09PSAoXCInXCIgKyBjaGFyQ29kZXMuY2hhckF0KDApKSkpKSk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCAmJiBjaGFyQ29kZU5keCA+IDAgJiYgIWlzTWFzay5jYWxsKGlucHV0bWFzaywgbmR4LCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UG9zID0gc2Vla05leHQuY2FsbChpbnB1dG1hc2ssIG5keCk7XG4gICAgICAgICAgICBpZiAoaW5wdXRtYXNrLmNhcmV0UG9zLmJlZ2luIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgIGlucHV0bWFzay5jYXJldFBvcyA9IHtiZWdpbjogbmV4dFBvc307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cblxuICAgIHJlc2V0TWFza1NldC5jYWxsKGlucHV0bWFzayk7XG4gICAgbWFza3NldC50ZXN0cyA9IHt9OyAvL3Jlc2V0IHRlc3RzIH4gcG9zc2libGUgYWZ0ZXIgYWx0ZXJuYXRpbmdcbiAgICBpbml0aWFsTmR4ID0gb3B0cy5yYWRpeFBvaW50ID8gZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywge1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgZW5kOiAwXG4gICAgfSwgZmFsc2UsIG9wdHMuX19maW5hbmNlSW5wdXQgPT09IGZhbHNlID8gXCJyYWRpeEZvY3VzXCIgOiB1bmRlZmluZWQpLmJlZ2luIDogMDtcbiAgICBtYXNrc2V0LnAgPSBpbml0aWFsTmR4O1xuICAgIGlucHV0bWFzay5jYXJldFBvcyA9IHtiZWdpbjogaW5pdGlhbE5keH07XG5cbiAgICB2YXIgc3RhdGljTWF0Y2hlcyA9IFtdLCBwcmV2Q2FyZXRQb3MgPSBpbnB1dG1hc2suY2FyZXRQb3M7XG4gICAgaW5wdXRWYWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFyQ29kZSwgbmR4KSB7XG4gICAgICAgIGlmIChjaGFyQ29kZSAhPT0gdW5kZWZpbmVkKSB7IC8vaW5wdXRmYWxsYmFjayBzdHJpcHMgc29tZSBlbGVtZW50cyBvdXQgb2YgdGhlIGlucHV0YXJyYXkuICAkLmVhY2ggbG9naWNhbGx5IHByZXNlbnRzIHRoZW0gYXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAvKmlmIChtYXNrc2V0LnZhbGlkUG9zaXRpb25zW25keF0gPT09IHVuZGVmaW5lZCAmJiBpbnB1dFZhbHVlW25keF0gPT09IGdldFBsYWNlaG9sZGVyLmNhbGwoaW5wdXRtYXNrLCBuZHgpICYmIGlzTWFzay5jYWxsKGlucHV0bWFzaywgbmR4LCB0cnVlKSAmJlxuICAgICAgICAgICAgICAgIGlzVmFsaWQuY2FsbChpbnB1dG1hc2ssIG5keCwgaW5wdXRWYWx1ZVtuZHhdLCB0cnVlLCB1bmRlZmluZWQsIHRydWUsIHRydWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlucHV0bWFzay5jYXJldFBvcy5iZWdpbisrO1xuICAgICAgICAgICAgfSBlbHNlKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cHJlc3MgPSBuZXcgJC5FdmVudChcIl9jaGVja3ZhbFwiKTtcbiAgICAgICAgICAgICAgICBrZXlwcmVzcy5rZXkgPSBjaGFyQ29kZTtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZXMgKz0gY2hhckNvZGU7XG4gICAgICAgICAgICAgICAgdmFyIGx2cCA9IGdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXNUZW1wbGF0ZU1hdGNoKGluaXRpYWxOZHgsIGNoYXJDb2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gRXZlbnRIYW5kbGVycy5rZXlwcmVzc0V2ZW50LmNhbGwoaW5wdXRtYXNrLCBrZXlwcmVzcywgdHJ1ZSwgZmFsc2UsIHN0cmljdCwgaW5wdXRtYXNrLmNhcmV0UG9zLmJlZ2luKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsTmR4ID0gaW5wdXRtYXNrLmNhcmV0UG9zLmJlZ2luICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlcyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBFdmVudEhhbmRsZXJzLmtleXByZXNzRXZlbnQuY2FsbChpbnB1dG1hc2ssIGtleXByZXNzLCB0cnVlLCBmYWxzZSwgc3RyaWN0LCBsdnAgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnBvcyAhPT0gdW5kZWZpbmVkICYmIG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbcmVzdWx0LnBvc10gJiYgbWFza3NldC52YWxpZFBvc2l0aW9uc1tyZXN1bHQucG9zXS5tYXRjaC5zdGF0aWMgPT09IHRydWUgJiYgbWFza3NldC52YWxpZFBvc2l0aW9uc1tyZXN1bHQucG9zXS5hbHRlcm5hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNNYXRjaGVzLnB1c2gocmVzdWx0LnBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0bWFzay5pc1JUTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mb3J3YXJkUG9zaXRpb24gPSByZXN1bHQucG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlci5jYWxsKGlucHV0bWFzaywgdW5kZWZpbmVkLCBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLCByZXN1bHQuZm9yd2FyZFBvc2l0aW9uLCBrZXlwcmVzcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dG1hc2suY2FyZXRQb3MgPSB7YmVnaW46IHJlc3VsdC5mb3J3YXJkUG9zaXRpb24sIGVuZDogcmVzdWx0LmZvcndhcmRQb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIHByZXZDYXJldFBvcyA9IGlucHV0bWFzay5jYXJldFBvcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFza3NldC52YWxpZFBvc2l0aW9uc1tuZHhdID09PSB1bmRlZmluZWQgJiYgaW5wdXRWYWx1ZVtuZHhdID09PSBnZXRQbGFjZWhvbGRlci5jYWxsKGlucHV0bWFzaywgbmR4KSAmJiBpc01hc2suY2FsbChpbnB1dG1hc2ssIG5keCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0bWFzay5jYXJldFBvcy5iZWdpbisrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaW5wdXRtYXNrLmNhcmV0UG9zID0gcHJldkNhcmV0UG9zOyAvL3Jlc3RvcmUgdGhlIGNhcmV0IHBvc2l0aW9uIGZyb20gYmVmb3JlIHRoZSBmYWlsZWQgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdGF0aWNNYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHNuZHgsIHZhbGlkUG9zLCBuZXh0VmFsaWQgPSBzZWVrTmV4dC5jYWxsKGlucHV0bWFzaywgLTEsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBpZiAoKCFpc0NvbXBsZXRlLmNhbGwoaW5wdXRtYXNrLCBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spKSAmJiBzdGF0aWNNYXRjaGVzLmxlbmd0aCA8PSBuZXh0VmFsaWQpXG4gICAgICAgICAgICB8fCAoaXNDb21wbGV0ZS5jYWxsKGlucHV0bWFzaywgZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKSkgJiYgc3RhdGljTWF0Y2hlcy5sZW5ndGggPiAwICYmIChzdGF0aWNNYXRjaGVzLmxlbmd0aCAhPT0gbmV4dFZhbGlkICYmIHN0YXRpY01hdGNoZXNbMF0gPT09IDApKSkgeyAvL3Nob3VsZCBjaGVjayBpZiBpcyBzZXF1ZW5jZSBzdGFydGluZyBmcm9tIDBcbiAgICAgICAgICAgIHZhciBuZXh0U25keCA9IG5leHRWYWxpZDtcbiAgICAgICAgICAgIHdoaWxlICgoc25keCA9IHN0YXRpY01hdGNoZXMuc2hpZnQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlwcmVzcyA9IG5ldyAkLkV2ZW50KFwiX2NoZWNrdmFsXCIpO1xuICAgICAgICAgICAgICAgIHZhbGlkUG9zID0gbWFza3NldC52YWxpZFBvc2l0aW9uc1tzbmR4XTtcbiAgICAgICAgICAgICAgICB2YWxpZFBvcy5nZW5lcmF0ZWRJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAga2V5cHJlc3Mua2V5ID0gdmFsaWRQb3MuaW5wdXQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gRXZlbnRIYW5kbGVycy5rZXlwcmVzc0V2ZW50LmNhbGwoaW5wdXRtYXNrLCBrZXlwcmVzcywgdHJ1ZSwgZmFsc2UsIHN0cmljdCwgbmV4dFNuZHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnBvcyAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdC5wb3MgIT09IHNuZHggJiYgbWFza3NldC52YWxpZFBvc2l0aW9uc1tyZXN1bHQucG9zXSAmJiBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3Jlc3VsdC5wb3NdLm1hdGNoLnN0YXRpYyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNNYXRjaGVzLnB1c2gocmVzdWx0LnBvcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcmVzdWx0KSBicmVhaztcbiAgICAgICAgICAgICAgICBuZXh0U25keCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvL21hcmsgYWwgc3RhdGljcyBhcyBnZW5lcmF0ZWRcbiAgICAgICAgICAgIC8vIHdoaWxlICgoc25keCA9IHN0YXRpY01hdGNoZXMucG9wKCkpKSB7XG4gICAgICAgICAgICAvLyBcdHZhbGlkUG9zID0gbWFza3NldC52YWxpZFBvc2l0aW9uc1tzbmR4XTtcbiAgICAgICAgICAgIC8vIFx0aWYgKHZhbGlkUG9zKSB7XG4gICAgICAgICAgICAvLyBcdFx0dmFsaWRQb3MuZ2VuZXJhdGVkSW5wdXQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gXHR9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdyaXRlT3V0KSB7XG4gICAgICAgIHdyaXRlQnVmZmVyLmNhbGwoXG4gICAgICAgICAgICBpbnB1dG1hc2ssXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzayksIHJlc3VsdCA/IHJlc3VsdC5mb3J3YXJkUG9zaXRpb24gOiBpbnB1dG1hc2suY2FyZXRQb3MuYmVnaW4sXG4gICAgICAgICAgICBpbml0aWF0aW5nRXZlbnQgfHwgbmV3ICQuRXZlbnQoXCJjaGVja3ZhbFwiKSxcbiAgICAgICAgICAgIGluaXRpYXRpbmdFdmVudCAmJiAoKGluaXRpYXRpbmdFdmVudC50eXBlID09PSBcImlucHV0XCIgJiYgaW5wdXRtYXNrLnVuZG9WYWx1ZSAhPT0gZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKS5qb2luKFwiXCIpKSB8fCBpbml0aWF0aW5nRXZlbnQudHlwZSA9PT0gXCJwYXN0ZVwiKSk7XG4gICAgICAgIC8vIGZvciAodmFyIHZuZHggaW4gbWFza3NldC52YWxpZFBvc2l0aW9ucykge1xuICAgICAgICAvLyBcdGlmIChtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3ZuZHhdLm1hdGNoLmdlbmVyYXRlZCAhPT0gdHJ1ZSkgeyAvL29ubHkgcmVtb3ZlIG5vbiBmb3JjZWQgZ2VuZXJhdGVkXG4gICAgICAgIC8vIFx0XHRkZWxldGUgbWFza3NldC52YWxpZFBvc2l0aW9uc1t2bmR4XS5nZW5lcmF0ZWRJbnB1dDsgLy9jbGVhciBnZW5lcmF0ZWQgbWFya2luZ3MgfiBjb25zaWRlciBpbml0aWFsaXppbmcgd2l0aCBhICB2YWx1ZSBhcyBmdWxseSB0eXBlZFxuICAgICAgICAvLyBcdH1cbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICBvcHRzLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgPSBza2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyO1xufVxuXG5mdW5jdGlvbiBIYW5kbGVOYXRpdmVQbGFjZWhvbGRlcihucHQsIHZhbHVlKSB7XG4gICAgY29uc3QgaW5wdXRtYXNrID0gbnB0ID8gbnB0LmlucHV0bWFzayA6IHRoaXM7XG5cbiAgICBpZiAoaWUpIHtcbiAgICAgICAgaWYgKG5wdC5pbnB1dG1hc2suX3ZhbHVlR2V0KCkgIT09IHZhbHVlICYmIChucHQucGxhY2Vob2xkZXIgIT09IHZhbHVlIHx8IG5wdC5wbGFjZWhvbGRlciA9PT0gXCJcIikpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgbnB0VmFsdWUgPSBucHQuaW5wdXRtYXNrLl92YWx1ZUdldCgpO1xuICAgICAgICAgICAgaWYgKG5wdFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBsdnAgPSBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzayk7XG4gICAgICAgICAgICAgICAgaWYgKGx2cCA9PT0gLTEgJiYgbnB0VmFsdWUgPT09IGdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoaW5wdXRtYXNrKS5qb2luKFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobHZwICE9PSAtMSkgeyAvL2NsZWFyb3V0IG9wdGlvbmFsIHRhaWwgb2YgdGhlIG1hc2tcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJPcHRpb25hbFRhaWwuY2FsbChpbnB1dG1hc2ssIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlQnVmZmVyKG5wdCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnB0LnBsYWNlaG9sZGVyICE9PSB2YWx1ZSkge1xuICAgICAgICBucHQucGxhY2Vob2xkZXIgPSB2YWx1ZTtcbiAgICAgICAgaWYgKG5wdC5wbGFjZWhvbGRlciA9PT0gXCJcIikgbnB0LnJlbW92ZUF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW5tYXNrZWR2YWx1ZShpbnB1dCkge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IGlucHV0ID8gaW5wdXQuaW5wdXRtYXNrIDogdGhpcyxcbiAgICAgICAgb3B0cyA9IGlucHV0bWFzay5vcHRzLFxuICAgICAgICBtYXNrc2V0ID0gaW5wdXRtYXNrLm1hc2tzZXQ7XG5cbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmlucHV0bWFzayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LmlucHV0bWFzayAmJiBpbnB1dC5pbnB1dG1hc2sucmVmcmVzaFZhbHVlKSB7IC8vZm9yY2VkIHJlZnJlc2ggZnJvbSB0aGUgdmFsdWUgZm9ybS5yZXNldFxuICAgICAgICAgICAgYXBwbHlJbnB1dFZhbHVlKGlucHV0LCBpbnB1dC5pbnB1dG1hc2suX3ZhbHVlR2V0KHRydWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW1WYWx1ZSA9IFtdLFxuICAgICAgICB2cHMgPSBtYXNrc2V0LnZhbGlkUG9zaXRpb25zO1xuICAgIGZvciAobGV0IHBuZHggPSAwLCB2cGwgPSB2cHMubGVuZ3RoOyBwbmR4IDwgdnBsOyBwbmR4KyspIHtcbiAgICAgICAgaWYgKHZwc1twbmR4XSAmJiB2cHNbcG5keF0ubWF0Y2ggJiYgKHZwc1twbmR4XS5tYXRjaC5zdGF0aWMgIT0gdHJ1ZSB8fCAoQXJyYXkuaXNBcnJheShtYXNrc2V0Lm1ldGFkYXRhKSAmJiB2cHNbcG5keF0uZ2VuZXJhdGVkSW5wdXQgIT09IHRydWUpKSkge1xuICAgICAgICAgICAgLy9vbmx5IGluY2x1ZGUgZ2VuZXJhdGVkIGlucHV0IHdpdGggbXVsdGlwbGUgbWFza3MgKGNoZWNrIG9uIG1ldGFkYXRhKVxuICAgICAgICAgICAgdW1WYWx1ZS5wdXNoKHZwc1twbmR4XS5pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVubWFza2VkVmFsdWUgPSB1bVZhbHVlLmxlbmd0aCA9PT0gMCA/IFwiXCIgOiAoaW5wdXRtYXNrLmlzUlRMID8gdW1WYWx1ZS5yZXZlcnNlKCkgOiB1bVZhbHVlKS5qb2luKFwiXCIpO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5vblVuTWFzayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBidWZmZXJWYWx1ZSA9IChpbnB1dG1hc2suaXNSVEwgPyBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLnNsaWNlKCkucmV2ZXJzZSgpIDogZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKSkuam9pbihcIlwiKTtcbiAgICAgICAgdW5tYXNrZWRWYWx1ZSA9IG9wdHMub25Vbk1hc2suY2FsbChpbnB1dG1hc2ssIGJ1ZmZlclZhbHVlLCB1bm1hc2tlZFZhbHVlLCBvcHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHVubWFza2VkVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyKGlucHV0LCBidWZmZXIsIGNhcmV0UG9zLCBldmVudCwgdHJpZ2dlckV2ZW50cykge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IGlucHV0ID8gaW5wdXQuaW5wdXRtYXNrIDogdGhpcyxcbiAgICAgICAgb3B0cyA9IGlucHV0bWFzay5vcHRzLFxuICAgICAgICAkID0gaW5wdXRtYXNrLmRlcGVuZGVuY3lMaWI7XG5cbiAgICBpZiAoZXZlbnQgJiYgdHlwZW9mIG9wdHMub25CZWZvcmVXcml0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgpOyAvL3ByZXZlbnQgdW5jb250cm9sbGVkIG1hbmlwdWxhdGlvbiBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRzLm9uQmVmb3JlV3JpdGUuY2FsbChpbnB1dG1hc2ssIGV2ZW50LCBidWZmZXIsIGNhcmV0UG9zLCBvcHRzKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWZyZXNoRnJvbUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHZhciByZWZyZXNoID0gcmVzdWx0LnJlZnJlc2hGcm9tQnVmZmVyO1xuICAgICAgICAgICAgICAgIHJlZnJlc2hGcm9tQnVmZmVyLmNhbGwoaW5wdXRtYXNrLCByZWZyZXNoID09PSB0cnVlID8gcmVmcmVzaCA6IHJlZnJlc2guc3RhcnQsIHJlZnJlc2guZW5kLCByZXN1bHQuYnVmZmVyIHx8IGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYXJldFBvcyAhPT0gdW5kZWZpbmVkKSBjYXJldFBvcyA9IHJlc3VsdC5jYXJldCAhPT0gdW5kZWZpbmVkID8gcmVzdWx0LmNhcmV0IDogY2FyZXRQb3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5wdXQuaW5wdXRtYXNrLl92YWx1ZVNldChidWZmZXIuam9pbihcIlwiKSk7XG4gICAgICAgIGlmIChjYXJldFBvcyAhPT0gdW5kZWZpbmVkICYmIChldmVudCA9PT0gdW5kZWZpbmVkIHx8IGV2ZW50LnR5cGUgIT09IFwiYmx1clwiKSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY2FyZXRQb3MpO1xuICAgICAgICAgICAgY2FyZXQuY2FsbChpbnB1dG1hc2ssIGlucHV0LCBjYXJldFBvcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIChldmVudCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiICYmIChldmVudC5rZXkgPT09IGtleXMuRGVsZXRlIHx8IGV2ZW50LmtleSA9PT0ga2V5cy5CYWNrc3BhY2UpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaWdnZXJFdmVudHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkKGlucHV0KSwgbnB0VmFsID0gaW5wdXQuaW5wdXRtYXNrLl92YWx1ZUdldCgpO1xuICAgICAgICAgICAgaW5wdXQuaW5wdXRtYXNrLnNraXBJbnB1dEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICRpbnB1dC50cmlnZ2VyKFwiaW5wdXRcIik7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgLy90aW1lb3V0IG5lZWRlZCBmb3IgSUVcbiAgICAgICAgICAgICAgICBpZiAobnB0VmFsID09PSBnZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaykuam9pbihcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAkaW5wdXQudHJpZ2dlcihcImNsZWFyZWRcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NvbXBsZXRlLmNhbGwoaW5wdXRtYXNrLCBidWZmZXIpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICRpbnB1dC50cmlnZ2VyKFwiY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKlxuICogSW5wdXQgTWFzayBDb3JlXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9Sb2JpbkhlcmJvdHMvanF1ZXJ5LmlucHV0bWFza1xuICogQ29weXJpZ2h0IChjKSBSb2JpbiBIZXJib3RzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge21hc2t9IGZyb20gXCIuL21hc2tcIjtcbmltcG9ydCAkIGZyb20gXCIuL2RlcGVuZGVuY3lMaWJzL2lucHV0bWFzay5kZXBlbmRlbmN5TGliXCI7XG5pbXBvcnQgd2luZG93IGZyb20gXCIuL2dsb2JhbC93aW5kb3dcIjtcbmltcG9ydCB7Z2VuZXJhdGVNYXNrU2V0LCBhbmFseXNlTWFza30gZnJvbSBcIi4vbWFzay1sZXhlclwiO1xuaW1wb3J0IHtnZXRNYXNrVGVtcGxhdGV9IGZyb20gXCIuL3ZhbGlkYXRpb24tdGVzdHNcIjtcbmltcG9ydCB7ZGV0ZXJtaW5lTGFzdFJlcXVpcmVkUG9zaXRpb24sIGdldEJ1ZmZlciwgZ2V0QnVmZmVyVGVtcGxhdGUsIGlzTWFza30gZnJvbSBcIi4vcG9zaXRpb25pbmdcIjtcbmltcG9ydCB7aXNDb21wbGV0ZX0gZnJvbSBcIi4vdmFsaWRhdGlvblwiO1xuaW1wb3J0IHtjaGVja1ZhbCwgdW5tYXNrZWR2YWx1ZX0gZnJvbSBcIi4vaW5wdXRIYW5kbGluZ1wiO1xuaW1wb3J0IHtFdmVudFJ1bGVyfSBmcm9tIFwiLi9ldmVudHJ1bGVyXCI7XG5pbXBvcnQgZGVmaW5pdGlvbnMgZnJvbSBcIi4vZGVmaW5pdGlvbnNcIjtcbmltcG9ydCBkZWZhdWx0cyBmcm9tIFwiLi9kZWZhdWx0c1wiO1xuaW1wb3J0IGNhblVzZURPTSBmcm9tIFwiLi9jYW5Vc2VET01cIjtcblxuY29uc3QgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsIGRhdGFLZXkgPSBcIl9pbnB1dG1hc2tfb3B0c1wiO1xuXG5mdW5jdGlvbiBJbnB1dG1hc2soYWxpYXMsIG9wdGlvbnMsIGludGVybmFsKSB7XG4gICAgaWYgKCFjYW5Vc2VET00pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vYWxsb3cgaW5zdGFuY2lhdGluZyB3aXRob3V0IG5ld1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnB1dG1hc2spKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5wdXRtYXNrKGFsaWFzLCBvcHRpb25zLCBpbnRlcm5hbCk7XG4gICAgfVxuXG4gICAgdGhpcy5kZXBlbmRlbmN5TGliID0gJDtcbiAgICB0aGlzLmVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgdGhpcy5tYXNrc2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGludGVybmFsICE9PSB0cnVlKSB7XG4gICAgICAgIC8vaW5pdCBvcHRpb25zXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYWxpYXMpID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYWxpYXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChhbGlhcykgb3B0aW9ucy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ub01hc2tzQ2FjaGUgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVmaW5pdGlvbnMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51c2VyT3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vdXNlciBwYXNzZWQgb3B0aW9uc1xuICAgICAgICByZXNvbHZlQWxpYXModGhpcy5vcHRzLmFsaWFzLCBvcHRpb25zLCB0aGlzLm9wdHMpO1xuICAgIH1cblxuICAgIC8vbWFza3Njb3BlIHByb3BlcnRpZXNcbiAgICB0aGlzLnJlZnJlc2hWYWx1ZSA9IGZhbHNlOyAvL2luZGljYXRlIGEgcmVmcmVzaCBmcm9tIHRoZSBpbnB1dHZhbHVlIGlzIG5lZWRlZCAoZm9ybS5yZXNldClcbiAgICB0aGlzLnVuZG9WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNraXBJbnB1dEV2ZW50ID0gZmFsc2U7IC8vc2tpcCB3aGVuIHRyaWdnZXJlZCBmcm9tIHdpdGhpbiBpbnB1dG1hc2tcbiAgICB0aGlzLnZhbGlkYXRpb25FdmVudCA9IGZhbHNlO1xuICAgIHRoaXMuaWdub3JhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5tYXhMZW5ndGg7XG4gICAgdGhpcy5tb3VzZUVudGVyID0gZmFsc2U7XG4gICAgdGhpcy5jbGlja2VkID0gMDtcbiAgICB0aGlzLm9yaWdpbmFsUGxhY2Vob2xkZXIgPSB1bmRlZmluZWQ7IC8vbmVlZGVkIGZvciBGRlxuICAgIHRoaXMuaXNDb21wb3NpbmcgPSBmYWxzZSwgLy9rZXlkb3duY29kZSA9PSAyMjkgIGNvbXBvc2l0aW9uZXZlbnQgZmFsbGJhY2tcbiAgICB0aGlzLmhhc0FsdGVybmF0b3IgPSBmYWxzZTtcbn1cblxuSW5wdXRtYXNrLnByb3RvdHlwZSA9IHtcbiAgICBkYXRhQXR0cmlidXRlOiBcImRhdGEtaW5wdXRtYXNrXCIsIC8vZGF0YSBhdHRyaWJ1dGUgcHJlZml4IHVzZWQgZm9yIGF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgLy9vcHRpb25zIGRlZmF1bHRcbiAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgZGVmaW5pdGlvbnM6IGRlZmluaXRpb25zLFxuICAgIGFsaWFzZXM6IHt9LCAvL2FsaWFzZXMgZGVmaW5pdGlvbnNcbiAgICBtYXNrc0NhY2hlOiB7fSxcbiAgICBnZXQgaXNSVEwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdHMuaXNSVEwgfHwgdGhpcy5vcHRzLm51bWVyaWNJbnB1dDtcbiAgICB9LFxuICAgIG1hc2s6IGZ1bmN0aW9uIChlbGVtcykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGVsZW1zID0gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1zKSB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbXMgPSBlbGVtcy5ub2RlTmFtZSA/IFtlbGVtc10gOiAoQXJyYXkuaXNBcnJheShlbGVtcykgPyBlbGVtcyA6IFtdLnNsaWNlLmNhbGwoZWxlbXMpKTsgLy9bXS5zbGljZSBhcyBhbHRlcm5hdGUgZm9yIEFycmF5LmZyb20gKFlhbmRleCBicm93c2VyKVxuICAgICAgICBlbGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgbmR4KSB7XG4gICAgICAgICAgICB2YXIgc2NvcGVkT3B0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGF0Lm9wdHMpO1xuICAgICAgICAgICAgaWYgKGltcG9ydEF0dHJpYnV0ZU9wdGlvbnMoZWwsIHNjb3BlZE9wdHMsICQuZXh0ZW5kKHRydWUsIHt9LCB0aGF0LnVzZXJPcHRpb25zKSwgdGhhdC5kYXRhQXR0cmlidXRlKSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXNrc2V0ID0gZ2VuZXJhdGVNYXNrU2V0KHNjb3BlZE9wdHMsIHRoYXQubm9NYXNrc0NhY2hlKTtcbiAgICAgICAgICAgICAgICBpZiAobWFza3NldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5pbnB1dG1hc2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuaW5wdXRtYXNrLm9wdHMuYXV0b1VubWFzayA9IHRydWU7IC8vZm9yY2UgYXV0b3VubWFza2luZyB3aGVuIHJlbWFza2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuaW5wdXRtYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgaW5wdXRtYXNrIGluc3RhbmNlIG9uIHRoZSBpbnB1dCB3aXRoIGVsZW1lbnQgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIGVsLmlucHV0bWFzayA9IG5ldyBJbnB1dG1hc2sodW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBlbC5pbnB1dG1hc2sub3B0cyA9IHNjb3BlZE9wdHM7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlucHV0bWFzay5ub01hc2tzQ2FjaGUgPSB0aGF0Lm5vTWFza3NDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5wdXRtYXNrLnVzZXJPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHRoYXQudXNlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbC5pbnB1dG1hc2suaXNSVEwgPSBzY29wZWRPcHRzLmlzUlRMIHx8IHNjb3BlZE9wdHMubnVtZXJpY0lucHV0O1xuICAgICAgICAgICAgICAgICAgICBlbC5pbnB1dG1hc2suZWwgPSBlbDtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5wdXRtYXNrLiRlbCA9ICQoZWwpO1xuICAgICAgICAgICAgICAgICAgICBlbC5pbnB1dG1hc2subWFza3NldCA9IG1hc2tzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgJC5kYXRhKGVsLCBkYXRhS2V5LCB0aGF0LnVzZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgbWFzay5jYWxsKGVsLmlucHV0bWFzayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVsZW1zICYmIGVsZW1zWzBdID8gKGVsZW1zWzBdLmlucHV0bWFzayB8fCB0aGlzKSA6IHRoaXM7XG4gICAgfSxcbiAgICBvcHRpb246IGZ1bmN0aW9uIChvcHRpb25zLCBub3JlbWFzaykgeyAvL3NldCBleHRyYSBvcHRpb25zIHx8IHJldHJpZXZlIHZhbHVlIG9mIGEgY3VycmVudCBvcHRpb25cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRzW29wdGlvbnNdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAkLmV4dGVuZCh0aGlzLnVzZXJPcHRpb25zLCBvcHRpb25zKTsgLy91c2VyIHBhc3NlZCBvcHRpb25zXG4gICAgICAgICAgICAvL3JlbWFza1xuICAgICAgICAgICAgaWYgKHRoaXMuZWwgJiYgbm9yZW1hc2sgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hc2sodGhpcy5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdW5tYXNrZWR2YWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWFza3NldCA9IHRoaXMubWFza3NldCB8fCBnZW5lcmF0ZU1hc2tTZXQodGhpcy5vcHRzLCB0aGlzLm5vTWFza3NDYWNoZSk7XG4gICAgICAgIGlmICh0aGlzLmVsID09PSB1bmRlZmluZWQgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlQnVmZmVyID0gKHR5cGVvZiB0aGlzLm9wdHMub25CZWZvcmVNYXNrID09PSBcImZ1bmN0aW9uXCIgPyAodGhpcy5vcHRzLm9uQmVmb3JlTWFzay5jYWxsKHRoaXMsIHZhbHVlLCB0aGlzLm9wdHMpIHx8IHZhbHVlKSA6IHZhbHVlKS5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgIGNoZWNrVmFsLmNhbGwodGhpcywgdW5kZWZpbmVkLCBmYWxzZSwgZmFsc2UsIHZhbHVlQnVmZmVyKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLm9uQmVmb3JlV3JpdGUgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5vcHRzLm9uQmVmb3JlV3JpdGUuY2FsbCh0aGlzLCB1bmRlZmluZWQsIGdldEJ1ZmZlci5jYWxsKHRoaXMpLCAwLCB0aGlzLm9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bm1hc2tlZHZhbHVlLmNhbGwodGhpcywgdGhpcy5lbCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgICAgICAgICQuZGF0YSh0aGlzLmVsLCBkYXRhS2V5LCBudWxsKTsgLy9pbnZhbGlkYXRlXG4gICAgICAgICAgICAvL3dyaXRlb3V0IHRoZSB2YWx1ZVxuICAgICAgICAgICAgdmFyIGN2ID0gdGhpcy5vcHRzLmF1dG9Vbm1hc2sgPyB1bm1hc2tlZHZhbHVlKHRoaXMuZWwpIDogdGhpcy5fdmFsdWVHZXQodGhpcy5vcHRzLmF1dG9Vbm1hc2spO1xuICAgICAgICAgICAgaWYgKGN2ICE9PSBnZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHRoaXMpLmpvaW4oXCJcIikpIHRoaXMuX3ZhbHVlU2V0KGN2LCB0aGlzLm9wdHMuYXV0b1VubWFzayk7IGVsc2UgdGhpcy5fdmFsdWVTZXQoXCJcIik7XG4gICAgICAgICAgICAvL3VuYmluZCBhbGwgZXZlbnRzXG4gICAgICAgICAgICBFdmVudFJ1bGVyLm9mZih0aGlzLmVsKTtcblxuICAgICAgICAgICAgLy9yZXN0b3JlIHRoZSB2YWx1ZSBwcm9wZXJ0eVxuICAgICAgICAgICAgdmFyIHZhbHVlUHJvcGVydHk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5lbCksIFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX192YWx1ZUdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZWwsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogdGhpcy5fX3ZhbHVlR2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogdGhpcy5fX3ZhbHVlU2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50Ll9fbG9va3VwR2V0dGVyX18gJiYgdGhpcy5lbC5fX2xvb2t1cEdldHRlcl9fKFwidmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3ZhbHVlR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuX19kZWZpbmVHZXR0ZXJfXyhcInZhbHVlXCIsIHRoaXMuX192YWx1ZUdldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuX19kZWZpbmVTZXR0ZXJfXyhcInZhbHVlXCIsIHRoaXMuX192YWx1ZVNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jbGVhciBkYXRhXG4gICAgICAgICAgICB0aGlzLmVsLmlucHV0bWFzayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbDtcbiAgICB9LFxuICAgIGdldGVtcHR5bWFzazogZnVuY3Rpb24gKCkgeyAvL3JldHVybiB0aGUgZGVmYXVsdCAoZW1wdHkpIG1hc2sgdmFsdWUsIHVzZWZ1bGwgZm9yIHNldHRpbmcgdGhlIGRlZmF1bHQgdmFsdWUgaW4gdmFsaWRhdGlvblxuICAgICAgICB0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgZ2VuZXJhdGVNYXNrU2V0KHRoaXMub3B0cywgdGhpcy5ub01hc2tzQ2FjaGUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNSVEwgPyBnZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHRoaXMpLnJldmVyc2UoKSA6IGdldEJ1ZmZlclRlbXBsYXRlLmNhbGwodGhpcykpLmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICBoYXNNYXNrZWRWYWx1ZTogZnVuY3Rpb24gKCkgeyAvL2NoZWNrIHdoZXRlciB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgbWFza2VkIG9yIG5vdDsgY3VycmVudGx5IG9ubHkgd29ya3MgcmVsaWFibGUgd2hlbiB1c2luZyBqcXVlcnkudmFsIGZuIHRvIHJldHJpZXZlIHRoZSB2YWx1ZVxuICAgICAgICByZXR1cm4gIXRoaXMub3B0cy5hdXRvVW5tYXNrO1xuICAgIH0sXG4gICAgaXNDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgZ2VuZXJhdGVNYXNrU2V0KHRoaXMub3B0cywgdGhpcy5ub01hc2tzQ2FjaGUpO1xuICAgICAgICByZXR1cm4gaXNDb21wbGV0ZS5jYWxsKHRoaXMsIGdldEJ1ZmZlci5jYWxsKHRoaXMpKTtcbiAgICB9LFxuICAgIGdldG1ldGFkYXRhOiBmdW5jdGlvbiAoKSB7IC8vcmV0dXJuIG1hc2sgbWV0YWRhdGEgaWYgZXhpc3RzXG4gICAgICAgIHRoaXMubWFza3NldCA9IHRoaXMubWFza3NldCB8fCBnZW5lcmF0ZU1hc2tTZXQodGhpcy5vcHRzLCB0aGlzLm5vTWFza3NDYWNoZSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubWFza3NldC5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBtYXNrVGFyZ2V0ID0gZ2V0TWFza1RlbXBsYXRlLmNhbGwodGhpcywgdHJ1ZSwgMCwgZmFsc2UpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICB0aGlzLm1hc2tzZXQubWV0YWRhdGEuZm9yRWFjaChmdW5jdGlvbiAobXRkdCkge1xuICAgICAgICAgICAgICAgIGlmIChtdGR0Lm1hc2sgPT09IG1hc2tUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFza1RhcmdldCA9IG10ZHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hc2tUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFza3NldC5tZXRhZGF0YTtcbiAgICB9LFxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgZ2VuZXJhdGVNYXNrU2V0KHRoaXMub3B0cywgdGhpcy5ub01hc2tzQ2FjaGUpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZUJ1ZmZlciA9ICh0eXBlb2YgdGhpcy5vcHRzLm9uQmVmb3JlTWFzayA9PT0gXCJmdW5jdGlvblwiID8gKHRoaXMub3B0cy5vbkJlZm9yZU1hc2suY2FsbCh0aGlzLCB2YWx1ZSwgdGhpcy5vcHRzKSB8fCB2YWx1ZSkgOiB2YWx1ZSkuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICBjaGVja1ZhbC5jYWxsKHRoaXMsIHVuZGVmaW5lZCwgdHJ1ZSwgZmFsc2UsIHZhbHVlQnVmZmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pc1JUTCA/IGdldEJ1ZmZlci5jYWxsKHRoaXMpLnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oXCJcIikgOiBnZXRCdWZmZXIuY2FsbCh0aGlzKS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBnZXRCdWZmZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIHJsID0gZGV0ZXJtaW5lTGFzdFJlcXVpcmVkUG9zaXRpb24uY2FsbCh0aGlzKSxcbiAgICAgICAgICAgIGxtaWIgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICg7IGxtaWIgPiBybDsgbG1pYi0tKSB7XG4gICAgICAgICAgICBpZiAoaXNNYXNrLmNhbGwodGhpcywgbG1pYikpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5zcGxpY2UocmwsIGxtaWIgKyAxIC0gcmwpO1xuXG4gICAgICAgIHJldHVybiBpc0NvbXBsZXRlLmNhbGwodGhpcywgYnVmZmVyKSAmJiB2YWx1ZSA9PT0gKHRoaXMuaXNSVEwgPyBnZXRCdWZmZXIuY2FsbCh0aGlzKS5zbGljZSgpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogZ2V0QnVmZmVyLmNhbGwodGhpcykuam9pbihcIlwiKSk7XG5cbiAgICB9LFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKHZhbHVlLCBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgZ2VuZXJhdGVNYXNrU2V0KHRoaXMub3B0cywgdGhpcy5ub01hc2tzQ2FjaGUpO1xuICAgICAgICBsZXQgdmFsdWVCdWZmZXIgPSAodHlwZW9mIHRoaXMub3B0cy5vbkJlZm9yZU1hc2sgPT09IFwiZnVuY3Rpb25cIiA/ICh0aGlzLm9wdHMub25CZWZvcmVNYXNrLmNhbGwodGhpcywgdmFsdWUsIHRoaXMub3B0cykgfHwgdmFsdWUpIDogdmFsdWUpLnNwbGl0KFwiXCIpO1xuICAgICAgICBjaGVja1ZhbC5jYWxsKHRoaXMsIHVuZGVmaW5lZCwgdHJ1ZSwgZmFsc2UsIHZhbHVlQnVmZmVyKTtcbiAgICAgICAgbGV0IGZvcm1hdHRlZFZhbHVlID0gdGhpcy5pc1JUTCA/IGdldEJ1ZmZlci5jYWxsKHRoaXMpLnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oXCJcIikgOiBnZXRCdWZmZXIuY2FsbCh0aGlzKS5qb2luKFwiXCIpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGEgPyB7XG4gICAgICAgICAgICB2YWx1ZTogZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5nZXRtZXRhZGF0YSgpXG4gICAgICAgIH0gOiBmb3JtYXR0ZWRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgICAgICAgICQodGhpcy5lbCkudHJpZ2dlcihcInNldHZhbHVlXCIsIFt2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhbmFseXNlTWFzazogYW5hbHlzZU1hc2tcbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVBbGlhcyhhbGlhc1N0ciwgb3B0aW9ucywgb3B0cykge1xuICAgIHZhciBhbGlhc0RlZmluaXRpb24gPSBJbnB1dG1hc2sucHJvdG90eXBlLmFsaWFzZXNbYWxpYXNTdHJdO1xuICAgIGlmIChhbGlhc0RlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKGFsaWFzRGVmaW5pdGlvbi5hbGlhcykgcmVzb2x2ZUFsaWFzKGFsaWFzRGVmaW5pdGlvbi5hbGlhcywgdW5kZWZpbmVkLCBvcHRzKTsgLy9hbGlhcyBpcyBhbm90aGVyIGFsaWFzXG4gICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdHMsIGFsaWFzRGVmaW5pdGlvbik7IC8vbWVyZ2UgYWxpYXMgZGVmaW5pdGlvbiBpbiB0aGUgb3B0aW9uc1xuICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRzLCBvcHRpb25zKTsgLy9yZWFwcGx5IGV4dHJhIGdpdmVuIG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIC8vYWxpYXMgbm90IGZvdW5kIC0gdHJ5IGFzIG1hc2tcbiAgICBpZiAob3B0cy5tYXNrID09PSBudWxsKSB7XG4gICAgICAgIG9wdHMubWFzayA9IGFsaWFzU3RyO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaW1wb3J0QXR0cmlidXRlT3B0aW9ucyhucHQsIG9wdHMsIHVzZXJPcHRpb25zLCBkYXRhQXR0cmlidXRlKSB7XG4gICAgZnVuY3Rpb24gaW1wb3J0T3B0aW9uKG9wdGlvbiwgb3B0aW9uRGF0YSkge1xuICAgICAgICBjb25zdCBhdHRyT3B0aW9uID0gZGF0YUF0dHJpYnV0ZSA9PT0gXCJcIiA/IG9wdGlvbiA6IGRhdGFBdHRyaWJ1dGUgKyBcIi1cIiArIG9wdGlvbjtcbiAgICAgICAgb3B0aW9uRGF0YSA9IG9wdGlvbkRhdGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbkRhdGEgOiBucHQuZ2V0QXR0cmlidXRlKGF0dHJPcHRpb24pO1xuICAgICAgICBpZiAob3B0aW9uRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25EYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5pbmRleE9mKFwib25cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uRGF0YSA9IHdpbmRvd1tvcHRpb25EYXRhXTtcbiAgICAgICAgICAgICAgICB9Ly9nZXQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbkRhdGEgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25EYXRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25EYXRhID09PSBcInRydWVcIikgb3B0aW9uRGF0YSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2VyT3B0aW9uc1tvcHRpb25dID0gb3B0aW9uRGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRzLmltcG9ydERhdGFBdHRyaWJ1dGVzID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBhdHRyT3B0aW9ucyA9IG5wdC5nZXRBdHRyaWJ1dGUoZGF0YUF0dHJpYnV0ZSksIG9wdGlvbiwgZGF0YW9wdGlvbnMsIG9wdGlvbkRhdGEsIHA7XG5cbiAgICAgICAgaWYgKGF0dHJPcHRpb25zICYmIGF0dHJPcHRpb25zICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBhdHRyT3B0aW9ucyA9IGF0dHJPcHRpb25zLnJlcGxhY2UoLycvZywgXCJcXFwiXCIpO1xuICAgICAgICAgICAgZGF0YW9wdGlvbnMgPSBKU09OLnBhcnNlKFwie1wiICsgYXR0ck9wdGlvbnMgKyBcIn1cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL3Jlc29sdmUgYWxpYXNlc1xuICAgICAgICBpZiAoZGF0YW9wdGlvbnMpIHsgLy9waWNrdXAgYWxpYXMgZnJvbSBkYXRhQXR0cmlidXRlXG4gICAgICAgICAgICBvcHRpb25EYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChwIGluIGRhdGFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAudG9Mb3dlckNhc2UoKSA9PT0gXCJhbGlhc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbkRhdGEgPSBkYXRhb3B0aW9uc1twXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGltcG9ydE9wdGlvbihcImFsaWFzXCIsIG9wdGlvbkRhdGEpOyAvL3BpY2t1cCBhbGlhcyBmcm9tIGRhdGFBdHRyaWJ1dGUtYWxpYXNcbiAgICAgICAgaWYgKHVzZXJPcHRpb25zLmFsaWFzKSB7XG4gICAgICAgICAgICByZXNvbHZlQWxpYXModXNlck9wdGlvbnMuYWxpYXMsIHVzZXJPcHRpb25zLCBvcHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAob3B0aW9uIGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbkRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIGRhdGFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnRvTG93ZXJDYXNlKCkgPT09IG9wdGlvbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25EYXRhID0gZGF0YW9wdGlvbnNbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltcG9ydE9wdGlvbihvcHRpb24sIG9wdGlvbkRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgICQuZXh0ZW5kKHRydWUsIG9wdHMsIHVzZXJPcHRpb25zKTtcblxuICAgIC8vaGFuZGxlIGRpcj1ydGxcbiAgICBpZiAobnB0LmRpciA9PT0gXCJydGxcIiB8fCBvcHRzLnJpZ2h0QWxpZ24pIHtcbiAgICAgICAgbnB0LnN0eWxlLnRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICB9XG5cbiAgICBpZiAobnB0LmRpciA9PT0gXCJydGxcIiB8fCBvcHRzLm51bWVyaWNJbnB1dCkge1xuICAgICAgICBucHQuZGlyID0gXCJsdHJcIjtcbiAgICAgICAgbnB0LnJlbW92ZUF0dHJpYnV0ZShcImRpclwiKTtcbiAgICAgICAgb3B0cy5pc1JUTCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHVzZXJPcHRpb25zKS5sZW5ndGg7XG59XG5cbi8vYXBwbHkgZGVmYXVsdHMsIGRlZmluaXRpb25zLCBhbGlhc2VzXG5JbnB1dG1hc2suZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICQuZXh0ZW5kKHRydWUsIElucHV0bWFzay5wcm90b3R5cGUuZGVmYXVsdHMsIG9wdGlvbnMpO1xufTtcbklucHV0bWFzay5leHRlbmREZWZpbml0aW9ucyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgJC5leHRlbmQodHJ1ZSwgSW5wdXRtYXNrLnByb3RvdHlwZS5kZWZpbml0aW9ucywgZGVmaW5pdGlvbik7XG59O1xuSW5wdXRtYXNrLmV4dGVuZEFsaWFzZXMgPSBmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAkLmV4dGVuZCh0cnVlLCBJbnB1dG1hc2sucHJvdG90eXBlLmFsaWFzZXMsIGFsaWFzKTtcbn07XG4vL3N0YXRpYyBmbiBvbiBpbnB1dG1hc2tcbklucHV0bWFzay5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIElucHV0bWFzayhvcHRpb25zKS5mb3JtYXQodmFsdWUsIG1ldGFkYXRhKTtcbn07XG5JbnB1dG1hc2sudW5tYXNrID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIElucHV0bWFzayhvcHRpb25zKS51bm1hc2tlZHZhbHVlKHZhbHVlKTtcbn07XG5JbnB1dG1hc2suaXNWYWxpZCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBJbnB1dG1hc2sob3B0aW9ucykuaXNWYWxpZCh2YWx1ZSk7XG59O1xuSW5wdXRtYXNrLnJlbW92ZSA9IGZ1bmN0aW9uIChlbGVtcykge1xuICAgIGlmICh0eXBlb2YgZWxlbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZWxlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtcykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtcyk7XG4gICAgfVxuICAgIGVsZW1zID0gZWxlbXMubm9kZU5hbWUgPyBbZWxlbXNdIDogZWxlbXM7XG4gICAgZWxlbXMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsLmlucHV0bWFzaykgZWwuaW5wdXRtYXNrLnJlbW92ZSgpO1xuICAgIH0pO1xufTtcbklucHV0bWFzay5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChlbGVtcywgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGVsZW1zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbXMpIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbXMpO1xuICAgIH1cbiAgICBlbGVtcyA9IGVsZW1zLm5vZGVOYW1lID8gW2VsZW1zXSA6IGVsZW1zO1xuICAgIGVsZW1zLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChlbC5pbnB1dG1hc2spIGVsLmlucHV0bWFzay5zZXRWYWx1ZSh2YWx1ZSk7IGVsc2UgJChlbCkudHJpZ2dlcihcInNldHZhbHVlXCIsIFt2YWx1ZV0pO1xuICAgIH0pO1xufTtcblxuSW5wdXRtYXNrLmRlcGVuZGVuY3lMaWIgPSAkO1xuXG4vL21ha2UgaW5wdXRtYXNrIGF2YWlsYWJsZVxud2luZG93LklucHV0bWFzayA9IElucHV0bWFzaztcbmV4cG9ydCBkZWZhdWx0IElucHV0bWFzaztcbiIsImV4cG9ydCB7a2V5Q29kZSwgdG9LZXksIHRvS2V5Q29kZSwga2V5c307XG5cbmNvbnN0IGtleUNvZGUgPSB7XG4gICAgXCJBbHRHcmFwaFwiOiAxOCxcbiAgICBcIkFycm93RG93blwiOiA0MCxcbiAgICBcIkFycm93TGVmdFwiOiAzNyxcbiAgICBcIkFycm93UmlnaHRcIjogMzksXG4gICAgXCJBcnJvd1VwXCI6IDM4LFxuICAgIFwiQmFja3NwYWNlXCI6IDgsXG4gICAgXCJCQUNLU1BBQ0VfU0FGQVJJXCI6IDEyNyxcbiAgICBcIkNhcHNMb2NrXCI6IDIwLFxuICAgIFwiRGVsZXRlXCI6IDQ2LFxuICAgIFwiRW5kXCI6IDM1LFxuICAgIFwiRW50ZXJcIjogMTMsXG4gICAgXCJFc2NhcGVcIjogMjcsXG4gICAgXCJIb21lXCI6IDM2LFxuICAgIFwiSW5zZXJ0XCI6IDQ1LFxuICAgIFwiUGFnZURvd25cIjogMzQsXG4gICAgXCJQYWdlVXBcIjogMzMsXG4gICAgXCJTcGFjZVwiOiAzMixcbiAgICBcIlRhYlwiOiA5LFxuICAgIFwiY1wiOiA2NyxcbiAgICBcInhcIjogODgsXG4gICAgXCJ6XCI6IDkwLFxuICAgIFwiU2hpZnRcIjogMTYsXG4gICAgXCJDb250cm9sXCI6IDE3LFxuICAgIFwiQWx0XCI6IDE4LFxuICAgIFwiUGF1c2VcIjogMTksXG4gICAgXCJNZXRhX0xFRlRcIjogOTEsXG4gICAgXCJNZXRhX1JJR0hUXCI6IDkyLFxuICAgIFwiQ29udGV4dE1lbnVcIjogOTMsXG4gICAgXCJQcm9jZXNzXCI6IDIyOSxcbiAgICBcIlVuaWRlbnRpZmllZFwiOiAyMjksXG4gICAgXCJGMVwiOiAxMTIsXG4gICAgXCJGMlwiOiAxMTMsXG4gICAgXCJGM1wiOiAxMTQsXG4gICAgXCJGNFwiOiAxMTUsXG4gICAgXCJGNVwiOiAxMTYsXG4gICAgXCJGNlwiOiAxMTcsXG4gICAgXCJGN1wiOiAxMTgsXG4gICAgXCJGOFwiOiAxMTksXG4gICAgXCJGOVwiOiAxMjAsXG4gICAgXCJGMTBcIjogMTIxLFxuICAgIFwiRjExXCI6IDEyMixcbiAgICBcIkYxMlwiOiAxMjNcbn07XG5cbmNvbnN0IGtleUNvZGVSZXYgPSBPYmplY3QuZW50cmllcyhrZXlDb2RlKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiAoYWNjW3ZhbHVlXSA9IGFjY1t2YWx1ZV0gPT09IHVuZGVmaW5lZCA/IGtleSA6IGFjY1t2YWx1ZV0gLCBhY2MpLCB7fSk7XG5jb25zdCBrZXlzID0gT2JqZWN0LmVudHJpZXMoa2V5Q29kZSkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4gKGFjY1trZXldID0ga2V5ID09PSBcIlNwYWNlXCIgPyBcIiBcIiA6IGtleSwgYWNjKSwge30pO1xuXG5mdW5jdGlvbiB0b0tleShrZXlDb2RlLCBzaGlmdEtleSkge1xuICAgIHJldHVybiBrZXlDb2RlUmV2W2tleUNvZGVdIHx8IChzaGlmdEtleSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5Q29kZSkgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUNvZGUpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5mdW5jdGlvbiB0b0tleUNvZGUoa2V5KSB7XG4gICAgcmV0dXJuIGtleUNvZGVba2V5XTtcbn1cbiIsImltcG9ydCAkIGZyb20gXCIuL2RlcGVuZGVuY3lMaWJzL2lucHV0bWFzay5kZXBlbmRlbmN5TGliXCI7XG5pbXBvcnQgTWFza1Rva2VuIGZyb20gXCIuL21hc2t0b2tlblwiO1xuaW1wb3J0IElucHV0bWFzayBmcm9tIFwiLi9pbnB1dG1hc2tcIjtcbmltcG9ydCBlc2NhcGVSZWdleCBmcm9tIFwiLi9lc2NhcGVSZWdleFwiO1xuXG5leHBvcnQge2dlbmVyYXRlTWFza1NldCwgYW5hbHlzZU1hc2t9O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZU1hc2tTZXQob3B0cywgbm9jYWNoZSkge1xuICAgIHZhciBtcztcblxuICAgIGZ1bmN0aW9uIHByZVByb2Nlc3NNYXNrKG1hc2ssIHtyZXBlYXQsIGdyb3VwbWFya2VyLCBxdWFudGlmaWVybWFya2VyLCBrZWVwU3RhdGljfSkge1xuICAgICAgICBpZiAocmVwZWF0ID4gMCB8fCByZXBlYXQgPT09IFwiKlwiIHx8IHJlcGVhdCA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgIHZhciByZXBlYXRTdGFydCA9IHJlcGVhdCA9PT0gXCIqXCIgPyAwIDogKHJlcGVhdCA9PT0gXCIrXCIgPyAxIDogcmVwZWF0KTtcbiAgICAgICAgICAgIG1hc2sgPSBncm91cG1hcmtlclswXSArIG1hc2sgKyBncm91cG1hcmtlclsxXSArIHF1YW50aWZpZXJtYXJrZXJbMF0gKyByZXBlYXRTdGFydCArIFwiLFwiICsgcmVwZWF0ICsgcXVhbnRpZmllcm1hcmtlclsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VlcFN0YXRpYyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IG9wdGlvbmFsUmVnZXggPSBcIiguKVxcXFxbKFteXFxcXF1dKilcXFxcXVwiLCAvLyBcIig/PHAxPi4pXFxcXFsoPzxwMj5bXlxcXFxdXSopXFxcXF1cIiwgcmVtb3ZlIG5hbWVkIGNhcHR1cmUgZ3JvdXAgQDI0MjhcbiAgICAgICAgICAgICAgICBtYXNrTWF0Y2hlcyA9IG1hc2subWF0Y2gobmV3IFJlZ0V4cChvcHRpb25hbFJlZ2V4LCBcImdcIikpO1xuICAgICAgICAgICAgbWFza01hdGNoZXMgJiYgbWFza01hdGNoZXMuZm9yRWFjaCgobSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBbcDEsIHAyXSA9IG0uc3BsaXQoXCJbXCIpOyBwMiA9IHAyLnJlcGxhY2UoXCJdXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIG1hc2sgPSBtYXNrLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtlc2NhcGVSZWdleChwMSl9XFxcXFske2VzY2FwZVJlZ2V4KHAyKX1cXFxcXWApLFxuICAgICAgICAgICAgICAgICAgICBwMS5jaGFyQXQoMCkgPT09IHAyLmNoYXJBdCgwKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7cDF9fCR7cDF9JHtwMn0pYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtwMX1bJHtwMn1dYCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobWFzayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTWFzayhtYXNrLCBtZXRhZGF0YSwgb3B0cykge1xuICAgICAgICB2YXIgcmVnZXhNYXNrID0gZmFsc2U7XG4gICAgICAgIGlmIChtYXNrID09PSBudWxsIHx8IG1hc2sgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJlZ2V4TWFzayA9IG9wdHMucmVnZXggIT09IG51bGw7XG4gICAgICAgICAgICBpZiAocmVnZXhNYXNrKSB7XG4gICAgICAgICAgICAgICAgbWFzayA9IG9wdHMucmVnZXg7XG4gICAgICAgICAgICAgICAgbWFzayA9IG1hc2sucmVwbGFjZSgvXihcXF4pKC4qKShcXCQpJC8sIFwiJDJcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2V4TWFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWFzayA9IFwiLipcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWFzay5sZW5ndGggPT09IDEgJiYgb3B0cy5ncmVlZHkgPT09IGZhbHNlICYmIG9wdHMucmVwZWF0ICE9PSAwKSB7XG4gICAgICAgICAgICBvcHRzLnBsYWNlaG9sZGVyID0gXCJcIjtcbiAgICAgICAgfSAvL2hpZGUgcGxhY2Vob2xkZXIgd2l0aCBzaW5nbGUgbm9uLWdyZWVkeSBtYXNrXG4gICAgICAgIG1hc2sgPSBwcmVQcm9jZXNzTWFzayhtYXNrLCBvcHRzKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhtYXNrKTtcbiAgICAgICAgdmFyIG1hc2tzZXREZWZpbml0aW9uLCBtYXNrZGVmS2V5O1xuICAgICAgICBtYXNrZGVmS2V5ID0gcmVnZXhNYXNrID8gXCJyZWdleF9cIiArIG9wdHMucmVnZXggOiBvcHRzLm51bWVyaWNJbnB1dCA/IG1hc2suc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIikgOiBtYXNrO1xuICAgICAgICBpZiAob3B0cy5rZWVwU3RhdGljICE9PSBudWxsKSB7IC8va2VlcHN0YXRpYyBtb2RpZmllcyB0aGUgb3V0cHV0IGZyb20gdGhlIHRlc3RkZWZpbml0aW9ucyB+IHNvIGRpZmZlcmVudGlhdGUgaW4gdGhlIG1hc2tjYWNoZVxuICAgICAgICAgICAgbWFza2RlZktleSA9IFwia3NfXCIgKyBvcHRzLmtlZXBTdGF0aWMgKyBtYXNrZGVmS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKElucHV0bWFzay5wcm90b3R5cGUubWFza3NDYWNoZVttYXNrZGVmS2V5XSA9PT0gdW5kZWZpbmVkIHx8IG5vY2FjaGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1hc2tzZXREZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgICAgIFwibWFza1wiOiBtYXNrLFxuICAgICAgICAgICAgICAgIFwibWFza1Rva2VuXCI6IElucHV0bWFzay5wcm90b3R5cGUuYW5hbHlzZU1hc2sobWFzaywgcmVnZXhNYXNrLCBvcHRzKSxcbiAgICAgICAgICAgICAgICBcInZhbGlkUG9zaXRpb25zXCI6IFtdLFxuICAgICAgICAgICAgICAgIFwiX2J1ZmZlclwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJidWZmZXJcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwidGVzdHNcIjoge30sXG4gICAgICAgICAgICAgICAgXCJleGNsdWRlc1wiOiB7fSwgLy9leGNsdWRlZCBhbHRlcm5hdGlvbnNcbiAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIFwibWFza0xlbmd0aFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJqaXRPZmZzZXRcIjoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobm9jYWNoZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIElucHV0bWFzay5wcm90b3R5cGUubWFza3NDYWNoZVttYXNrZGVmS2V5XSA9IG1hc2tzZXREZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIG1hc2tzZXREZWZpbml0aW9uID0gJC5leHRlbmQodHJ1ZSwge30sIElucHV0bWFzay5wcm90b3R5cGUubWFza3NDYWNoZVttYXNrZGVmS2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXNrc2V0RGVmaW5pdGlvbiA9ICQuZXh0ZW5kKHRydWUsIHt9LCBJbnB1dG1hc2sucHJvdG90eXBlLm1hc2tzQ2FjaGVbbWFza2RlZktleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hc2tzZXREZWZpbml0aW9uO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5tYXNrID09PSBcImZ1bmN0aW9uXCIpIHsgLy9hbGxvdyBtYXNrIHRvIGJlIGEgcHJlcHJvY2Vzc2luZyBmbiAtIHNob3VsZCByZXR1cm4gYSB2YWxpZCBtYXNrXG4gICAgICAgIG9wdHMubWFzayA9IG9wdHMubWFzayhvcHRzKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5tYXNrKSkge1xuICAgICAgICBpZiAob3B0cy5tYXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmtlZXBTdGF0aWMgPT09IG51bGwpIHsgLy9lbmFibGUgYnkgZGVmYXVsdCB3aGVuIHBhc3NpbmcgbXVsdGlwbGUgbWFza3Mgd2hlbiB0aGUgb3B0aW9uIGlzIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIG9wdHMua2VlcFN0YXRpYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWx0TWFzayA9IG9wdHMuZ3JvdXBtYXJrZXJbMF07XG4gICAgICAgICAgICAob3B0cy5pc1JUTCA/IG9wdHMubWFzay5yZXZlcnNlKCkgOiBvcHRzLm1hc2spLmZvckVhY2goZnVuY3Rpb24gKG1zaykge1xuICAgICAgICAgICAgICAgIGlmIChhbHRNYXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0TWFzayArPSBvcHRzLmFsdGVybmF0b3JtYXJrZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtc2subWFzayAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBtc2subWFzayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsdE1hc2sgKz0gbXNrLm1hc2s7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0TWFzayArPSBtc2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbHRNYXNrICs9IG9wdHMuZ3JvdXBtYXJrZXJbMV07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhhbHRNYXNrKTtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZU1hc2soYWx0TWFzaywgb3B0cy5tYXNrLCBvcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMubWFzayA9IG9wdHMubWFzay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5tYXNrICYmIG9wdHMubWFzay5tYXNrICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdHMubWFzay5tYXNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbXMgPSBnZW5lcmF0ZU1hc2sob3B0cy5tYXNrLm1hc2ssIG9wdHMubWFzaywgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbXMgPSBnZW5lcmF0ZU1hc2sob3B0cy5tYXNrLCBvcHRzLm1hc2ssIG9wdHMpO1xuICAgIH1cbiAgICBpZiAob3B0cy5rZWVwU3RhdGljID09PSBudWxsKSBvcHRzLmtlZXBTdGF0aWMgPSBmYWxzZTtcbiAgICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIGFuYWx5c2VNYXNrKG1hc2ssIHJlZ2V4TWFzaywgb3B0cykge1xuICAgIGNvbnN0IHRva2VuaXplciA9IC8oPzpbPyorXXxcXHtbMC05KypdKyg/OixbMC05KypdKik/KD86XFx8WzAtOSsqXSopP1xcfSl8W14uPyorXiR7W10oKXxcXFxcXSt8Li9nLFxuICAgICAgICAvL1RoeCB0byBodHRwczovL2dpdGh1Yi5jb20vc2xldml0aGFuL3JlZ2V4LWNvbG9yaXplciBmb3IgdGhlIHJlZ2V4VG9rZW5pemVyIHJlZ2V4XG4gICAgICAgIHJlZ2V4VG9rZW5pemVyID0gL1xcW1xcXj9dPyg/OlteXFxcXFxcXV0rfFxcXFxbXFxTXFxzXT8pKl0/fFxcXFwoPzowKD86WzAtM11bMC03XXswLDJ9fFs0LTddWzAtN10/KT98WzEtOV1bMC05XSp8eFswLTlBLUZhLWZdezJ9fHVbMC05QS1GYS1mXXs0fXxjW0EtWmEtel18W1xcU1xcc10/KXxcXCgoPzpcXD9bOj0hXT8pP3woPzpbPyorXXxcXHtbMC05XSsoPzosWzAtOV0qKT9cXH0pXFw/P3xbXi4/KiteJHtbKCl8XFxcXF0rfC4vZztcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLFxuICAgICAgICBjdXJyZW50VG9rZW4gPSBuZXcgTWFza1Rva2VuKCksXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtLFxuICAgICAgICBvcGVuZW5pbmdzID0gW10sXG4gICAgICAgIG1hc2tUb2tlbnMgPSBbXSxcbiAgICAgICAgb3BlbmluZ1Rva2VuLFxuICAgICAgICBjdXJyZW50T3BlbmluZ1Rva2VuLFxuICAgICAgICBhbHRlcm5hdG9yLFxuICAgICAgICBsYXN0TWF0Y2gsXG4gICAgICAgIGNsb3NlUmVnZXhHcm91cCA9IGZhbHNlO1xuXG4gICAgLy90ZXN0IGRlZmluaXRpb24gPT4ge2ZuOiBSZWdFeHAvZnVuY3Rpb24sIHN0YXRpYzogdHJ1ZS9mYWxzZSBvcHRpb25hbGl0eTogYm9vbCwgbmV3QmxvY2tNYXJrZXI6IGJvb2wsIGNhc2luZzogbnVsbC91cHBlci9sb3dlciwgZGVmOiBkZWZpbml0aW9uU3ltYm9sLCBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsIG1hc2s6IHJlYWwgbWFza0RlZmluaXRpb259XG4gICAgZnVuY3Rpb24gaW5zZXJ0VGVzdERlZmluaXRpb24obXRva2VuLCBlbGVtZW50LCBwb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICE9PSB1bmRlZmluZWQgPyBwb3NpdGlvbiA6IG10b2tlbi5tYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHByZXZNYXRjaCA9IG10b2tlbi5tYXRjaGVzW3Bvc2l0aW9uIC0gMV07XG4gICAgICAgIGlmIChyZWdleE1hc2spIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmluZGV4T2YoXCJbXCIpID09PSAwIHx8IChlc2NhcGVkICYmIC9cXFxcZHxcXFxcc3xcXFxcd3xcXFxccC9pLnRlc3QoZWxlbWVudCkpIHx8IGVsZW1lbnQgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZsYWcgPSBvcHRzLmNhc2luZyA/IFwiaVwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoL15cXFxccFxcey4qfSQvaS50ZXN0KGVsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICBmbGFnICs9IFwidVwiO1xuICAgICAgICAgICAgICAgIG10b2tlbi5tYXRjaGVzLnNwbGljZShwb3NpdGlvbisrLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgIGZuOiBuZXcgUmVnRXhwKGVsZW1lbnQsIGZsYWcpLFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbGl0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrTWFya2VyOiBwcmV2TWF0Y2ggPT09IHVuZGVmaW5lZCA/IFwibWFzdGVyXCIgOiBwcmV2TWF0Y2guZGVmICE9PSBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGRlZjogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRGVmOiBlbGVtZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkKSBlbGVtZW50ID0gZWxlbWVudFtlbGVtZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3BsaXQoXCJcIikuZm9yRWFjaChmdW5jdGlvbiAobG1udCwgbmR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZNYXRjaCA9IG10b2tlbi5tYXRjaGVzW3Bvc2l0aW9uIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIG10b2tlbi5tYXRjaGVzLnNwbGljZShwb3NpdGlvbisrLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbjogL1thLXpdL2kudGVzdCgob3B0cy5zdGF0aWNEZWZpbml0aW9uU3ltYm9sIHx8IGxtbnQpKSA/IG5ldyBSZWdFeHAoXCJbXCIgKyAob3B0cy5zdGF0aWNEZWZpbml0aW9uU3ltYm9sIHx8IGxtbnQpICsgXCJdXCIsIG9wdHMuY2FzaW5nID8gXCJpXCIgOiBcIlwiKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbGl0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9ja01hcmtlcjogcHJldk1hdGNoID09PSB1bmRlZmluZWQgPyBcIm1hc3RlclwiIDogKHByZXZNYXRjaC5kZWYgIT09IGxtbnQgJiYgcHJldk1hdGNoLnN0YXRpYyAhPT0gdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IG9wdHMuc3RhdGljRGVmaW5pdGlvblN5bWJvbCB8fCBsbW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IG9wdHMuc3RhdGljRGVmaW5pdGlvblN5bWJvbCAhPT0gdW5kZWZpbmVkID8gbG1udCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZURlZjogKGVzY2FwZWQgPyBcIidcIiA6IFwiXCIpICsgbG1udFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXNrZGVmID0gKG9wdHMuZGVmaW5pdGlvbnMgJiYgb3B0cy5kZWZpbml0aW9uc1tlbGVtZW50XSkgfHwgKG9wdHMudXNlUHJvdG90eXBlRGVmaW5pdGlvbnMgJiYgSW5wdXRtYXNrLnByb3RvdHlwZS5kZWZpbml0aW9uc1tlbGVtZW50XSk7XG4gICAgICAgICAgICBpZiAobWFza2RlZiAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgIG10b2tlbi5tYXRjaGVzLnNwbGljZShwb3NpdGlvbisrLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgIGZuOiBtYXNrZGVmLnZhbGlkYXRvciA/IHR5cGVvZiBtYXNrZGVmLnZhbGlkYXRvciA9PSBcInN0cmluZ1wiID8gbmV3IFJlZ0V4cChtYXNrZGVmLnZhbGlkYXRvciwgb3B0cy5jYXNpbmcgPyBcImlcIiA6IFwiXCIpIDogbmV3IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGVzdCA9IG1hc2tkZWYudmFsaWRhdG9yO1xuICAgICAgICAgICAgICAgICAgICB9IDogbmV3IFJlZ0V4cChcIi5cIiksXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpYzogbWFza2RlZi5zdGF0aWMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsaXR5OiBtYXNrZGVmLm9wdGlvbmFsIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZWZPcHRpb25hbGl0eTogbWFza2RlZi5vcHRpb25hbCB8fCBmYWxzZSwgLy9pbmRpY2F0b3IgZm9yIGFuIG9wdGlvbmFsIGZyb20gdGhlIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgbmV3QmxvY2tNYXJrZXI6IChwcmV2TWF0Y2ggPT09IHVuZGVmaW5lZCB8fCBtYXNrZGVmLm9wdGlvbmFsKSA/IFwibWFzdGVyXCIgOiBwcmV2TWF0Y2guZGVmICE9PSAobWFza2RlZi5kZWZpbml0aW9uU3ltYm9sIHx8IGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IG1hc2tkZWYuY2FzaW5nLFxuICAgICAgICAgICAgICAgICAgICBkZWY6IG1hc2tkZWYuZGVmaW5pdGlvblN5bWJvbCB8fCBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbWFza2RlZi5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRGVmOiBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IG1hc2tkZWYuZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG10b2tlbi5tYXRjaGVzLnNwbGljZShwb3NpdGlvbisrLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgIGZuOiAvW2Etel0vaS50ZXN0KChvcHRzLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgZWxlbWVudCkpID8gbmV3IFJlZ0V4cChcIltcIiArIChvcHRzLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgZWxlbWVudCkgKyBcIl1cIiwgb3B0cy5jYXNpbmcgPyBcImlcIiA6IFwiXCIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbGl0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrTWFya2VyOiBwcmV2TWF0Y2ggPT09IHVuZGVmaW5lZCA/IFwibWFzdGVyXCIgOiAocHJldk1hdGNoLmRlZiAhPT0gZWxlbWVudCAmJiBwcmV2TWF0Y2guc3RhdGljICE9PSB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBkZWY6IG9wdHMuc3RhdGljRGVmaW5pdGlvblN5bWJvbCB8fCBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogb3B0cy5zdGF0aWNEZWZpbml0aW9uU3ltYm9sICE9PSB1bmRlZmluZWQgPyBlbGVtZW50IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVEZWY6IChlc2NhcGVkID8gXCInXCIgOiBcIlwiKSArIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2ZXJpZnlHcm91cE1hcmtlcihtYXNrVG9rZW4pIHtcbiAgICAgICAgaWYgKG1hc2tUb2tlbiAmJiBtYXNrVG9rZW4ubWF0Y2hlcykge1xuICAgICAgICAgICAgbWFza1Rva2VuLm1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4sIG5keCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSBtYXNrVG9rZW4ubWF0Y2hlc1tuZHggKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHRUb2tlbiA9PT0gdW5kZWZpbmVkIHx8IChuZXh0VG9rZW4ubWF0Y2hlcyA9PT0gdW5kZWZpbmVkIHx8IG5leHRUb2tlbi5pc1F1YW50aWZpZXIgPT09IGZhbHNlKSkgJiYgdG9rZW4gJiYgdG9rZW4uaXNHcm91cCkgeyAvL3RoaXMgaXMgbm90IGEgZ3JvdXAgYnV0IGEgbm9ybWFsIG1hc2sgPT4gY29udmVydFxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5pc0dyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVnZXhNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXN0RGVmaW5pdGlvbih0b2tlbiwgb3B0cy5ncm91cG1hcmtlclswXSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4ub3Blbkdyb3VwICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGVzdERlZmluaXRpb24odG9rZW4sIG9wdHMuZ3JvdXBtYXJrZXJbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZlcmlmeUdyb3VwTWFya2VyKHRva2VuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdENhc2UoKSB7XG4gICAgICAgIGlmIChvcGVuZW5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRPcGVuaW5nVG9rZW4gPSBvcGVuZW5pbmdzW29wZW5lbmluZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpbnNlcnRUZXN0RGVmaW5pdGlvbihjdXJyZW50T3BlbmluZ1Rva2VuLCBtKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50T3BlbmluZ1Rva2VuLmlzQWx0ZXJuYXRvcikgeyAvL2hhbmRsZSBhbHRlcm5hdG9yIGEgfCBiIGNhc2VcbiAgICAgICAgICAgICAgICBhbHRlcm5hdG9yID0gb3BlbmVuaW5ncy5wb3AoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtbmR4ID0gMDsgbW5keCA8IGFsdGVybmF0b3IubWF0Y2hlcy5sZW5ndGg7IG1uZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWx0ZXJuYXRvci5tYXRjaGVzW21uZHhdLmlzR3JvdXApIGFsdGVybmF0b3IubWF0Y2hlc1ttbmR4XS5pc0dyb3VwID0gZmFsc2U7IC8vZG9uJ3QgbWFyayBhbHRlcm5hdGUgZ3JvdXBzIGFzIGdyb3VwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcGVuZW5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5pbmdUb2tlbiA9IG9wZW5lbmluZ3Nbb3BlbmVuaW5ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5pbmdUb2tlbi5tYXRjaGVzLnB1c2goYWx0ZXJuYXRvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuLm1hdGNoZXMucHVzaChhbHRlcm5hdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRUZXN0RGVmaW5pdGlvbihjdXJyZW50VG9rZW4sIG0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV2ZXJzZVRva2VucyhtYXNrVG9rZW4pIHtcbiAgICAgICAgZnVuY3Rpb24gcmV2ZXJzZVN0YXRpYyhzdCkge1xuICAgICAgICAgICAgaWYgKHN0ID09PSBvcHRzLm9wdGlvbmFsbWFya2VyWzBdKSB7XG4gICAgICAgICAgICAgICAgc3QgPSBvcHRzLm9wdGlvbmFsbWFya2VyWzFdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdCA9PT0gb3B0cy5vcHRpb25hbG1hcmtlclsxXSkge1xuICAgICAgICAgICAgICAgIHN0ID0gb3B0cy5vcHRpb25hbG1hcmtlclswXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3QgPT09IG9wdHMuZ3JvdXBtYXJrZXJbMF0pIHtcbiAgICAgICAgICAgICAgICBzdCA9IG9wdHMuZ3JvdXBtYXJrZXJbMV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0ID09PSBvcHRzLmdyb3VwbWFya2VyWzFdKSBzdCA9IG9wdHMuZ3JvdXBtYXJrZXJbMF07XG5cbiAgICAgICAgICAgIHJldHVybiBzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tUb2tlbi5tYXRjaGVzID0gbWFza1Rva2VuLm1hdGNoZXMucmV2ZXJzZSgpO1xuICAgICAgICBmb3IgKHZhciBtYXRjaCBpbiBtYXNrVG9rZW4ubWF0Y2hlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXNrVG9rZW4ubWF0Y2hlcywgbWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludE1hdGNoID0gcGFyc2VJbnQobWF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChtYXNrVG9rZW4ubWF0Y2hlc1ttYXRjaF0uaXNRdWFudGlmaWVyICYmIG1hc2tUb2tlbi5tYXRjaGVzW2ludE1hdGNoICsgMV0gJiYgbWFza1Rva2VuLm1hdGNoZXNbaW50TWF0Y2ggKyAxXS5pc0dyb3VwKSB7IC8vcmVwb3NpdGlvbiBxdWFudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdCA9IG1hc2tUb2tlbi5tYXRjaGVzW21hdGNoXTtcbiAgICAgICAgICAgICAgICAgICAgbWFza1Rva2VuLm1hdGNoZXMuc3BsaWNlKG1hdGNoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgbWFza1Rva2VuLm1hdGNoZXMuc3BsaWNlKGludE1hdGNoICsgMSwgMCwgcXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFza1Rva2VuLm1hdGNoZXNbbWF0Y2hdLm1hdGNoZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXNrVG9rZW4ubWF0Y2hlc1ttYXRjaF0gPSByZXZlcnNlVG9rZW5zKG1hc2tUb2tlbi5tYXRjaGVzW21hdGNoXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFza1Rva2VuLm1hdGNoZXNbbWF0Y2hdID0gcmV2ZXJzZVN0YXRpYyhtYXNrVG9rZW4ubWF0Y2hlc1ttYXRjaF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXNrVG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3JvdXBpZnkobWF0Y2hlcykge1xuICAgICAgICB2YXIgZ3JvdXBUb2tlbiA9IG5ldyBNYXNrVG9rZW4odHJ1ZSk7XG4gICAgICAgIGdyb3VwVG9rZW4ub3Blbkdyb3VwID0gZmFsc2U7XG4gICAgICAgIGdyb3VwVG9rZW4ubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgICAgIHJldHVybiBncm91cFRva2VuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlR3JvdXAoKSB7XG4gICAgICAgIC8vIEdyb3VwIGNsb3NpbmdcbiAgICAgICAgb3BlbmluZ1Rva2VuID0gb3BlbmVuaW5ncy5wb3AoKTtcbiAgICAgICAgb3BlbmluZ1Rva2VuLm9wZW5Hcm91cCA9IGZhbHNlOyAvL21hcmsgZ3JvdXAgYXMgY29tcGxldGVcbiAgICAgICAgaWYgKG9wZW5pbmdUb2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob3BlbmVuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE9wZW5pbmdUb2tlbiA9IG9wZW5lbmluZ3Nbb3BlbmVuaW5ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50T3BlbmluZ1Rva2VuLm1hdGNoZXMucHVzaChvcGVuaW5nVG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50T3BlbmluZ1Rva2VuLmlzQWx0ZXJuYXRvcikgeyAvL2hhbmRsZSBhbHRlcm5hdG9yIChhKSB8IChiKSBjYXNlXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0b3IgPSBvcGVuZW5pbmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWx0TWF0Y2hlc0xlbmd0aCA9IGFsdGVybmF0b3IubWF0Y2hlc1swXS5tYXRjaGVzID8gYWx0ZXJuYXRvci5tYXRjaGVzWzBdLm1hdGNoZXMubGVuZ3RoIDogMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbW5keCA9IDA7IG1uZHggPCBhbHRlcm5hdG9yLm1hdGNoZXMubGVuZ3RoOyBtbmR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0b3IubWF0Y2hlc1ttbmR4XS5pc0dyb3VwID0gZmFsc2U7IC8vZG9uJ3QgbWFyayBhbHRlcm5hdGUgZ3JvdXBzIGFzIGdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdG9yLm1hdGNoZXNbbW5keF0uYWx0ZXJuYXRvckdyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5rZWVwU3RhdGljID09PSBudWxsICYmIGFsdE1hdGNoZXNMZW5ndGggPCAoYWx0ZXJuYXRvci5tYXRjaGVzW21uZHhdLm1hdGNoZXMgPyBhbHRlcm5hdG9yLm1hdGNoZXNbbW5keF0ubWF0Y2hlcy5sZW5ndGggOiAxKSkgeyAvL2VuYWJsZSBieSBkZWZhdWx0IHdoZW4gcGFzc2luZyBtdWx0aXBsZSBtYXNrcyB3aGVuIHRoZSBvcHRpb24gaXMgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5rZWVwU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdE1hdGNoZXNMZW5ndGggPSBhbHRlcm5hdG9yLm1hdGNoZXNbbW5keF0ubWF0Y2hlcyA/IGFsdGVybmF0b3IubWF0Y2hlc1ttbmR4XS5tYXRjaGVzLmxlbmd0aCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lbmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5pbmdUb2tlbiA9IG9wZW5lbmluZ3Nbb3BlbmVuaW5ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVuaW5nVG9rZW4ubWF0Y2hlcy5wdXNoKGFsdGVybmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuLm1hdGNoZXMucHVzaChhbHRlcm5hdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRva2VuLm1hdGNoZXMucHVzaChvcGVuaW5nVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdENhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdyb3VwUXVhbnRpZmllcihtYXRjaGVzKSB7XG4gICAgICAgIHZhciBsYXN0TWF0Y2ggPSBtYXRjaGVzLnBvcCgpO1xuICAgICAgICBpZiAobGFzdE1hdGNoLmlzUXVhbnRpZmllcikge1xuICAgICAgICAgICAgbGFzdE1hdGNoID0gZ3JvdXBpZnkoW21hdGNoZXMucG9wKCksIGxhc3RNYXRjaF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0TWF0Y2g7XG4gICAgfVxuXG4gICAgaWYgKHJlZ2V4TWFzaykge1xuICAgICAgICBvcHRzLm9wdGlvbmFsbWFya2VyWzBdID0gdW5kZWZpbmVkO1xuICAgICAgICBvcHRzLm9wdGlvbmFsbWFya2VyWzFdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXhNYXNrID8gcmVnZXhUb2tlbml6ZXIuZXhlYyhtYXNrKSA6IHRva2VuaXplci5leGVjKG1hc2spKSkge1xuICAgICAgICBtID0gbWF0Y2hbMF07XG5cbiAgICAgICAgaWYgKHJlZ2V4TWFzaykge1xuICAgICAgICAgICAgc3dpdGNoIChtLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgIC8vUXVhbnRpZmllclxuICAgICAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgICAgIG0gPSBcInswLDF9XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAgICAgbSA9IFwie1wiICsgbSArIFwifVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgICAgICAvL3JlZ2V4IG1hc2sgYWx0ZXJuYXRvciAgZXg6IFswMV1bMC05XXwyWzAtM10gPT4gKFswMV1bMC05XXwyWzAtM10pXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZW5pbmdzLmxlbmd0aCA9PT0gMCkgeyAvL3dyYXAgdGhlIG1hc2sgaW4gYSBncm91cCB0byBmb3JtIGEgcmVnZXggYWx0ZXJuYXRvciAgKFswMV1bMC05XXwyWzAtM10pXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWx0UmVnZXhHcm91cCA9IGdyb3VwaWZ5KGN1cnJlbnRUb2tlbi5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdFJlZ2V4R3JvdXAub3Blbkdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lbmluZ3MucHVzaChhbHRSZWdleEdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbi5tYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZVJlZ2V4R3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChtKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxkXCI6XG4gICAgICAgICAgICAgICAgICAgIG0gPSBcIlswLTldXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxccFwiOiAvL1VuaWNvZGUgQ2F0ZWdvcmllc1xuICAgICAgICAgICAgICAgICAgICBtICs9IHJlZ2V4VG9rZW5pemVyLmV4ZWMobWFzaylbMF07IC8vIHtcbiAgICAgICAgICAgICAgICAgICAgbSArPSByZWdleFRva2VuaXplci5leGVjKG1hc2spWzBdOyAvLyA/fVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiKD86XCI6IC8vbm9uIGNhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgICAgIGNhc2UgXCIoPz1cIjogLy9sb29rYWhlYWRcbiAgICAgICAgICAgICAgICBjYXNlIFwiKD8hXCI6IC8vbmVnYXRpdmUgbG9va2FoZWFkXG4gICAgICAgICAgICAgICAgY2FzZSBcIig/PD1cIjogLy9sb29rYmVoaW5kXG4gICAgICAgICAgICAgICAgY2FzZSBcIig/PCFcIjogLy9uZWdhdGl2ZSBsb29rYmVoaW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyZWF0IGFzIGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRDYXNlKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG0uY2hhckF0KDApKSB7XG4gICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgICAgICAvL2lnbm9yZSBiZWdpbnN3aXRoIGFuZCBlbmRzd2l0aCBhcyBpbiBtYXNraW5nIHRoaXMgbWFrZXMgbm8gcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4TWFzaykge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugb3B0cy5lc2NhcGVDaGFyOlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleE1hc2spIGRlZmF1bHRDYXNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBvcHRpb25hbCBjbG9zaW5nXG4gICAgICAgICAgICBjYXNlIG9wdHMub3B0aW9uYWxtYXJrZXJbMV06XG4gICAgICAgICAgICBjYXNlIG9wdHMuZ3JvdXBtYXJrZXJbMV06XG4gICAgICAgICAgICAgICAgY2xvc2VHcm91cCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvcHRzLm9wdGlvbmFsbWFya2VyWzBdOlxuICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIG9wZW5pbmdcbiAgICAgICAgICAgICAgICBvcGVuZW5pbmdzLnB1c2gobmV3IE1hc2tUb2tlbihmYWxzZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvcHRzLmdyb3VwbWFya2VyWzBdOlxuICAgICAgICAgICAgICAgIC8vIEdyb3VwIG9wZW5pbmdcbiAgICAgICAgICAgICAgICBvcGVuZW5pbmdzLnB1c2gobmV3IE1hc2tUb2tlbih0cnVlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG9wdHMucXVhbnRpZmllcm1hcmtlclswXTpcbiAgICAgICAgICAgICAgICAvL1F1YW50aWZpZXJcbiAgICAgICAgICAgICAgICB2YXIgcXVhbnRpZmllciA9IG5ldyBNYXNrVG9rZW4oZmFsc2UsIGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIG0gPSBtLnJlcGxhY2UoL1t7fT9dL2csIFwiXCIpOyAvLz8gbWF0Y2hlcyBsYXp5IHF1YW50aWZpZXJzXG4gICAgICAgICAgICAgICAgdmFyIG1xaiA9IG0uc3BsaXQoXCJ8XCIpLFxuICAgICAgICAgICAgICAgICAgICBtcSA9IG1xalswXS5zcGxpdChcIixcIiksXG4gICAgICAgICAgICAgICAgICAgIG1xMCA9IGlzTmFOKG1xWzBdKSA/IG1xWzBdIDogcGFyc2VJbnQobXFbMF0pLFxuICAgICAgICAgICAgICAgICAgICBtcTEgPSBtcS5sZW5ndGggPT09IDEgPyBtcTAgOiAoaXNOYU4obXFbMV0pID8gbXFbMV0gOiBwYXJzZUludChtcVsxXSkpLFxuICAgICAgICAgICAgICAgICAgICBtcUppdCA9IGlzTmFOKG1xalsxXSkgPyBtcWpbMV0gOiBwYXJzZUludChtcWpbMV0pO1xuICAgICAgICAgICAgICAgIGlmIChtcTAgPT09IFwiKlwiIHx8IG1xMCA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXEwID0gbXExID09PSBcIipcIiA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWFudGlmaWVyLnF1YW50aWZpZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbjogbXEwLFxuICAgICAgICAgICAgICAgICAgICBtYXg6IG1xMSxcbiAgICAgICAgICAgICAgICAgICAgaml0OiBtcUppdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBvcGVuZW5pbmdzLmxlbmd0aCA+IDAgPyBvcGVuZW5pbmdzW29wZW5lbmluZ3MubGVuZ3RoIC0gMV0ubWF0Y2hlcyA6IGN1cnJlbnRUb2tlbi5tYXRjaGVzO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiAobWF0Y2guaXNBbHRlcm5hdG9yKSB7IC8vaGFuZGxlIHF1YW50aWZpZXIgaW4gYW4gYWx0ZXJuYXRpb24gWzAtOV17Mn18WzAtOV17M31cbiAgICAgICAgICAgICAgICAvLyAgICAgbWF0Y2hlcy5wdXNoKG1hdGNoKTsgLy9wdXNoIGJhY2sgYWx0ZXJuYXRvclxuICAgICAgICAgICAgICAgIC8vICAgICBtYXRjaGVzID0gbWF0Y2gubWF0Y2hlczsgLy9yZW1hcCB0YXJnZXQgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgZ3JvdXBUb2tlbiA9IG5ldyBNYXNrVG9rZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gICAgIHZhciB0bXBNYXRjaCA9IG1hdGNoZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgLy8gICAgIG1hdGNoZXMucHVzaChncm91cFRva2VuKTsgLy9wdXNoIHRoZSBncm91cFxuICAgICAgICAgICAgICAgIC8vICAgICBtYXRjaGVzID0gZ3JvdXBUb2tlbi5tYXRjaGVzO1xuICAgICAgICAgICAgICAgIC8vICAgICBtYXRjaCA9IHRtcE1hdGNoO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBncm91cGlmeShbbWF0Y2hdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gocXVhbnRpZmllcik7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugb3B0cy5hbHRlcm5hdG9ybWFya2VyOlxuICAgICAgICAgICAgICAgIGlmIChvcGVuZW5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5pbmdUb2tlbiA9IG9wZW5lbmluZ3Nbb3BlbmVuaW5ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlRva2VuID0gY3VycmVudE9wZW5pbmdUb2tlbi5tYXRjaGVzW2N1cnJlbnRPcGVuaW5nVG9rZW4ubWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRPcGVuaW5nVG9rZW4ub3Blbkdyb3VwICYmIC8vcmVnZXhwIGFsdCBzeW50YXhcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdWJUb2tlbi5tYXRjaGVzID09PSB1bmRlZmluZWQgfHwgKHN1YlRva2VuLmlzR3JvdXAgPT09IGZhbHNlICYmIHN1YlRva2VuLmlzQWx0ZXJuYXRvciA9PT0gZmFsc2UpKSkgeyAvL2FsdGVybmF0aW9ucyB3aXRoaW4gZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNYXRjaCA9IG9wZW5lbmluZ3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWF0Y2ggPSBncm91cFF1YW50aWZpZXIoY3VycmVudE9wZW5pbmdUb2tlbi5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNYXRjaCA9IGdyb3VwUXVhbnRpZmllcihjdXJyZW50VG9rZW4ubWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0TWF0Y2guaXNBbHRlcm5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lbmluZ3MucHVzaChsYXN0TWF0Y2gpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TWF0Y2guYWx0ZXJuYXRvckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdG9yID0gb3BlbmVuaW5ncy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNYXRjaC5hbHRlcm5hdG9yR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0b3IgPSBuZXcgTWFza1Rva2VuKGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0b3IubWF0Y2hlcy5wdXNoKGxhc3RNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lbmluZ3MucHVzaChhbHRlcm5hdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RNYXRjaC5vcGVuR3JvdXApIHsgLy9yZWdleHAgYWx0IHN5bnRheFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1hdGNoLm9wZW5Hcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsdGVybmF0b3JHcm91cCA9IG5ldyBNYXNrVG9rZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdG9yR3JvdXAuYWx0ZXJuYXRvckdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lbmluZ3MucHVzaChhbHRlcm5hdG9yR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsb3NlUmVnZXhHcm91cCkgY2xvc2VHcm91cCgpO1xuXG4gICAgd2hpbGUgKG9wZW5lbmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBvcGVuaW5nVG9rZW4gPSBvcGVuZW5pbmdzLnBvcCgpO1xuICAgICAgICBjdXJyZW50VG9rZW4ubWF0Y2hlcy5wdXNoKG9wZW5pbmdUb2tlbik7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VG9rZW4ubWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZlcmlmeUdyb3VwTWFya2VyKGN1cnJlbnRUb2tlbik7XG4gICAgICAgIG1hc2tUb2tlbnMucHVzaChjdXJyZW50VG9rZW4pO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm51bWVyaWNJbnB1dCB8fCBvcHRzLmlzUlRMKSB7XG4gICAgICAgIHJldmVyc2VUb2tlbnMobWFza1Rva2Vuc1swXSk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG1hc2tUb2tlbnMpKTtcbiAgICByZXR1cm4gbWFza1Rva2Vucztcbn1cbiIsImltcG9ydCB7a2V5c30gZnJvbSBcIi4va2V5Y29kZS5qc1wiO1xuaW1wb3J0IHtjYXJldCwgZ2V0QnVmZmVyLCBnZXRCdWZmZXJUZW1wbGF0ZSwgZ2V0TGFzdFZhbGlkUG9zaXRpb24sIHJlc2V0TWFza1NldCwgc2Vla05leHR9IGZyb20gXCIuL3Bvc2l0aW9uaW5nXCI7XG5pbXBvcnQge2FwcGx5SW5wdXRWYWx1ZSwgY2xlYXJPcHRpb25hbFRhaWwsIHdyaXRlQnVmZmVyfSBmcm9tIFwiLi9pbnB1dEhhbmRsaW5nXCI7XG5pbXBvcnQge0V2ZW50UnVsZXJ9IGZyb20gXCIuL2V2ZW50cnVsZXJcIjtcbmltcG9ydCB7aXBob25lLCBtb2JpbGV9IGZyb20gXCIuL2Vudmlyb25tZW50XCI7XG5pbXBvcnQge2lzQ29tcGxldGV9IGZyb20gXCIuL3ZhbGlkYXRpb25cIjtcbmltcG9ydCB7RXZlbnRIYW5kbGVyc30gZnJvbSBcIi4vZXZlbnRoYW5kbGVyc1wiO1xuXG5leHBvcnQge21hc2t9O1xuXG4vL3RvZG8gcHV0IG9uIHRoZSBwcm90b3R5cGU/XG5mdW5jdGlvbiBtYXNrKCkge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMsXG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHMsXG4gICAgICAgIGVsID0gdGhpcy5lbCwgJCA9IHRoaXMuZGVwZW5kZW5jeUxpYjtcblxuXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50VHlwZVN1cHBvcnRlZChpbnB1dCwgb3B0cykge1xuICAgICAgICBmdW5jdGlvbiBwYXRjaFZhbHVlUHJvcGVydHkobnB0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVHZXQ7XG4gICAgICAgICAgICB2YXIgdmFsdWVTZXQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhdGNoVmFsaG9vayh0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQudmFsSG9va3MgJiYgKCQudmFsSG9va3NbdHlwZV0gPT09IHVuZGVmaW5lZCB8fCAkLnZhbEhvb2tzW3R5cGVdLmlucHV0bWFza3BhdGNoICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaG9va0dldCA9ICQudmFsSG9va3NbdHlwZV0gJiYgJC52YWxIb29rc1t0eXBlXS5nZXQgPyAkLnZhbEhvb2tzW3R5cGVdLmdldCA6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGhvb2tTZXQgPSAkLnZhbEhvb2tzW3R5cGVdICYmICQudmFsSG9va3NbdHlwZV0uc2V0ID8gJC52YWxIb29rc1t0eXBlXS5zZXQgOiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICQudmFsSG9va3NbdHlwZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uaW5wdXRtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLmlucHV0bWFzay5vcHRzLmF1dG9Vbm1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmlucHV0bWFzay51bm1hc2tlZHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsaG9va0dldChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGVsZW0uaW5wdXRtYXNrLm1hc2tzZXQudmFsaWRQb3NpdGlvbnMpICE9PSAtMSB8fCBvcHRzLm51bGxhYmxlICE9PSB0cnVlID8gcmVzdWx0IDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxob29rR2V0KGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWxob29rU2V0KGVsZW0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5pbnB1dG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlJbnB1dFZhbHVlKGVsZW0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1hc2twYXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0dGVyKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0bWFzaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dG1hc2sub3B0cy5hdXRvVW5tYXNrID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRtYXNrLnVubWFza2VkdmFsdWUoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAoZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChpbnB1dG1hc2spICE9PSAtMSB8fCBvcHRzLm51bGxhYmxlICE9PSB0cnVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCh0aGlzLmlucHV0bWFzay5zaGFkb3dSb290IHx8IHRoaXMub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCkgPT09IHRoaXMgJiYgb3B0cy5jbGVhck1hc2tPbkxvc3RGb2N1cyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbnB1dG1hc2suaXNSVEwgPyBjbGVhck9wdGlvbmFsVGFpbC5jYWxsKGlucHV0bWFzaywgZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKS5zbGljZSgpKS5yZXZlcnNlKCkgOiBjbGVhck9wdGlvbmFsVGFpbC5jYWxsKGlucHV0bWFzaywgZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKS5zbGljZSgpKSkuam9pbihcIlwiKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlR2V0LmNhbGwodGhpcykpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVHZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldHRlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlU2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0bWFzaykge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUlucHV0VmFsdWUodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaW5zdGFsbE5hdGl2ZVZhbHVlU2V0RmFsbGJhY2sobnB0KSB7XG4gICAgICAgICAgICAgICAgRXZlbnRSdWxlci5vbihucHQsIFwibW91c2VlbnRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnB1dCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGlucHV0LmlucHV0bWFzay5fdmFsdWVHZXQodHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJWYWx1ZSA9IChpbnB1dC5pbnB1dG1hc2suaXNSVEwgPyBnZXRCdWZmZXIuY2FsbChpbnB1dC5pbnB1dG1hc2spLnNsaWNlKCkucmV2ZXJzZSgpIDogZ2V0QnVmZmVyLmNhbGwoaW5wdXQuaW5wdXRtYXNrKSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IGJ1ZmZlclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseUlucHV0VmFsdWUoaW5wdXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5wdC5pbnB1dG1hc2suX192YWx1ZUdldCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLm5vVmFsdWVQYXRjaGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlUHJvcGVydHkgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5nZXRQcm90b3R5cGVPZihucHQpLCBcInZhbHVlXCIpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlUHJvcGVydHkgJiYgdmFsdWVQcm9wZXJ0eS5nZXQgJiYgdmFsdWVQcm9wZXJ0eS5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUdldCA9IHZhbHVlUHJvcGVydHkuZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlU2V0ID0gdmFsdWVQcm9wZXJ0eS5zZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5wdCwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5wdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlR2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlU2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucHQsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50Ll9fbG9va3VwR2V0dGVyX18gJiYgbnB0Ll9fbG9va3VwR2V0dGVyX18oXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVHZXQgPSBucHQuX19sb29rdXBHZXR0ZXJfXyhcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTZXQgPSBucHQuX19sb29rdXBTZXR0ZXJfXyhcInZhbHVlXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBucHQuX19kZWZpbmVHZXR0ZXJfXyhcInZhbHVlXCIsIGdldHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBucHQuX19kZWZpbmVTZXR0ZXJfXyhcInZhbHVlXCIsIHNldHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbnB0LmlucHV0bWFzay5fX3ZhbHVlR2V0ID0gdmFsdWVHZXQ7IC8vc3RvcmUgbmF0aXZlIHByb3BlcnR5IGdldHRlclxuICAgICAgICAgICAgICAgICAgICBucHQuaW5wdXRtYXNrLl9fdmFsdWVTZXQgPSB2YWx1ZVNldDsgLy9zdG9yZSBuYXRpdmUgcHJvcGVydHkgc2V0dGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5wdC5pbnB1dG1hc2suX3ZhbHVlR2V0ID0gZnVuY3Rpb24gKG92ZXJydWxlUlRMKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dG1hc2suaXNSVEwgJiYgb3ZlcnJ1bGVSVEwgIT09IHRydWUgPyB2YWx1ZUdldC5jYWxsKHRoaXMuZWwpLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogdmFsdWVHZXQuY2FsbCh0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5wdC5pbnB1dG1hc2suX3ZhbHVlU2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBvdmVycnVsZVJUTCkgeyAvL251bGwgY2hlY2sgaXMgbmVlZGVkIGZvciBJRTggPT4gb3RoZXJ3aXNlIGNvbnZlcnRzIHRvIFwibnVsbFwiXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU2V0LmNhbGwodGhpcy5lbCwgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpID8gXCJcIiA6ICgob3ZlcnJ1bGVSVEwgIT09IHRydWUgJiYgaW5wdXRtYXNrLmlzUlRMKSA/IHZhbHVlLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlR2V0ID09PSB1bmRlZmluZWQpIHsgLy9qcXVlcnkudmFsIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlR2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoVmFsaG9vayhucHQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxOYXRpdmVWYWx1ZVNldEZhbGxiYWNrKG5wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgICAgICBvcHRzLmlnbm9yYWJsZXMucHVzaChrZXlzLkVudGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGlucHV0LmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgICAgIHZhciBpc1N1cHBvcnRlZCA9IChpbnB1dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBvcHRzLnN1cHBvcnRzSW5wdXRUeXBlLmluY2x1ZGVzKGVsZW1lbnRUeXBlKSkgfHwgaW5wdXQuaXNDb250ZW50RWRpdGFibGUgfHwgaW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInRleHRhcmVhXCI7XG4gICAgICAgIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIGVsZW1lbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZCA9IGVsLnR5cGUgPT09IFwidGV4dFwiOyAvL2FwcGx5IG1hc2sgb25seSBpZiB0aGUgdHlwZSBpcyBub3QgbmF0aXZlbHkgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgZWwgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZCA9IFwicGFydGlhbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N1cHBvcnRlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHBhdGNoVmFsdWVQcm9wZXJ0eShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dC5pbnB1dG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIC8vdW5iaW5kIGFsbCBldmVudHMgLSB0byBtYWtlIHN1cmUgdGhhdCBubyBvdGhlciBtYXNrIHdpbGwgaW50ZXJmZXJlIHdoZW4gcmUtbWFza2luZ1xuICAgIEV2ZW50UnVsZXIub2ZmKGVsKTtcbiAgICB2YXIgaXNTdXBwb3J0ZWQgPSBpc0VsZW1lbnRUeXBlU3VwcG9ydGVkKGVsLCBvcHRzKTtcbiAgICBpZiAoaXNTdXBwb3J0ZWQgIT09IGZhbHNlKSB7XG4gICAgICAgIGlucHV0bWFzay5vcmlnaW5hbFBsYWNlaG9sZGVyID0gZWwucGxhY2Vob2xkZXI7XG5cbiAgICAgICAgLy9yZWFkIG1heGxlbmd0aCBwcm9wIGZyb20gZWxcbiAgICAgICAgaW5wdXRtYXNrLm1heExlbmd0aCA9IGVsICE9PSB1bmRlZmluZWQgPyBlbC5tYXhMZW5ndGggOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpbnB1dG1hc2subWF4TGVuZ3RoID09PSAtMSkgaW5wdXRtYXNrLm1heExlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwiaW5wdXRNb2RlXCIgaW4gZWwgJiYgZWwuZ2V0QXR0cmlidXRlKFwiaW5wdXRtb2RlXCIpID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbC5pbnB1dE1vZGUgPSBvcHRzLmlucHV0bW9kZTtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImlucHV0bW9kZVwiLCBvcHRzLmlucHV0bW9kZSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChpc1N1cHBvcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb3B0cy5zaG93TWFza09uRm9jdXMgPSBvcHRzLnNob3dNYXNrT25Gb2N1cyAmJiBbXCJjYy1udW1iZXJcIiwgXCJjYy1leHBcIl0uaW5kZXhPZihlbC5hdXRvY29tcGxldGUpID09PSAtMTtcbiAgICAgICAgICAgIGlmIChpcGhvbmUpIHtcbiAgICAgICAgICAgICAgICAvL3NlbGVjdGluZyB0aGUgY2FyZXQgc2hvd3MgYXMgYSBzZWxlY3Rpb24gb24gaXBob25lXG4gICAgICAgICAgICAgICAgb3B0cy5pbnNlcnRNb2RlVmlzdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy9kaXNhYmxlIGF1dG9jb3JyZWN0XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIiwgXCJvZmZcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vYmluZCBldmVudHNcbiAgICAgICAgICAgIEV2ZW50UnVsZXIub24oZWwsIFwic3VibWl0XCIsIEV2ZW50SGFuZGxlcnMuc3VibWl0RXZlbnQpO1xuICAgICAgICAgICAgRXZlbnRSdWxlci5vbihlbCwgXCJyZXNldFwiLCBFdmVudEhhbmRsZXJzLnJlc2V0RXZlbnQpO1xuICAgICAgICAgICAgRXZlbnRSdWxlci5vbihlbCwgXCJibHVyXCIsIEV2ZW50SGFuZGxlcnMuYmx1ckV2ZW50KTtcbiAgICAgICAgICAgIEV2ZW50UnVsZXIub24oZWwsIFwiZm9jdXNcIiwgRXZlbnRIYW5kbGVycy5mb2N1c0V2ZW50KTtcbiAgICAgICAgICAgIEV2ZW50UnVsZXIub24oZWwsIFwiaW52YWxpZFwiLCBFdmVudEhhbmRsZXJzLmludmFsaWRFdmVudCk7XG4gICAgICAgICAgICBFdmVudFJ1bGVyLm9uKGVsLCBcImNsaWNrXCIsIEV2ZW50SGFuZGxlcnMuY2xpY2tFdmVudCk7XG4gICAgICAgICAgICBFdmVudFJ1bGVyLm9uKGVsLCBcIm1vdXNlbGVhdmVcIiwgRXZlbnRIYW5kbGVycy5tb3VzZWxlYXZlRXZlbnQpO1xuICAgICAgICAgICAgRXZlbnRSdWxlci5vbihlbCwgXCJtb3VzZWVudGVyXCIsIEV2ZW50SGFuZGxlcnMubW91c2VlbnRlckV2ZW50KTtcbiAgICAgICAgICAgIEV2ZW50UnVsZXIub24oZWwsIFwicGFzdGVcIiwgRXZlbnRIYW5kbGVycy5wYXN0ZUV2ZW50KTtcbiAgICAgICAgICAgIEV2ZW50UnVsZXIub24oZWwsIFwiY3V0XCIsIEV2ZW50SGFuZGxlcnMuY3V0RXZlbnQpO1xuICAgICAgICAgICAgRXZlbnRSdWxlci5vbihlbCwgXCJjb21wbGV0ZVwiLCBvcHRzLm9uY29tcGxldGUpO1xuICAgICAgICAgICAgRXZlbnRSdWxlci5vbihlbCwgXCJpbmNvbXBsZXRlXCIsIG9wdHMub25pbmNvbXBsZXRlKTtcbiAgICAgICAgICAgIEV2ZW50UnVsZXIub24oZWwsIFwiY2xlYXJlZFwiLCBvcHRzLm9uY2xlYXJlZCk7XG4gICAgICAgICAgICBpZiAob3B0cy5pbnB1dEV2ZW50T25seSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIEV2ZW50UnVsZXIub24oZWwsIFwia2V5ZG93blwiLCBFdmVudEhhbmRsZXJzLmtleUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2JpbGUgfHwgb3B0cy5pbnB1dEV2ZW50T25seSkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcIm1heExlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEV2ZW50UnVsZXIub24oZWwsIFwiaW5wdXRcIiwgRXZlbnRIYW5kbGVycy5pbnB1dEZhbGxCYWNrRXZlbnQpO1xuICAgICAgICAgICAgLy8gRXZlbnRSdWxlci5vbihlbCwgXCJiZWZvcmVpbnB1dFwiLCBFdmVudEhhbmRsZXJzLmJlZm9yZUlucHV0RXZlbnQpOyAvL2h0dHBzOi8vZ2l0aHViLmNvbS93M2MvaW5wdXQtZXZlbnRzIC0gdG8gaW1wbGVtZW50XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRSdWxlci5vbihlbCwgXCJzZXR2YWx1ZVwiLCBFdmVudEhhbmRsZXJzLnNldFZhbHVlRXZlbnQpO1xuXG4gICAgICAgIC8vYXBwbHkgbWFza1xuICAgICAgICBnZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaykuam9pbihcIlwiKTsgLy9pbml0aWFsaXplIHRoZSBidWZmZXIgYW5kIGdldG1hc2tsZW5ndGhcbiAgICAgICAgaW5wdXRtYXNrLnVuZG9WYWx1ZSA9IGlucHV0bWFzay5fdmFsdWVHZXQodHJ1ZSk7XG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gKGVsLmlucHV0bWFzay5zaGFkb3dSb290IHx8IGVsLm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChlbC5pbnB1dG1hc2suX3ZhbHVlR2V0KHRydWUpICE9PSBcIlwiIHx8IG9wdHMuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgPT09IGZhbHNlIHx8IGFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgICAgICAgICBhcHBseUlucHV0VmFsdWUoZWwsIGVsLmlucHV0bWFzay5fdmFsdWVHZXQodHJ1ZSksIG9wdHMpO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzaykuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChpc0NvbXBsZXRlLmNhbGwoaW5wdXRtYXNrLCBidWZmZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmNsZWFySW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNldE1hc2tTZXQuY2FsbChpbnB1dG1hc2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmNsZWFyTWFza09uTG9zdEZvY3VzICYmIGFjdGl2ZUVsZW1lbnQgIT09IGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJPcHRpb25hbFRhaWwuY2FsbChpbnB1dG1hc2ssIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgPT09IGZhbHNlIHx8IChvcHRzLnNob3dNYXNrT25Gb2N1cyAmJiBhY3RpdmVFbGVtZW50ID09PSBlbCkgfHwgZWwuaW5wdXRtYXNrLl92YWx1ZUdldCh0cnVlKSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHdyaXRlQnVmZmVyKGVsLCBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7IC8vcG9zaXRpb24gdGhlIGNhcmV0IHdoZW4gaW4gZm9jdXNcbiAgICAgICAgICAgICAgICBjYXJldC5jYWxsKGlucHV0bWFzaywgZWwsIHNlZWtOZXh0LmNhbGwoaW5wdXRtYXNrLCBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChpc0dyb3VwLCBpc09wdGlvbmFsLCBpc1F1YW50aWZpZXIsIGlzQWx0ZXJuYXRvcikge1xuXHR0aGlzLm1hdGNoZXMgPSBbXTtcblx0dGhpcy5vcGVuR3JvdXAgPSBpc0dyb3VwIHx8IGZhbHNlO1xuXHR0aGlzLmFsdGVybmF0b3JHcm91cCA9IGZhbHNlO1xuXHR0aGlzLmlzR3JvdXAgPSBpc0dyb3VwIHx8IGZhbHNlO1xuXHR0aGlzLmlzT3B0aW9uYWwgPSBpc09wdGlvbmFsIHx8IGZhbHNlO1xuXHR0aGlzLmlzUXVhbnRpZmllciA9IGlzUXVhbnRpZmllciB8fCBmYWxzZTtcblx0dGhpcy5pc0FsdGVybmF0b3IgPSBpc0FsdGVybmF0b3IgfHwgZmFsc2U7XG5cdHRoaXMucXVhbnRpZmllciA9IHtcblx0XHRtaW46IDEsXG5cdFx0bWF4OiAxXG5cdH07XG59IiwiaW1wb3J0IHtcbiAgICBkZXRlcm1pbmVUZXN0VGVtcGxhdGUsXG4gICAgZ2V0TWFza1RlbXBsYXRlLFxuICAgIGdldFBsYWNlaG9sZGVyLFxuICAgIGdldFRlc3QsXG4gICAgZ2V0VGVzdHMsXG4gICAgZ2V0VGVzdFRlbXBsYXRlXG59IGZyb20gXCIuL3ZhbGlkYXRpb24tdGVzdHNcIjtcbmltcG9ydCB7Y2hlY2tBbHRlcm5hdGlvbk1hdGNofSBmcm9tIFwiLi92YWxpZGF0aW9uXCI7XG5cbmV4cG9ydCB7XG4gICAgY2FyZXQsXG4gICAgZGV0ZXJtaW5lTGFzdFJlcXVpcmVkUG9zaXRpb24sXG4gICAgZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbixcbiAgICBnZXRCdWZmZXIsXG4gICAgZ2V0QnVmZmVyVGVtcGxhdGUsXG4gICAgZ2V0TGFzdFZhbGlkUG9zaXRpb24sXG4gICAgaXNNYXNrLFxuICAgIHJlc2V0TWFza1NldCxcbiAgICBzZWVrTmV4dCxcbiAgICBzZWVrUHJldmlvdXMsXG4gICAgdHJhbnNsYXRlUG9zaXRpb25cbn07XG5cbi8vdG9iZSBwdXQgb24gcHJvdG90eXBlP1xuZnVuY3Rpb24gY2FyZXQoaW5wdXQsIGJlZ2luLCBlbmQsIG5vdHJhbnNsYXRlLCBpc0RlbGV0ZSkge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMsXG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHM7XG5cbiAgICB2YXIgcmFuZ2U7XG4gICAgaWYgKGJlZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmVnaW4pKSB7XG4gICAgICAgICAgICBlbmQgPSBpbnB1dG1hc2suaXNSVEwgPyBiZWdpblswXSA6IGJlZ2luWzFdO1xuICAgICAgICAgICAgYmVnaW4gPSBpbnB1dG1hc2suaXNSVEwgPyBiZWdpblsxXSA6IGJlZ2luWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdpbi5iZWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmQgPSBpbnB1dG1hc2suaXNSVEwgPyBiZWdpbi5iZWdpbiA6IGJlZ2luLmVuZDtcbiAgICAgICAgICAgIGJlZ2luID0gaW5wdXRtYXNrLmlzUlRMID8gYmVnaW4uZW5kIDogYmVnaW4uYmVnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYmVnaW4gPSBub3RyYW5zbGF0ZSA/IGJlZ2luIDogdHJhbnNsYXRlUG9zaXRpb24uY2FsbChpbnB1dG1hc2ssIGJlZ2luKTtcbiAgICAgICAgICAgIGVuZCA9IG5vdHJhbnNsYXRlID8gZW5kIDogdHJhbnNsYXRlUG9zaXRpb24uY2FsbChpbnB1dG1hc2ssIGVuZCk7XG4gICAgICAgICAgICBlbmQgPSAodHlwZW9mIGVuZCA9PSBcIm51bWJlclwiKSA/IGVuZCA6IGJlZ2luO1xuICAgICAgICAgICAgLy8gaWYgKCEkKGlucHV0KS5pcyhcIjp2aXNpYmxlXCIpKSB7XG4gICAgICAgICAgICAvLyBcdHJldHVybjtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgdmFyIHNjcm9sbENhbGMgPSBwYXJzZUludCgoKGlucHV0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5nZXRDb21wdXRlZFN0eWxlID8gKGlucHV0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5nZXRDb21wdXRlZFN0eWxlKGlucHV0LCBudWxsKSA6IGlucHV0LmN1cnJlbnRTdHlsZSkuZm9udFNpemUpICogZW5kO1xuICAgICAgICAgICAgaW5wdXQuc2Nyb2xsTGVmdCA9IHNjcm9sbENhbGMgPiBpbnB1dC5zY3JvbGxXaWR0aCA/IHNjcm9sbENhbGMgOiAwO1xuICAgICAgICAgICAgaW5wdXQuaW5wdXRtYXNrLmNhcmV0UG9zID0ge2JlZ2luOiBiZWdpbiwgZW5kOiBlbmR9OyAvL3RyYWNrIGNhcmV0IGludGVybmFsbHlcbiAgICAgICAgICAgIGlmIChvcHRzLmluc2VydE1vZGVWaXN1YWwgJiYgb3B0cy5pbnNlcnRNb2RlID09PSBmYWxzZSAmJiBiZWdpbiA9PT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbmQrKzsgLy9zZXQgdmlzdWFsaXphdGlvbiBmb3IgaW5zZXJ0L292ZXJ3cml0ZSBtb2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0ID09PSAoaW5wdXQuaW5wdXRtYXNrLnNoYWRvd1Jvb3QgfHwgaW5wdXQub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChcInNldFNlbGVjdGlvblJhbmdlXCIgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoYmVnaW4sIGVuZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmZpcnN0Q2hpbGQgPT09IHVuZGVmaW5lZCB8fCBpbnB1dC5maXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChpbnB1dC5maXJzdENoaWxkLCBiZWdpbiA8IGlucHV0LmlucHV0bWFzay5fdmFsdWVHZXQoKS5sZW5ndGggPyBiZWdpbiA6IGlucHV0LmlucHV0bWFzay5fdmFsdWVHZXQoKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoaW5wdXQuZmlyc3RDaGlsZCwgZW5kIDwgaW5wdXQuaW5wdXRtYXNrLl92YWx1ZUdldCgpLmxlbmd0aCA/IGVuZCA6IGlucHV0LmlucHV0bWFzay5fdmFsdWVHZXQoKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAvL2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5jcmVhdGVUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIGJlZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFwic2VsZWN0aW9uU3RhcnRcIiBpbiBpbnB1dCAmJiBcInNlbGVjdGlvbkVuZFwiIGluIGlucHV0KSB7XG4gICAgICAgICAgICBiZWdpbiA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgZW5kID0gaW5wdXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJhbmdlID0gd2luZG93LmdldFNlbGVjdGlvbigpLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICBpZiAocmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIucGFyZW50Tm9kZSA9PT0gaW5wdXQgfHwgcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgYmVnaW4gPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICBlbmQgPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSkge1xuICAgICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIGJlZ2luID0gMCAtIHJhbmdlLmR1cGxpY2F0ZSgpLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCAtaW5wdXQuaW5wdXRtYXNrLl92YWx1ZUdldCgpLmxlbmd0aCk7XG4gICAgICAgICAgICBlbmQgPSBiZWdpbiArIHJhbmdlLnRleHQubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgKG9wdHMuaW5zZXJ0TW9kZVZpc3VhbCAmJiBvcHRzLmluc2VydE1vZGUgPT09IGZhbHNlICYmIGJlZ2luID09PSAoZW5kIC0gMSkpIGVuZC0tOyAvL2NvcnJlY3QgY2FyZXQgZm9yIGluc2VydC9vdmVyd3JpdGUgbW9kZVxuXG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiYmVnaW5cIjogbm90cmFuc2xhdGUgPyBiZWdpbiA6IHRyYW5zbGF0ZVBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCBiZWdpbiksXG4gICAgICAgICAgICBcImVuZFwiOiBub3RyYW5zbGF0ZSA/IGVuZCA6IHRyYW5zbGF0ZVBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCBlbmQpXG4gICAgICAgIH07XG4gICAgICAgIC8qZXNsaW50LWVuYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgIH1cbn1cblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0UmVxdWlyZWRQb3NpdGlvbihyZXR1cm5EZWZpbml0aW9uKSB7XG4gICAgY29uc3QgaW5wdXRtYXNrID0gdGhpcywge21hc2tzZXQsIGRlcGVuZGVuY3lMaWI6ICR9ID0gaW5wdXRtYXNrO1xuXG4gICAgdmFyIGJ1ZmZlciA9IGdldE1hc2tUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaywgdHJ1ZSwgZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChpbnB1dG1hc2spLCB0cnVlLCB0cnVlKSxcbiAgICAgICAgYmwgPSBidWZmZXIubGVuZ3RoLFxuICAgICAgICBwb3MsIGx2cCA9IGdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrKSxcbiAgICAgICAgcG9zaXRpb25zID0ge30sXG4gICAgICAgIGx2VGVzdCA9IG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbbHZwXSxcbiAgICAgICAgbmR4SW50bHpyID0gbHZUZXN0ICE9PSB1bmRlZmluZWQgPyBsdlRlc3QubG9jYXRvci5zbGljZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICB0ZXN0UG9zO1xuICAgIGZvciAocG9zID0gbHZwICsgMTsgcG9zIDwgYnVmZmVyLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgdGVzdFBvcyA9IGdldFRlc3RUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaywgcG9zLCBuZHhJbnRsenIsIHBvcyAtIDEpO1xuICAgICAgICBuZHhJbnRsenIgPSB0ZXN0UG9zLmxvY2F0b3Iuc2xpY2UoKTtcbiAgICAgICAgcG9zaXRpb25zW3Bvc10gPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGVzdFBvcyk7XG4gICAgfVxuXG4gICAgdmFyIGx2VGVzdEFsdCA9IGx2VGVzdCAmJiBsdlRlc3QuYWx0ZXJuYXRpb24gIT09IHVuZGVmaW5lZCA/IGx2VGVzdC5sb2NhdG9yW2x2VGVzdC5hbHRlcm5hdGlvbl0gOiB1bmRlZmluZWQ7XG4gICAgZm9yIChwb3MgPSBibCAtIDE7IHBvcyA+IGx2cDsgcG9zLS0pIHtcbiAgICAgICAgdGVzdFBvcyA9IHBvc2l0aW9uc1twb3NdO1xuICAgICAgICBpZiAoKHRlc3RQb3MubWF0Y2gub3B0aW9uYWxpdHkgfHxcbiAgICAgICAgICAgICAgICAodGVzdFBvcy5tYXRjaC5vcHRpb25hbFF1YW50aWZpZXIgJiYgdGVzdFBvcy5tYXRjaC5uZXdCbG9ja01hcmtlcikgfHxcbiAgICAgICAgICAgICAgICAobHZUZXN0QWx0ICYmXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChsdlRlc3RBbHQgIT09IHBvc2l0aW9uc1twb3NdLmxvY2F0b3JbbHZUZXN0LmFsdGVybmF0aW9uXSAmJiB0ZXN0UG9zLm1hdGNoLnN0YXRpYyAhPSB0cnVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRlc3RQb3MubWF0Y2guc3RhdGljID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdFBvcy5sb2NhdG9yW2x2VGVzdC5hbHRlcm5hdGlvbl0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0FsdGVybmF0aW9uTWF0Y2guY2FsbChpbnB1dG1hc2ssIHRlc3RQb3MubG9jYXRvcltsdlRlc3QuYWx0ZXJuYXRpb25dLnRvU3RyaW5nKCkuc3BsaXQoXCIsXCIpLCBsdlRlc3RBbHQudG9TdHJpbmcoKS5zcGxpdChcIixcIikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGVzdHMuY2FsbChpbnB1dG1hc2ssIHBvcylbMF0uZGVmICE9PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSkgJiZcbiAgICAgICAgICAgIGJ1ZmZlcltwb3NdID09PSBnZXRQbGFjZWhvbGRlci5jYWxsKGlucHV0bWFzaywgcG9zLCB0ZXN0UG9zLm1hdGNoKSkge1xuICAgICAgICAgICAgYmwtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5EZWZpbml0aW9uID8ge1xuICAgICAgICBcImxcIjogYmwsXG4gICAgICAgIFwiZGVmXCI6IHBvc2l0aW9uc1tibF0gPyBwb3NpdGlvbnNbYmxdLm1hdGNoIDogdW5kZWZpbmVkXG4gICAgfSA6IGJsO1xufVxuXG4vL3RvYmUgcHV0IG9uIHByb3RvdHlwZT9cbmZ1bmN0aW9uIGRldGVybWluZU5ld0NhcmV0UG9zaXRpb24oc2VsZWN0ZWRDYXJldCwgdGFiYmVkLCBwb3NpdGlvbkNhcmV0T25DbGljaykge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMsIHttYXNrc2V0LCBvcHRzfSA9IGlucHV0bWFzaztcblxuICAgIGZ1bmN0aW9uIGRvUmFkaXhGb2N1cyhjbGlja1Bvcykge1xuICAgICAgICBpZiAob3B0cy5yYWRpeFBvaW50ICE9PSBcIlwiICYmIG9wdHMuZGlnaXRzICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgdnBzID0gbWFza3NldC52YWxpZFBvc2l0aW9ucztcbiAgICAgICAgICAgIGlmICh2cHNbY2xpY2tQb3NdID09PSB1bmRlZmluZWQgfHwgKHZwc1tjbGlja1Bvc10uaW5wdXQgPT09IGdldFBsYWNlaG9sZGVyLmNhbGwoaW5wdXRtYXNrLCBjbGlja1BvcykpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaWNrUG9zIDwgc2Vla05leHQuY2FsbChpbnB1dG1hc2ssIC0xKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl4UG9zID0gZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKS5pbmRleE9mKG9wdHMucmFkaXhQb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKHJhZGl4UG9zICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB2cCA9IDAsIHZwbCA9IHZwcy5sZW5ndGg7IHZwIDwgdnBsOyB2cCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodnBzW3ZwXSAmJiByYWRpeFBvcyA8IHZwICYmIHZwc1t2cF0uaW5wdXQgIT09IGdldFBsYWNlaG9sZGVyLmNhbGwoaW5wdXRtYXNrLCB2cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGFiYmVkKSB7XG4gICAgICAgIGlmIChpbnB1dG1hc2suaXNSVEwpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkQ2FyZXQuZW5kID0gc2VsZWN0ZWRDYXJldC5iZWdpbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGVkQ2FyZXQuYmVnaW4gPSBzZWxlY3RlZENhcmV0LmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0ZWRDYXJldC5iZWdpbiA9PT0gc2VsZWN0ZWRDYXJldC5lbmQpIHtcbiAgICAgICAgcG9zaXRpb25DYXJldE9uQ2xpY2sgPSBwb3NpdGlvbkNhcmV0T25DbGljayB8fCBvcHRzLnBvc2l0aW9uQ2FyZXRPbkNsaWNrO1xuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uQ2FyZXRPbkNsaWNrKSB7XG4gICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgICAgIHNlbGVjdGVkQ2FyZXQgPSB7YmVnaW46IDAsIGVuZDogZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKS5sZW5ndGh9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImlnbm9yZVwiOlxuICAgICAgICAgICAgICAgIHNlbGVjdGVkQ2FyZXQuZW5kID0gc2VsZWN0ZWRDYXJldC5iZWdpbiA9IHNlZWtOZXh0LmNhbGwoaW5wdXRtYXNrLCBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJhZGl4Rm9jdXNcIjpcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRtYXNrLmNsaWNrZWQgPiAxICYmIG1hc2tzZXQudmFsaWRQb3NpdGlvbnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChkb1JhZGl4Rm9jdXMoc2VsZWN0ZWRDYXJldC5iZWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhZGl4UG9zID0gZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKS5qb2luKFwiXCIpLmluZGV4T2Yob3B0cy5yYWRpeFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRDYXJldC5lbmQgPSBzZWxlY3RlZENhcmV0LmJlZ2luID0gb3B0cy5udW1lcmljSW5wdXQgPyBzZWVrTmV4dC5jYWxsKGlucHV0bWFzaywgcmFkaXhQb3MpIDogcmFkaXhQb3M7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gLy9mYWxsYmFjayB0byBsdnBcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDogLy9sdnA6XG4gICAgICAgICAgICAgICAgdmFyIGNsaWNrUG9zaXRpb24gPSBzZWxlY3RlZENhcmV0LmJlZ2luLFxuICAgICAgICAgICAgICAgICAgICBsdmNsaWNrUG9zaXRpb24gPSBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywgY2xpY2tQb3NpdGlvbiwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQb3NpdGlvbiA9IHNlZWtOZXh0LmNhbGwoaW5wdXRtYXNrLCAobHZjbGlja1Bvc2l0aW9uID09PSAtMSAmJiAhaXNNYXNrLmNhbGwoaW5wdXRtYXNrLCAwKSkgPyAtMSA6IGx2Y2xpY2tQb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xpY2tQb3NpdGlvbiA8PSBsYXN0UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRDYXJldC5lbmQgPSBzZWxlY3RlZENhcmV0LmJlZ2luID0gIWlzTWFzay5jYWxsKGlucHV0bWFzaywgY2xpY2tQb3NpdGlvbiwgZmFsc2UsIHRydWUpID8gc2Vla05leHQuY2FsbChpbnB1dG1hc2ssIGNsaWNrUG9zaXRpb24pIDogY2xpY2tQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbHZwID0gbWFza3NldC52YWxpZFBvc2l0aW9uc1tsdmNsaWNrUG9zaXRpb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHQgPSBnZXRUZXN0VGVtcGxhdGUuY2FsbChpbnB1dG1hc2ssIGxhc3RQb3NpdGlvbiwgbHZwID8gbHZwLm1hdGNoLmxvY2F0b3IgOiB1bmRlZmluZWQsIGx2cCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciA9IGdldFBsYWNlaG9sZGVyLmNhbGwoaW5wdXRtYXNrLCBsYXN0UG9zaXRpb24sIHR0Lm1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwbGFjZWhvbGRlciAhPT0gXCJcIiAmJiBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spW2xhc3RQb3NpdGlvbl0gIT09IHBsYWNlaG9sZGVyICYmIHR0Lm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAhPT0gdHJ1ZSAmJiB0dC5tYXRjaC5uZXdCbG9ja01hcmtlciAhPT0gdHJ1ZSkgfHwgKCFpc01hc2suY2FsbChpbnB1dG1hc2ssIGxhc3RQb3NpdGlvbiwgb3B0cy5rZWVwU3RhdGljLCB0cnVlKSAmJiB0dC5tYXRjaC5kZWYgPT09IHBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvcyA9IHNlZWtOZXh0LmNhbGwoaW5wdXRtYXNrLCBsYXN0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWNrUG9zaXRpb24gPj0gbmV3UG9zIHx8IGNsaWNrUG9zaXRpb24gPT09IGxhc3RQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQb3NpdGlvbiA9IG5ld1BvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZENhcmV0LmVuZCA9IHNlbGVjdGVkQ2FyZXQuYmVnaW4gPSBsYXN0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkQ2FyZXQ7XG4gICAgfVxufVxuXG5cbi8vdG9iZSBwdXQgb24gcHJvdG90eXBlP1xuZnVuY3Rpb24gZ2V0QnVmZmVyKG5vQ2FjaGUpIHtcbiAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLCB7bWFza3NldH0gPSBpbnB1dG1hc2s7XG5cbiAgICBpZiAobWFza3NldC5idWZmZXIgPT09IHVuZGVmaW5lZCB8fCBub0NhY2hlID09PSB0cnVlKSB7XG4gICAgICAgIG1hc2tzZXQuYnVmZmVyID0gZ2V0TWFza1RlbXBsYXRlLmNhbGwoaW5wdXRtYXNrLCB0cnVlLCBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzayksIHRydWUpO1xuICAgICAgICBpZiAobWFza3NldC5fYnVmZmVyID09PSB1bmRlZmluZWQpIG1hc2tzZXQuX2J1ZmZlciA9IG1hc2tzZXQuYnVmZmVyLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXNrc2V0LmJ1ZmZlcjtcbn1cblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBnZXRCdWZmZXJUZW1wbGF0ZSgpIHtcbiAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLCBtYXNrc2V0ID0gdGhpcy5tYXNrc2V0O1xuXG4gICAgaWYgKG1hc2tzZXQuX2J1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vZ2VuZXJhdGUgdGVtcGxhdGVcbiAgICAgICAgbWFza3NldC5fYnVmZmVyID0gZ2V0TWFza1RlbXBsYXRlLmNhbGwoaW5wdXRtYXNrLCBmYWxzZSwgMSk7XG4gICAgICAgIGlmIChtYXNrc2V0LmJ1ZmZlciA9PT0gdW5kZWZpbmVkKSBtYXNrc2V0LmJ1ZmZlciA9IG1hc2tzZXQuX2J1ZmZlci5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFza3NldC5fYnVmZmVyO1xufVxuXG4vL3RvYmUgcHV0IG9uIHByb3RvdHlwZT9cbmZ1bmN0aW9uIGdldExhc3RWYWxpZFBvc2l0aW9uKGNsb3Nlc3RUbywgc3RyaWN0LCB2YWxpZFBvc2l0aW9ucykge1xuICAgIGNvbnN0IG1hc2tzZXQgPSB0aGlzLm1hc2tzZXQ7XG5cbiAgICB2YXIgYmVmb3JlID0gLTEsXG4gICAgICAgIGFmdGVyID0gLTEsXG4gICAgICAgIHZhbGlkcyA9IHZhbGlkUG9zaXRpb25zIHx8IG1hc2tzZXQudmFsaWRQb3NpdGlvbnM7IC8vZm9yIHVzZSBpbiB2YWxob29rIH4gY29udGV4dCBzd2l0Y2hcbiAgICBpZiAoY2xvc2VzdFRvID09PSB1bmRlZmluZWQpIGNsb3Nlc3RUbyA9IC0xO1xuICAgIGZvciAodmFyIHBzTmR4ID0gMCwgdnBsID0gdmFsaWRzLmxlbmd0aDsgcHNOZHggPCB2cGw7IHBzTmR4KyspIHtcbiAgICAgICAgaWYgKHZhbGlkc1twc05keF0gJiYgKHN0cmljdCB8fCB2YWxpZHNbcHNOZHhdLmdlbmVyYXRlZElucHV0ICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgaWYgKHBzTmR4IDw9IGNsb3Nlc3RUbykgYmVmb3JlID0gcHNOZHg7XG4gICAgICAgICAgICBpZiAocHNOZHggPj0gY2xvc2VzdFRvKSBhZnRlciA9IHBzTmR4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoYmVmb3JlID09PSAtMSB8fCBiZWZvcmUgPT0gY2xvc2VzdFRvKSA/IGFmdGVyIDogYWZ0ZXIgPT0gLTEgPyBiZWZvcmUgOiAoY2xvc2VzdFRvIC0gYmVmb3JlKSA8IChhZnRlciAtIGNsb3Nlc3RUbykgPyBiZWZvcmUgOiBhZnRlcjtcbn1cblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBpc01hc2socG9zLCBzdHJpY3QsIGZ1enp5KSB7XG4gICAgY29uc3QgaW5wdXRtYXNrID0gdGhpcywgbWFza3NldCA9IHRoaXMubWFza3NldDtcblxuICAgIHZhciB0ZXN0ID0gZ2V0VGVzdFRlbXBsYXRlLmNhbGwoaW5wdXRtYXNrLCBwb3MpLm1hdGNoO1xuICAgIGlmICh0ZXN0LmRlZiA9PT0gXCJcIikgdGVzdCA9IGdldFRlc3QuY2FsbChpbnB1dG1hc2ssIHBvcykubWF0Y2g7XG5cbiAgICBpZiAodGVzdC5zdGF0aWMgIT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRlc3QuZm47XG4gICAgfVxuICAgIGlmIChmdXp6eSA9PT0gdHJ1ZSAmJiAobWFza3NldC52YWxpZFBvc2l0aW9uc1twb3NdICE9PSB1bmRlZmluZWQgJiYgbWFza3NldC52YWxpZFBvc2l0aW9uc1twb3NdLmdlbmVyYXRlZElucHV0ICE9PSB0cnVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0ICE9PSB0cnVlICYmIHBvcyA+IC0xKSB7XG4gICAgICAgIGlmIChmdXp6eSkgeyAvL2NoZWNrIG9uIHRoZSBudW1iZXIgb2YgdGVzdHNcbiAgICAgICAgICAgIHZhciB0ZXN0cyA9IGdldFRlc3RzLmNhbGwoaW5wdXRtYXNrLCBwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RzLmxlbmd0aCA+ICgxICsgKHRlc3RzW3Rlc3RzLmxlbmd0aCAtIDFdLm1hdGNoLmRlZiA9PT0gXCJcIiA/IDEgOiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9lbHNlIGJhc2VkIG9uIHRoZSB0ZW1wbGF0ZVxuICAgICAgICB2YXIgdGVzdFRlbXBsYXRlID0gZGV0ZXJtaW5lVGVzdFRlbXBsYXRlLmNhbGwoaW5wdXRtYXNrLCBwb3MsIGdldFRlc3RzLmNhbGwoaW5wdXRtYXNrLCBwb3MpKTtcbiAgICAgICAgdmFyIHRlc3RQbGFjZUhvbGRlciA9IGdldFBsYWNlaG9sZGVyLmNhbGwoaW5wdXRtYXNrLCBwb3MsIHRlc3RUZW1wbGF0ZS5tYXRjaCk7XG4gICAgICAgIHJldHVybiB0ZXN0VGVtcGxhdGUubWF0Y2guZGVmICE9PSB0ZXN0UGxhY2VIb2xkZXI7XG5cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL3RvYmUgcHV0IG9uIHByb3RvdHlwZT9cbmZ1bmN0aW9uIHJlc2V0TWFza1NldChzb2Z0KSB7XG4gICAgY29uc3QgbWFza3NldCA9IHRoaXMubWFza3NldDtcblxuICAgIG1hc2tzZXQuYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgIGlmIChzb2Z0ICE9PSB0cnVlKSB7XG4gICAgICAgIG1hc2tzZXQudmFsaWRQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbWFza3NldC5wID0gMDtcbiAgICB9XG59XG5cbi8vdG9iZSBwdXQgb24gcHJvdG90eXBlP1xuZnVuY3Rpb24gc2Vla05leHQocG9zLCBuZXdCbG9jaywgZnV6enkpIHtcbiAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzO1xuXG4gICAgaWYgKGZ1enp5ID09PSB1bmRlZmluZWQpIGZ1enp5ID0gdHJ1ZTtcbiAgICB2YXIgcG9zaXRpb24gPSBwb3MgKyAxO1xuICAgIHdoaWxlIChnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBwb3NpdGlvbikubWF0Y2guZGVmICE9PSBcIlwiICYmXG4gICAgKChuZXdCbG9jayA9PT0gdHJ1ZSAmJiAoZ2V0VGVzdC5jYWxsKGlucHV0bWFzaywgcG9zaXRpb24pLm1hdGNoLm5ld0Jsb2NrTWFya2VyICE9PSB0cnVlIHx8ICFpc01hc2suY2FsbChpbnB1dG1hc2ssIHBvc2l0aW9uLCB1bmRlZmluZWQsIHRydWUpKSkgfHxcbiAgICAgICAgKG5ld0Jsb2NrICE9PSB0cnVlICYmICFpc01hc2suY2FsbChpbnB1dG1hc2ssIHBvc2l0aW9uLCB1bmRlZmluZWQsIGZ1enp5KSkpKSB7XG4gICAgICAgIHBvc2l0aW9uKys7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbn1cblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBzZWVrUHJldmlvdXMocG9zLCBuZXdCbG9jaykge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXM7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBwb3MgLSAxO1xuICAgIGlmIChwb3MgPD0gMCkgcmV0dXJuIDA7XG5cbiAgICB3aGlsZSAocG9zaXRpb24gPiAwICYmXG4gICAgKChuZXdCbG9jayA9PT0gdHJ1ZSAmJiAoZ2V0VGVzdC5jYWxsKGlucHV0bWFzaywgcG9zaXRpb24pLm1hdGNoLm5ld0Jsb2NrTWFya2VyICE9PSB0cnVlIHx8ICFpc01hc2suY2FsbChpbnB1dG1hc2ssIHBvc2l0aW9uLCB1bmRlZmluZWQsIHRydWUpKSkgfHxcbiAgICAgICAgKG5ld0Jsb2NrICE9PSB0cnVlICYmICFpc01hc2suY2FsbChpbnB1dG1hc2ssIHBvc2l0aW9uLCB1bmRlZmluZWQsIHRydWUpKSkpIHtcbiAgICAgICAgcG9zaXRpb24tLTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG4vL3RvYmUgcHV0IG9uIHByb3RvdHlwZT9cbmZ1bmN0aW9uIHRyYW5zbGF0ZVBvc2l0aW9uKHBvcykge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMsXG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHMsXG4gICAgICAgIGVsID0gdGhpcy5lbDtcblxuICAgIGlmIChpbnB1dG1hc2suaXNSVEwgJiYgdHlwZW9mIHBvcyA9PT0gXCJudW1iZXJcIiAmJiAoIW9wdHMuZ3JlZWR5IHx8IG9wdHMucGxhY2Vob2xkZXIgIT09IFwiXCIpICYmIGVsKSB7XG4gICAgICAgIHBvcyA9IGlucHV0bWFzay5fdmFsdWVHZXQoKS5sZW5ndGggLSBwb3M7XG4gICAgICAgIGlmIChwb3MgPCAwKSBwb3MgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuIiwiZXhwb3J0IHtcbiAgICBkZXRlcm1pbmVUZXN0VGVtcGxhdGUsXG4gICAgZ2V0RGVjaXNpb25UYWtlcixcbiAgICBnZXRNYXNrVGVtcGxhdGUsXG4gICAgZ2V0UGxhY2Vob2xkZXIsXG4gICAgZ2V0VGVzdCxcbiAgICBnZXRUZXN0cyxcbiAgICBnZXRUZXN0VGVtcGxhdGUsXG4gICAgaXNTdWJzZXRPZlxufTtcbmltcG9ydCBJbnB1dG1hc2sgZnJvbSBcIi4vaW5wdXRtYXNrXCI7XG5cbmZ1bmN0aW9uIGdldExvY2F0b3IodHN0LCBhbGlnbikgeyAvL25lZWQgdG8gYWxpZ24gdGhlIGxvY2F0b3JzIHRvIGJlIGNvcnJlY3RcbiAgICB2YXIgbG9jYXRvciA9ICh0c3QuYWx0ZXJuYXRpb24gIT0gdW5kZWZpbmVkID8gdHN0Lm1sb2NbZ2V0RGVjaXNpb25UYWtlcih0c3QpXSA6IHRzdC5sb2NhdG9yKS5qb2luKFwiXCIpO1xuICAgIGlmIChsb2NhdG9yICE9PSBcIlwiKSB3aGlsZSAobG9jYXRvci5sZW5ndGggPCBhbGlnbikgbG9jYXRvciArPSBcIjBcIjtcbiAgICByZXR1cm4gbG9jYXRvcjtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjaXNpb25UYWtlcih0c3QpIHtcbiAgICB2YXIgZGVjaXNpb25UYWtlciA9IHRzdC5sb2NhdG9yW3RzdC5hbHRlcm5hdGlvbl07XG4gICAgaWYgKHR5cGVvZiBkZWNpc2lvblRha2VyID09IFwic3RyaW5nXCIgJiYgZGVjaXNpb25UYWtlci5sZW5ndGggPiAwKSB7IC8vbm8gZGVjaXNpb24gdGFrZW4gfiB0YWtlIGZpcnN0IG9uZSBhcyBkZWNpZGVyXG4gICAgICAgIGRlY2lzaW9uVGFrZXIgPSBkZWNpc2lvblRha2VyLnNwbGl0KFwiLFwiKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2lzaW9uVGFrZXIgIT09IHVuZGVmaW5lZCA/IGRlY2lzaW9uVGFrZXIudG9TdHJpbmcoKSA6IFwiXCI7XG59XG5cbi8vdG9iZSBwdXQgb24gcHJvdG90eXBlP1xuZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIocG9zLCB0ZXN0LCByZXR1cm5QTCkge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMsXG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHMsXG4gICAgICAgIG1hc2tzZXQgPSB0aGlzLm1hc2tzZXQ7XG5cbiAgICB0ZXN0ID0gdGVzdCB8fCBnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBwb3MpLm1hdGNoO1xuICAgIGlmICh0ZXN0LnBsYWNlaG9sZGVyICE9PSB1bmRlZmluZWQgfHwgcmV0dXJuUEwgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0ZXN0LnBsYWNlaG9sZGVyID09PSBcImZ1bmN0aW9uXCIgPyB0ZXN0LnBsYWNlaG9sZGVyKG9wdHMpIDogdGVzdC5wbGFjZWhvbGRlcjtcbiAgICB9IGVsc2UgaWYgKHRlc3Quc3RhdGljID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChwb3MgPiAtMSAmJiBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3Bvc10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHRlc3RzID0gZ2V0VGVzdHMuY2FsbChpbnB1dG1hc2ssIHBvcyksXG4gICAgICAgICAgICAgICAgc3RhdGljQWx0ZXJuYXRpb25zID0gW10sXG4gICAgICAgICAgICAgICAgcHJldlRlc3Q7XG4gICAgICAgICAgICBpZiAodGVzdHMubGVuZ3RoID4gMSArICh0ZXN0c1t0ZXN0cy5sZW5ndGggLSAxXS5tYXRjaC5kZWYgPT09IFwiXCIgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0c1tpXS5tYXRjaC5kZWYgIT09IFwiXCIgJiYgdGVzdHNbaV0ubWF0Y2gub3B0aW9uYWxpdHkgIT09IHRydWUgJiYgdGVzdHNbaV0ubWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyICE9PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGVzdHNbaV0ubWF0Y2guc3RhdGljID09PSB0cnVlIHx8IChwcmV2VGVzdCA9PT0gdW5kZWZpbmVkIHx8IHRlc3RzW2ldLm1hdGNoLmZuLnRlc3QocHJldlRlc3QubWF0Y2guZGVmLCBtYXNrc2V0LCBwb3MsIHRydWUsIG9wdHMpICE9PSBmYWxzZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNBbHRlcm5hdGlvbnMucHVzaCh0ZXN0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVzdHNbaV0ubWF0Y2guc3RhdGljID09PSB0cnVlKSBwcmV2VGVzdCA9IHRlc3RzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRpY0FsdGVybmF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9bMC05YS1iQS1aXS8udGVzdChzdGF0aWNBbHRlcm5hdGlvbnNbMF0ubWF0Y2guZGVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0cy5wbGFjZWhvbGRlci5jaGFyQXQocG9zICUgb3B0cy5wbGFjZWhvbGRlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVzdC5kZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdHMucGxhY2Vob2xkZXIuY2hhckF0KHBvcyAlIG9wdHMucGxhY2Vob2xkZXIubGVuZ3RoKTtcbn1cblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBnZXRNYXNrVGVtcGxhdGUoYmFzZU9uSW5wdXQsIG1pbmltYWxQb3MsIGluY2x1ZGVNb2RlLCBub0ppdCwgY2xlYXJPcHRpb25hbFRhaWwpIHtcbiAgICAvL2luY2x1ZGVNb2RlIHRydWUgPT4gaW5wdXQsIHVuZGVmaW5lZCA9PiBwbGFjZWhvbGRlciwgZmFsc2UgPT4gbWFza1xuXG4gICAgdmFyIGlucHV0bWFzayA9IHRoaXMsXG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHMsXG4gICAgICAgIG1hc2tzZXQgPSB0aGlzLm1hc2tzZXQ7XG5cblxuICAgIHZhciBncmVlZHkgPSBvcHRzLmdyZWVkeTtcbiAgICBpZiAoY2xlYXJPcHRpb25hbFRhaWwgJiYgb3B0cy5ncmVlZHkpIHtcbiAgICAgICAgb3B0cy5ncmVlZHkgPSBmYWxzZTtcbiAgICAgICAgaW5wdXRtYXNrLm1hc2tzZXQudGVzdHMgPSB7fTtcbiAgICB9XG4gICAgbWluaW1hbFBvcyA9IG1pbmltYWxQb3MgfHwgMDtcbiAgICB2YXIgbWFza1RlbXBsYXRlID0gW10sXG4gICAgICAgIG5keEludGx6ciwgcG9zID0gMCxcbiAgICAgICAgdGVzdCwgdGVzdFBvcywgaml0UmVuZGVyU3RhdGljO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKGJhc2VPbklucHV0ID09PSB0cnVlICYmIG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbcG9zXSkge1xuICAgICAgICAgICAgdGVzdFBvcyA9IChjbGVhck9wdGlvbmFsVGFpbCAmJiBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3Bvc10ubWF0Y2gub3B0aW9uYWxpdHlcbiAgICAgICAgICAgICAgICAmJiBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3BvcyArIDFdID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAmJiAobWFza3NldC52YWxpZFBvc2l0aW9uc1twb3NdLmdlbmVyYXRlZElucHV0ID09PSB0cnVlIHx8IChtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3Bvc10uaW5wdXQgPT0gb3B0cy5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyICYmIHBvcyA+IDApKSlcbiAgICAgICAgICAgICAgICA/IGRldGVybWluZVRlc3RUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaywgcG9zLCBnZXRUZXN0cy5jYWxsKGlucHV0bWFzaywgcG9zLCBuZHhJbnRsenIsIHBvcyAtIDEpKVxuICAgICAgICAgICAgICAgIDogbWFza3NldC52YWxpZFBvc2l0aW9uc1twb3NdO1xuICAgICAgICAgICAgdGVzdCA9IHRlc3RQb3MubWF0Y2g7XG4gICAgICAgICAgICBuZHhJbnRsenIgPSB0ZXN0UG9zLmxvY2F0b3Iuc2xpY2UoKTtcbiAgICAgICAgICAgIG1hc2tUZW1wbGF0ZS5wdXNoKGluY2x1ZGVNb2RlID09PSB0cnVlID8gdGVzdFBvcy5pbnB1dCA6IGluY2x1ZGVNb2RlID09PSBmYWxzZSA/IHRlc3QubmF0aXZlRGVmIDogZ2V0UGxhY2Vob2xkZXIuY2FsbChpbnB1dG1hc2ssIHBvcywgdGVzdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVzdFBvcyA9IGdldFRlc3RUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaywgcG9zLCBuZHhJbnRsenIsIHBvcyAtIDEpO1xuICAgICAgICAgICAgdGVzdCA9IHRlc3RQb3MubWF0Y2g7XG4gICAgICAgICAgICBuZHhJbnRsenIgPSB0ZXN0UG9zLmxvY2F0b3Iuc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBqaXRNYXNraW5nID0gbm9KaXQgPT09IHRydWUgPyBmYWxzZSA6IChvcHRzLmppdE1hc2tpbmcgIT09IGZhbHNlID8gb3B0cy5qaXRNYXNraW5nIDogdGVzdC5qaXQpO1xuICAgICAgICAgICAgLy9jaGVjayBmb3IgZ3JvdXBTZXBhcmF0b3IgaXMgYSBoYWNrIGZvciB0aGUgbnVtZXJpY3MgYXMgd2UgZG9uJ3Qgd2FudCB0aGUgcmVuZGVyIG9mIHRoZSBncm91cFNlcGFyYXRvciBiZWZvcmVoYW5kXG4gICAgICAgICAgICBqaXRSZW5kZXJTdGF0aWMgPSAoKGppdFJlbmRlclN0YXRpYyAmJiB0ZXN0LnN0YXRpYyAmJiB0ZXN0LmRlZiAhPT0gb3B0cy5ncm91cFNlcGFyYXRvciAmJiB0ZXN0LmZuID09PSBudWxsKSB8fCAobWFza3NldC52YWxpZFBvc2l0aW9uc1twb3MgLSAxXSAmJiB0ZXN0LnN0YXRpYyAmJiB0ZXN0LmRlZiAhPT0gb3B0cy5ncm91cFNlcGFyYXRvciAmJiB0ZXN0LmZuID09PSBudWxsKSkgJiYgbWFza3NldC50ZXN0c1twb3NdIC8qJiYgbWFza3NldC50ZXN0c1twb3NdLmxlbmd0aCA9PT0gMSovO1xuICAgICAgICAgICAgaWYgKGppdFJlbmRlclN0YXRpYyB8fCBqaXRNYXNraW5nID09PSBmYWxzZSB8fCBqaXRNYXNraW5nID09PSB1bmRlZmluZWQgLyp8fCBwb3MgPCBsdnAqLyB8fCAodHlwZW9mIGppdE1hc2tpbmcgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUoaml0TWFza2luZykgJiYgaml0TWFza2luZyA+IHBvcykpIHtcbiAgICAgICAgICAgICAgICBtYXNrVGVtcGxhdGUucHVzaChpbmNsdWRlTW9kZSA9PT0gZmFsc2UgPyB0ZXN0Lm5hdGl2ZURlZiA6IGdldFBsYWNlaG9sZGVyLmNhbGwoaW5wdXRtYXNrLCBtYXNrVGVtcGxhdGUubGVuZ3RoLCB0ZXN0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGppdFJlbmRlclN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9zKys7XG4gICAgfSB3aGlsZSAoKHRlc3Quc3RhdGljICE9PSB0cnVlIHx8IHRlc3QuZGVmICE9PSBcIlwiKSB8fCBtaW5pbWFsUG9zID4gcG9zKTtcbiAgICBpZiAobWFza1RlbXBsYXRlW21hc2tUZW1wbGF0ZS5sZW5ndGggLSAxXSA9PT0gXCJcIikge1xuICAgICAgICBtYXNrVGVtcGxhdGUucG9wKCk7IC8vZHJvcCB0aGUgbGFzdCBvbmUgd2hpY2ggaXMgZW1wdHlcbiAgICB9XG4gICAgaWYgKGluY2x1ZGVNb2RlICE9PSBmYWxzZSB8fCAvL2RvIG5vdCBhbHRlciB0aGUgbWFza2xlbmd0aCB3aGVuIGp1c3QgcmV0cmlldmluZyB0aGUgbWFza2RlZmluaXRpb25cbiAgICAgICAgbWFza3NldC5tYXNrTGVuZ3RoID09PSB1bmRlZmluZWQpIC8vanVzdCBtYWtlIHN1cmUgdGhlIG1hc2tMZW5ndGggZ2V0cyBpbml0aWFsaXplZCBpbiBhbGwgY2FzZXMgKG5lZWRlZCBmb3IgaXNWYWxpZClcbiAgICB7XG4gICAgICAgIG1hc2tzZXQubWFza0xlbmd0aCA9IHBvcyAtIDE7XG4gICAgfVxuXG4gICAgb3B0cy5ncmVlZHkgPSBncmVlZHk7XG4gICAgcmV0dXJuIG1hc2tUZW1wbGF0ZTtcbn1cblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBnZXRUZXN0VGVtcGxhdGUocG9zLCBuZHhJbnRsenIsIHRzdFBzKSB7XG4gICAgdmFyIGlucHV0bWFzayA9IHRoaXMsXG4gICAgICAgIG1hc2tzZXQgPSB0aGlzLm1hc2tzZXQ7XG5cbiAgICByZXR1cm4gbWFza3NldC52YWxpZFBvc2l0aW9uc1twb3NdIHx8IGRldGVybWluZVRlc3RUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaywgcG9zLCBnZXRUZXN0cy5jYWxsKGlucHV0bWFzaywgcG9zLCBuZHhJbnRsenIgPyBuZHhJbnRsenIuc2xpY2UoKSA6IG5keEludGx6ciwgdHN0UHMpKTtcbn1cblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBkZXRlcm1pbmVUZXN0VGVtcGxhdGUocG9zLCB0ZXN0cykge1xuICAgIHZhciBpbnB1dG1hc2sgPSB0aGlzLFxuICAgICAgICBvcHRzID0gdGhpcy5vcHRzLFxuICAgICAgICBsZW5naHRPZmZzZXQgPSAwO1xuICAgIHZhciBvcHRpb25hbGl0eUxldmVsID0gZGV0ZXJtaW5lT3B0aW9uYWxpdHlMZXZlbChwb3MsIHRlc3RzKTtcbiAgICBwb3MgPSBwb3MgPiAwID8gcG9zIC0gMSA6IDA7XG4gICAgdmFyIGFsdFRlc3QgPSBnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBwb3MpLCB0YXJnZXRMb2NhdG9yID0gZ2V0TG9jYXRvcihhbHRUZXN0KSwgdHN0TG9jYXRvciwgY2xvc2VzdCwgYmVzdE1hdGNoO1xuICAgIGlmIChvcHRzLmdyZWVkeSAmJiB0ZXN0cy5sZW5ndGggPiAxICYmIHRlc3RzW3Rlc3RzLmxlbmd0aCAtIDFdLm1hdGNoLmRlZiA9PT0gXCJcIilcbiAgICAgICAgbGVuZ2h0T2Zmc2V0ID0gMTtcbiAgICAvLyBjb25zb2xlLmxvZyhcIiBvcHRpb25hbGl0eSA9IFwiICsgb3B0aW9uYWxpdHlMZXZlbCk7XG4gICAgLy8gY29uc29sZS5sb2coXCIgLSBcIiArIEpTT04uc3RyaW5naWZ5KHRlc3RzKSk7XG4gICAgZm9yICh2YXIgbmR4ID0gMDsgbmR4IDwgdGVzdHMubGVuZ3RoIC0gbGVuZ2h0T2Zmc2V0OyBuZHgrKykgeyAvL2ZpbmQgYmVzdCBtYXRjaGluZ1xuICAgICAgICB2YXIgdHN0ID0gdGVzdHNbbmR4XTtcbiAgICAgICAgdHN0TG9jYXRvciA9IGdldExvY2F0b3IodHN0LCB0YXJnZXRMb2NhdG9yLmxlbmd0aCk7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKHRzdExvY2F0b3IgLSB0YXJnZXRMb2NhdG9yKTtcblxuICAgICAgICBpZiAoY2xvc2VzdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICB8fCAodHN0TG9jYXRvciAhPT0gXCJcIiAmJiBkaXN0YW5jZSA8IGNsb3Nlc3QpXG4gICAgICAgICAgICB8fCAoYmVzdE1hdGNoICYmICFvcHRzLmdyZWVkeSAmJlxuICAgICAgICAgICAgICAgIChiZXN0TWF0Y2gubWF0Y2gub3B0aW9uYWxpdHkgJiYgYmVzdE1hdGNoLm1hdGNoLm9wdGlvbmFsaXR5IC0gb3B0aW9uYWxpdHlMZXZlbCA+IDApICYmXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLm1hdGNoLm5ld0Jsb2NrTWFya2VyID09PSBcIm1hc3RlclwiICYmXG4gICAgICAgICAgICAgICAgKCghdHN0Lm1hdGNoLm9wdGlvbmFsaXR5IHx8IHRzdC5tYXRjaC5vcHRpb25hbGl0eSAtIG9wdGlvbmFsaXR5TGV2ZWwgPCAxKSB8fCAhdHN0Lm1hdGNoLm5ld0Jsb2NrTWFya2VyKSlcbiAgICAgICAgICAgIHx8IChiZXN0TWF0Y2ggJiYgIW9wdHMuZ3JlZWR5ICYmIGJlc3RNYXRjaC5tYXRjaC5vcHRpb25hbFF1YW50aWZpZXIgJiYgIXRzdC5tYXRjaC5vcHRpb25hbFF1YW50aWZpZXIpKSB7XG4gICAgICAgICAgICBjbG9zZXN0ID0gZGlzdGFuY2U7XG4gICAgICAgICAgICBiZXN0TWF0Y2ggPSB0c3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJlc3RNYXRjaDtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lT3B0aW9uYWxpdHlMZXZlbChwb3MsIHRlc3RzKSB7XG4gICAgbGV0IG9wdGlvbmFsaXR5TGV2ZWwgPSAwLCBkaWZmZXJlbnRPcHRpb25hbExldmVscyA9IGZhbHNlO1xuICAgIHRlc3RzLmZvckVhY2godGVzdCA9PiB7XG4gICAgICAgIGlmICh0ZXN0Lm1hdGNoLm9wdGlvbmFsaXR5KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uYWxpdHlMZXZlbCAhPT0gMCAmJiBvcHRpb25hbGl0eUxldmVsICE9PSB0ZXN0Lm1hdGNoLm9wdGlvbmFsaXR5KVxuICAgICAgICAgICAgICAgIGRpZmZlcmVudE9wdGlvbmFsTGV2ZWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25hbGl0eUxldmVsID09PSAwIHx8IG9wdGlvbmFsaXR5TGV2ZWwgPiB0ZXN0Lm1hdGNoLm9wdGlvbmFsaXR5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxpdHlMZXZlbCA9IHRlc3QubWF0Y2gub3B0aW9uYWxpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAob3B0aW9uYWxpdHlMZXZlbCkge1xuICAgICAgICBpZiAocG9zID09IDApIG9wdGlvbmFsaXR5TGV2ZWwgPSAwO1xuICAgICAgICBlbHNlIGlmICh0ZXN0cy5sZW5ndGggPT0gMSkgb3B0aW9uYWxpdHlMZXZlbCA9IDA7XG4gICAgICAgIGVsc2UgaWYgKCFkaWZmZXJlbnRPcHRpb25hbExldmVscykgb3B0aW9uYWxpdHlMZXZlbCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25hbGl0eUxldmVsO1xufVxuXG4vL3RvYmUgcHV0IG9uIHByb3RvdHlwZT9cbmZ1bmN0aW9uIGdldFRlc3QocG9zLCB0ZXN0cykge1xuICAgIHZhciBpbnB1dG1hc2sgPSB0aGlzLFxuICAgICAgICBtYXNrc2V0ID0gdGhpcy5tYXNrc2V0O1xuXG4gICAgaWYgKG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbcG9zXSkge1xuICAgICAgICByZXR1cm4gbWFza3NldC52YWxpZFBvc2l0aW9uc1twb3NdO1xuICAgIH1cbiAgICByZXR1cm4gKHRlc3RzIHx8IGdldFRlc3RzLmNhbGwoaW5wdXRtYXNrLCBwb3MpKVswXTtcbn1cblxuZnVuY3Rpb24gaXNTdWJzZXRPZihzb3VyY2UsIHRhcmdldCwgb3B0cykge1xuICAgIGZ1bmN0aW9uIGV4cGFuZChwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBleHBhbmRlZCA9IFtdLCBzdGFydCA9IC0xLCBlbmQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0dGVybi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLmNoYXJBdChpKSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBwYXR0ZXJuLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK3N0YXJ0IDwgZW5kKSBleHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBwYXR0ZXJuLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgZXhwYW5kZWQucHVzaChwYXR0ZXJuLmNoYXJBdChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkLmpvaW4oXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5tYXRjaC5kZWYgPT09IHRhcmdldC5tYXRjaC5uYXRpdmVEZWYpIHJldHVybiB0cnVlO1xuICAgIGlmICgob3B0cy5yZWdleCB8fCAoc291cmNlLm1hdGNoLmZuIGluc3RhbmNlb2YgUmVnRXhwICYmIHRhcmdldC5tYXRjaC5mbiBpbnN0YW5jZW9mIFJlZ0V4cCkpICYmIHNvdXJjZS5tYXRjaC5zdGF0aWMgIT09IHRydWUgJiYgdGFyZ2V0Lm1hdGNoLnN0YXRpYyAhPT0gdHJ1ZSkgeyAvL2lzIHJlZ2V4IGEgc3Vic2V0XG4gICAgICAgIHJldHVybiBleHBhbmQodGFyZ2V0Lm1hdGNoLmZuLnRvU3RyaW5nKCkucmVwbGFjZSgvW1tcXF0vXS9nLCBcIlwiKSkuaW5kZXhPZihleHBhbmQoc291cmNlLm1hdGNoLmZuLnRvU3RyaW5nKCkucmVwbGFjZSgvW1tcXF0vXS9nLCBcIlwiKSkpICE9PSAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL3RvYmUgcHV0IG9uIHByb3RvdHlwZT9cbmZ1bmN0aW9uIGdldFRlc3RzKHBvcywgbmR4SW50bHpyLCB0c3RQcykge1xuICAgIHZhciBpbnB1dG1hc2sgPSB0aGlzLFxuICAgICAgICAkID0gdGhpcy5kZXBlbmRlbmN5TGliLFxuICAgICAgICBtYXNrc2V0ID0gdGhpcy5tYXNrc2V0LFxuICAgICAgICBvcHRzID0gdGhpcy5vcHRzLFxuICAgICAgICBlbCA9IHRoaXMuZWwsXG4gICAgICAgIG1hc2tUb2tlbnMgPSBtYXNrc2V0Lm1hc2tUb2tlbixcbiAgICAgICAgdGVzdFBvcyA9IG5keEludGx6ciA/IHRzdFBzIDogMCxcbiAgICAgICAgbmR4SW5pdGlhbGl6ZXIgPSBuZHhJbnRsenIgPyBuZHhJbnRsenIuc2xpY2UoKSA6IFswXSxcbiAgICAgICAgbWF0Y2hlcyA9IFtdLFxuICAgICAgICBpbnNlcnRTdG9wID0gZmFsc2UsXG4gICAgICAgIGxhdGVzdE1hdGNoLFxuICAgICAgICBjYWNoZURlcGVuZGVuY3kgPSBuZHhJbnRsenIgPyBuZHhJbnRsenIuam9pbihcIlwiKSA6IFwiXCI7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlVGVzdEZyb21Ub2tlbihtYXNrVG9rZW4sIG5keEluaXRpYWxpemVyLCBsb29wTmR4LCBxdWFudGlmaWVyUmVjdXJzZSkgeyAvL25keEluaXRpYWxpemVyIGNvbnRhaW5zIGEgc2V0IG9mIGluZGV4ZXMgdG8gc3BlZWR1cCBzZWFyY2hlcyBpbiB0aGUgbXRva2Vuc1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNYXRjaChtYXRjaCwgbG9vcE5keCwgcXVhbnRpZmllclJlY3Vyc2UpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRmlyc3RNYXRjaChsYXRlc3RNYXRjaCwgdG9rZW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdE1hdGNoID0gdG9rZW5Hcm91cC5tYXRjaGVzLmluZGV4T2YobGF0ZXN0TWF0Y2gpID09PSAwO1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkdyb3VwLm1hdGNoZXMuZXZlcnkoZnVuY3Rpb24gKG1hdGNoLCBuZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5pc1F1YW50aWZpZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE1hdGNoID0gaXNGaXJzdE1hdGNoKGxhdGVzdE1hdGNoLCB0b2tlbkdyb3VwLm1hdGNoZXNbbmR4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWF0Y2gsIFwibWF0Y2hlc1wiKSkgZmlyc3RNYXRjaCA9IGlzRmlyc3RNYXRjaChsYXRlc3RNYXRjaCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0TWF0Y2gpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RNYXRjaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZU5keEluaXRpYWxpemVyKHBvcywgYWx0ZXJuYXRlTmR4LCB0YXJnZXRBbHRlcm5hdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBiZXN0TWF0Y2gsIGluZGV4UG9zO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tzZXQudGVzdHNbcG9zXSB8fCBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3Bvc10pIHtcbiAgICAgICAgICAgICAgICAgICAgKG1hc2tzZXQudGVzdHNbcG9zXSB8fCBbbWFza3NldC52YWxpZFBvc2l0aW9uc1twb3NdXSkuZXZlcnkoZnVuY3Rpb24gKGxtbnQsIG5keCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxtbnQubWxvY1thbHRlcm5hdGVOZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gbG1udDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHRlcm5hdGlvbiA9IHRhcmdldEFsdGVybmF0aW9uICE9PSB1bmRlZmluZWQgPyB0YXJnZXRBbHRlcm5hdGlvbiA6IGxtbnQuYWx0ZXJuYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmR4UG9zID0gbG1udC5sb2NhdG9yW2FsdGVybmF0aW9uXSAhPT0gdW5kZWZpbmVkID8gbG1udC5sb2NhdG9yW2FsdGVybmF0aW9uXS50b1N0cmluZygpLmluZGV4T2YoYWx0ZXJuYXRlTmR4KSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpbmRleFBvcyA9PT0gdW5kZWZpbmVkIHx8IG5keFBvcyA8IGluZGV4UG9zKSAmJiBuZHhQb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gbG1udDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFBvcyA9IG5keFBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZXN0TWF0Y2hBbHRJbmRleCA9IGJlc3RNYXRjaC5sb2NhdG9yW2Jlc3RNYXRjaC5hbHRlcm5hdGlvbl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdG9yID0gYmVzdE1hdGNoLm1sb2NbYWx0ZXJuYXRlTmR4XSB8fCBiZXN0TWF0Y2gubWxvY1tiZXN0TWF0Y2hBbHRJbmRleF0gfHwgYmVzdE1hdGNoLmxvY2F0b3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhdG9yLnNsaWNlKCh0YXJnZXRBbHRlcm5hdGlvbiAhPT0gdW5kZWZpbmVkID8gdGFyZ2V0QWx0ZXJuYXRpb24gOiBiZXN0TWF0Y2guYWx0ZXJuYXRpb24pICsgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldEFsdGVybmF0aW9uICE9PSB1bmRlZmluZWQgPyByZXNvbHZlTmR4SW5pdGlhbGl6ZXIocG9zLCBhbHRlcm5hdGVOZHgpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RhdGljQ2FuTWF0Y2hEZWZpbml0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5tYXRjaC5zdGF0aWMgPT09IHRydWUgJiYgdGFyZ2V0Lm1hdGNoLnN0YXRpYyAhPT0gdHJ1ZSA/IHRhcmdldC5tYXRjaC5mbi50ZXN0KHNvdXJjZS5tYXRjaC5kZWYsIG1hc2tzZXQsIHBvcywgZmFsc2UsIG9wdHMsIGZhbHNlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL21lcmdlbG9jYXRvcnMgZm9yIHJldHJpZXZpbmcgdGhlIGNvcnJlY3QgbG9jYXRvciBtYXRjaCB3aGVuIG1lcmdpbmdcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldE1lcmdlTG9jYXRvcnModGFyZ2V0TWF0Y2gsIGFsdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsdGVybmF0aW9uTmR4ID0gdGFyZ2V0TWF0Y2guYWx0ZXJuYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZE1lcmdlID0gYWx0TWF0Y2ggPT09IHVuZGVmaW5lZCB8fCAoYWx0ZXJuYXRpb25OZHggPT09IGFsdE1hdGNoLmFsdGVybmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaC5sb2NhdG9yW2FsdGVybmF0aW9uTmR4XS50b1N0cmluZygpLmluZGV4T2YoYWx0TWF0Y2gubG9jYXRvclthbHRlcm5hdGlvbk5keF0pID09PSAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRNZXJnZSAmJiBhbHRlcm5hdGlvbk5keCA+IGFsdE1hdGNoLmFsdGVybmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhbHRNYXRjaC5hbHRlcm5hdGlvbjsgaSA8IGFsdGVybmF0aW9uTmR4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRNYXRjaC5sb2NhdG9yW2ldICE9PSBhbHRNYXRjaC5sb2NhdG9yW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpb25OZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE1lcmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRNZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaC5tbG9jID0gdGFyZ2V0TWF0Y2gubWxvYyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY05keCA9IHRhcmdldE1hdGNoLmxvY2F0b3JbYWx0ZXJuYXRpb25OZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jTmR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoLmFsdGVybmF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NOZHggPT09IFwic3RyaW5nXCIpIGxvY05keCA9IGxvY05keC5zcGxpdChcIixcIilbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0TWF0Y2gubWxvY1tsb2NOZHhdID09PSB1bmRlZmluZWQpIHRhcmdldE1hdGNoLm1sb2NbbG9jTmR4XSA9IHRhcmdldE1hdGNoLmxvY2F0b3Iuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHRNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmR4IGluIGFsdE1hdGNoLm1sb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZHggPT09IFwic3RyaW5nXCIpIG5keCA9IG5keC5zcGxpdChcIixcIilbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRNYXRjaC5tbG9jW25keF0gPT09IHVuZGVmaW5lZCkgdGFyZ2V0TWF0Y2gubWxvY1tuZHhdID0gYWx0TWF0Y2gubWxvY1tuZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaC5sb2NhdG9yW2FsdGVybmF0aW9uTmR4XSA9IE9iamVjdC5rZXlzKHRhcmdldE1hdGNoLm1sb2MpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc1NhbWVMZXZlbCh0YXJnZXRNYXRjaCwgYWx0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0TWF0Y2gubG9jYXRvci5sZW5ndGggIT09IGFsdE1hdGNoLmxvY2F0b3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbG9jTmR4ID0gdGFyZ2V0TWF0Y2guYWx0ZXJuYXRpb24gKyAxOyBsb2NOZHggPCB0YXJnZXRNYXRjaC5sb2NhdG9yLmxlbmd0aDsgbG9jTmR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldE1hdGNoLmxvY2F0b3JbbG9jTmR4XSAhPT0gYWx0TWF0Y2gubG9jYXRvcltsb2NOZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUdyb3VwKCkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gaGFuZGxlTWF0Y2gobWFza1Rva2VuLm1hdGNoZXNbbWFza1Rva2VuLm1hdGNoZXMuaW5kZXhPZihtYXRjaCkgKyAxXSwgbG9vcE5keCwgcXVhbnRpZmllclJlY3Vyc2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZU9wdGlvbmFsKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25hbFRva2VuID0gbWF0Y2gsIG10Y2hzTmR4ID0gbWF0Y2hlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSByZXNvbHZlVGVzdEZyb21Ub2tlbihtYXRjaCwgbmR4SW5pdGlhbGl6ZXIsIGxvb3BOZHgsIHF1YW50aWZpZXJSZWN1cnNlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7IC8vY2hlY2sgb24gbWF0Y2hlcy5sZW5ndGggaW5zdGVhZCBvZiBtYXRjaCB0byBoYW5kbGUgcXVhbnRpZmllciBpbiBhIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vbWFyayBvcHRpb25hbGl0eSBpbiBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobXRjaCwgbmR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmR4ID49IG10Y2hzTmR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXRjaC5tYXRjaC5vcHRpb25hbGl0eSA9IG10Y2gubWF0Y2gub3B0aW9uYWxpdHkgPyBtdGNoLm1hdGNoLm9wdGlvbmFsaXR5ICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsYXRlc3RNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5tYXRjaDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocXVhbnRpZmllclJlY3Vyc2UgPT09IHVuZGVmaW5lZCAmJiBpc0ZpcnN0TWF0Y2gobGF0ZXN0TWF0Y2gsIG9wdGlvbmFsVG9rZW4pKSB7IC8vcHJldmVudCBsb29wIHNlZSAjNjk4XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRTdG9wID0gdHJ1ZTsgLy9pbnNlcnQgYSBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXN0UG9zID0gcG9zOyAvL21hdGNoIHRoZSBwb3NpdGlvbiBhZnRlciB0aGUgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDsgLy9tYWtlIHRoZSBsb29wIGNvbnRpbnVlIHdoZW4gaXQgaXMgZGVsaWJlcmF0ZWx5IGJ5IGEgcXVhbnRpZmllclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVBbHRlcm5hdG9yKCkge1xuICAgICAgICAgICAgICAgIGlucHV0bWFzay5oYXNBbHRlcm5hdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlVG9rZW4gPSBtYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgbWFsdGVybmF0ZU1hdGNoZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgbWFsdE1hdGNoZXMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICBsb29wTmR4Q250ID0gbG9vcE5keC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHVuTWF0Y2hlZEFsdGVybmF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGFsdEluZGV4ID0gbmR4SW5pdGlhbGl6ZXIubGVuZ3RoID4gMCA/IG5keEluaXRpYWxpemVyLnNoaWZ0KCkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoYWx0SW5kZXggPT09IC0xIHx8IHR5cGVvZiBhbHRJbmRleCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBvcyA9IHRlc3RQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZHhJbml0aWFsaXplckNsb25lID0gbmR4SW5pdGlhbGl6ZXIuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdEluZGV4QXJyID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbW5keDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhbHRJbmRleCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRJbmRleEFyciA9IGFsdEluZGV4LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYW1uZHggPSAwOyBhbW5keCA8IGFsdGVybmF0ZVRva2VuLm1hdGNoZXMubGVuZ3RoOyBhbW5keCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0SW5kZXhBcnIucHVzaChhbW5keC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXNrc2V0LmV4Y2x1ZGVzW3Bvc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsdEluZGV4QXJyQ2xvbmUgPSBhbHRJbmRleEFyci5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGV4bCA9IG1hc2tzZXQuZXhjbHVkZXNbcG9zXS5sZW5ndGg7IGkgPCBleGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGNsdWRlU2V0ID0gbWFza3NldC5leGNsdWRlc1twb3NdW2ldLnRvU3RyaW5nKCkuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb29wTmR4Lmxlbmd0aCA9PSBleGNsdWRlU2V0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdEluZGV4QXJyLnNwbGljZShhbHRJbmRleEFyci5pbmRleE9mKGV4Y2x1ZGVTZXRbMF0pLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWx0SW5kZXhBcnIubGVuZ3RoID09PSAwKSB7IC8vZnVsbHkgYWx0ZXJuYXRlZCA9PiByZXNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXNrc2V0LmV4Y2x1ZGVzW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0SW5kZXhBcnIgPSBhbHRJbmRleEFyckNsb25lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmtlZXBTdGF0aWMgPT09IHRydWUgfHwgKGlzRmluaXRlKHBhcnNlSW50KG9wdHMua2VlcFN0YXRpYykpICYmIGN1cnJlbnRQb3MgPj0gb3B0cy5rZWVwU3RhdGljKSkgYWx0SW5kZXhBcnIgPSBhbHRJbmRleEFyci5zbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmR4ID0gMDsgbmR4IDwgYWx0SW5kZXhBcnIubGVuZ3RoOyBuZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1uZHggPSBwYXJzZUludChhbHRJbmRleEFycltuZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IHRoZSBjb3JyZWN0IG5keEluaXRpYWxpemVyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZHhJbml0aWFsaXplciA9IHR5cGVvZiBhbHRJbmRleCA9PT0gXCJzdHJpbmdcIiA/IHJlc29sdmVOZHhJbml0aWFsaXplcih0ZXN0UG9zLCBhbW5keCwgbG9vcE5keENudCkgfHwgbmR4SW5pdGlhbGl6ZXJDbG9uZS5zbGljZSgpIDogbmR4SW5pdGlhbGl6ZXJDbG9uZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuTWF0Y2ggPSBhbHRlcm5hdGVUb2tlbi5tYXRjaGVzW2FtbmR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbk1hdGNoICYmIGhhbmRsZU1hdGNoKHRva2VuTWF0Y2gsIFthbW5keF0uY29uY2F0KGxvb3BOZHgpLCBxdWFudGlmaWVyUmVjdXJzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5NYXRjaGVkQWx0ZXJuYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5NYXRjaCAmJiB0b2tlbk1hdGNoLm1hdGNoZXMgJiYgdG9rZW5NYXRjaC5tYXRjaGVzLmxlbmd0aCA+IGFsdGVybmF0ZVRva2VuLm1hdGNoZXNbMF0ubWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWx0TWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RQb3MgPSBjdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Z1enp5IG1lcmdlIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5keDEgPSAwOyBuZHgxIDwgbWFsdE1hdGNoZXMubGVuZ3RoOyBuZHgxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWx0TWF0Y2ggPSBtYWx0TWF0Y2hlc1tuZHgxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0TWF0Y2gubWF0Y2guaml0ID0gYWx0TWF0Y2gubWF0Y2guaml0IHx8IHVuTWF0Y2hlZEFsdGVybmF0aW9uOyAvL21hcmsgaml0IHdoZW4gdGhlcmUgYXJlIHVubWF0Y2hlZCBhbHRlcm5hdGlvbnMgIGV4OiBtYXNrOiBcIihhfGFhKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0TWF0Y2guYWx0ZXJuYXRpb24gPSBhbHRNYXRjaC5hbHRlcm5hdGlvbiB8fCBsb29wTmR4Q250O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1lcmdlTG9jYXRvcnMoYWx0TWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5keDIgPSAwOyBuZHgyIDwgbWFsdGVybmF0ZU1hdGNoZXMubGVuZ3RoOyBuZHgyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsdE1hdGNoMiA9IG1hbHRlcm5hdGVNYXRjaGVzW25keDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFsdEluZGV4ICE9PSBcInN0cmluZ1wiIHx8IChhbHRNYXRjaC5hbHRlcm5hdGlvbiAhPT0gdW5kZWZpbmVkICYmIGFsdEluZGV4QXJyLmluY2x1ZGVzKGFsdE1hdGNoLmxvY2F0b3JbYWx0TWF0Y2guYWx0ZXJuYXRpb25dLnRvU3RyaW5nKCkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsdE1hdGNoLm1hdGNoLm5hdGl2ZURlZiA9PT0gYWx0TWF0Y2gyLm1hdGNoLm5hdGl2ZURlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWVyZ2VMb2NhdG9ycyhhbHRNYXRjaDIsIGFsdE1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdWJzZXRPZihhbHRNYXRjaCwgYWx0TWF0Y2gyLCBvcHRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXRNZXJnZUxvY2F0b3JzKGFsdE1hdGNoLCBhbHRNYXRjaDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbHRlcm5hdGVNYXRjaGVzLnNwbGljZShtYWx0ZXJuYXRlTWF0Y2hlcy5pbmRleE9mKGFsdE1hdGNoMiksIDAsIGFsdE1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3Vic2V0T2YoYWx0TWF0Y2gyLCBhbHRNYXRjaCwgb3B0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNZXJnZUxvY2F0b3JzKGFsdE1hdGNoMiwgYWx0TWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0aWNDYW5NYXRjaERlZmluaXRpb24oYWx0TWF0Y2gsIGFsdE1hdGNoMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZUxldmVsKGFsdE1hdGNoLCBhbHRNYXRjaDIpICYmIGVsLmlucHV0bWFzay51c2VyT3B0aW9ucy5rZWVwU3RhdGljID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5rZWVwU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNldE1lcmdlTG9jYXRvcnMoYWx0TWF0Y2gsIGFsdE1hdGNoMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pbnNlcnQgbWF0Y2ggYWJvdmUgZ2VuZXJhbCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWx0ZXJuYXRlTWF0Y2hlcy5zcGxpY2UobWFsdGVybmF0ZU1hdGNoZXMuaW5kZXhPZihhbHRNYXRjaDIpLCAwLCBhbHRNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJvcE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbHRlcm5hdGVNYXRjaGVzLnB1c2goYWx0TWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBjdXJyZW50TWF0Y2hlcy5jb25jYXQobWFsdGVybmF0ZU1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0UG9zID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRTdG9wID0gbWF0Y2hlcy5sZW5ndGggPiAwOyAvL2luc2VydCBhIHN0b3BlbGVtbnQgd2hlbiB0aGVyZSBpcyBhbiBhbHRlcm5hdGUgLSBuZWVkZWQgZm9yIG5vbi1ncmVlZHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWFsdGVybmF0ZU1hdGNoZXMubGVuZ3RoID4gMDsgLy9zZXQgY29ycmVjdCBtYXRjaCBzdGF0ZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vY2xvbmViYWNrXG4gICAgICAgICAgICAgICAgICAgIG5keEluaXRpYWxpemVyID0gbmR4SW5pdGlhbGl6ZXJDbG9uZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gaGFuZGxlTWF0Y2goYWx0ZXJuYXRlVG9rZW4ubWF0Y2hlc1thbHRJbmRleF0gfHwgbWFza1Rva2VuLm1hdGNoZXNbYWx0SW5kZXhdLCBbYWx0SW5kZXhdLmNvbmNhdChsb29wTmR4KSwgcXVhbnRpZmllclJlY3Vyc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVRdWFudGlmaWVyKCkge1xuICAgICAgICAgICAgICAgIHZhciBxdCA9IG1hdGNoLCBicmVha2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBxbmR4ID0gKG5keEluaXRpYWxpemVyLmxlbmd0aCA+IDApID8gbmR4SW5pdGlhbGl6ZXIuc2hpZnQoKSA6IDA7IChxbmR4IDwgKGlzTmFOKHF0LnF1YW50aWZpZXIubWF4KSA/IHFuZHggKyAxIDogcXQucXVhbnRpZmllci5tYXgpKSAmJiB0ZXN0UG9zIDw9IHBvczsgcW5keCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbkdyb3VwID0gbWFza1Rva2VuLm1hdGNoZXNbbWFza1Rva2VuLm1hdGNoZXMuaW5kZXhPZihxdCkgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBoYW5kbGVNYXRjaCh0b2tlbkdyb3VwLCBbcW5keF0uY29uY2F0KGxvb3BOZHgpLCB0b2tlbkdyb3VwKTsgLy9zZXQgdGhlIHRva2VuR3JvdXAgYXMgcXVhbnRpZmllclJlY3Vyc2UgbWFya2VyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtdGNoLCBuZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoSXNNYXRjaE9mKHRva2VuR3JvdXAsIG10Y2gubWF0Y2gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3RNYXRjaCA9IG10Y2gubWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBsYXRlc3RNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5tYXRjaDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFyayBvcHRpb25hbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBGSVggUkVDVVJTSVZFIFFVQU5USUZJRVJTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0TWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyID0gcW5keCA+PSBxdC5xdWFudGlmaWVyLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhwb3MgKyBcIiBcIiArIHF0LnF1YW50aWZpZXIubWluICsgXCIgXCIgKyBsYXRlc3RNYXRjaC5vcHRpb25hbFF1YW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcW5keCArIDEgYXMgdGhlIGluZGV4IHN0YXJ0cyBmcm9tIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3RNYXRjaC5qaXQgPSAocW5keCArIDEpICogKHRva2VuR3JvdXAubWF0Y2hlcy5pbmRleE9mKGxhdGVzdE1hdGNoKSArIDEpID4gcXQucXVhbnRpZmllci5qaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhdGVzdE1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAmJiBpc0ZpcnN0TWF0Y2gobGF0ZXN0TWF0Y2gsIHRva2VuR3JvdXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0UG9zID0gcG9zOyAvL21hdGNoIHRoZSBwb3NpdGlvbiBhZnRlciB0aGUgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuZ3JlZWR5ICYmIG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbcG9zIC0gMV0gPT0gdW5kZWZpbmVkICYmIHFuZHggPiBxdC5xdWFudGlmaWVyLm1pbiAmJiBbXCIqXCIsIFwiK1wiXS5pbmRleE9mKHF0LnF1YW50aWZpZXIubWF4KSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlRGVwZW5kZW5jeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha2xvb3AgPSB0cnVlOyAvL3N0b3AgcXVhbnRpZmllcmxvb3AgJiYgc2VhcmNoIGZvciBuZXh0IHBvc3NpYmxlIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7IC8vbWFyayBtYXRjaCB0byBmYWxzZSB0byBtYWtlIHN1cmUgdGhlIGxvb3AgaW4gb3B0aW9uYWxzIGNvbnRpbnVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJyZWFrbG9vcCAmJiBsYXRlc3RNYXRjaC5qaXQgLyomJiAhbGF0ZXN0TWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hbHdheXMgc2V0IGppdE9mZnNldCwgaXN2YWxpZCBjaGVja3Mgd2hlbiB0byBhcHBseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrc2V0LmppdE9mZnNldFtwb3NdID0gdG9rZW5Hcm91cC5tYXRjaGVzLmxlbmd0aCAtIHRva2VuR3JvdXAubWF0Y2hlcy5pbmRleE9mKGxhdGVzdE1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicmVha2xvb3ApIGJyZWFrOyAvLyBzZWFyY2ggZm9yIG5leHQgcG9zc2libGUgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGVzdFBvcyA+IChwb3MgKyBvcHRzLl9tYXhUZXN0UG9zKSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW5wdXRtYXNrOiBUaGVyZSBpcyBwcm9iYWJseSBhbiBlcnJvciBpbiB5b3VyIG1hc2sgZGVmaW5pdGlvbiBvciBpbiB0aGUgY29kZS4gQ3JlYXRlIGFuIGlzc3VlIG9uIGdpdGh1YiB3aXRoIGFuIGV4YW1wbGUgb2YgdGhlIG1hc2sgeW91IGFyZSB1c2luZy4gXCIgKyBtYXNrc2V0Lm1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVzdFBvcyA9PT0gcG9zICYmIG1hdGNoLm1hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIFwibWF0Y2hcIjogbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIFwibG9jYXRvclwiOiBsb29wTmR4LnJldmVyc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgXCJjZFwiOiBjYWNoZURlcGVuZGVuY3ksXG4gICAgICAgICAgICAgICAgICAgIFwibWxvY1wiOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaC5vcHRpb25hbGl0eSAmJiBxdWFudGlmaWVyUmVjdXJzZSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICgob3B0cy5kZWZpbml0aW9ucyAmJiBvcHRzLmRlZmluaXRpb25zW21hdGNoLm5hdGl2ZURlZl0gJiYgb3B0cy5kZWZpbml0aW9uc1ttYXRjaC5uYXRpdmVEZWZdLm9wdGlvbmFsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKElucHV0bWFzay5wcm90b3R5cGUuZGVmaW5pdGlvbnNbbWF0Y2gubmF0aXZlRGVmXSAmJiBJbnB1dG1hc2sucHJvdG90eXBlLmRlZmluaXRpb25zW21hdGNoLm5hdGl2ZURlZl0ub3B0aW9uYWwpKSkgeyAvL3ByZXZlbnQgbG9vcCBzZWUgIzY5OFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRTdG9wID0gdHJ1ZTsgLy9pbnNlcnQgYSBzdG9wXG4gICAgICAgICAgICAgICAgICAgIHRlc3RQb3MgPSBwb3M7IC8vbWF0Y2ggdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBncm91cFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2gubWF0Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoLmlzR3JvdXAgJiYgcXVhbnRpZmllclJlY3Vyc2UgIT09IG1hdGNoKSB7IC8vd2hlbiBhIGdyb3VwIHBhc3MgYWxvbmcgdG8gdGhlIHF1YW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUdyb3VwKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVPcHRpb25hbCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2guaXNBbHRlcm5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVBbHRlcm5hdG9yKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaC5pc1F1YW50aWZpZXIgJiYgcXVhbnRpZmllclJlY3Vyc2UgIT09IG1hc2tUb2tlbi5tYXRjaGVzW21hc2tUb2tlbi5tYXRjaGVzLmluZGV4T2YobWF0Y2gpIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVF1YW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJlc29sdmVUZXN0RnJvbVRva2VuKG1hdGNoLCBuZHhJbml0aWFsaXplciwgbG9vcE5keCwgcXVhbnRpZmllclJlY3Vyc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVzdFBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy90aGUgb2Zmc2V0IGlzIHNldCBpbiB0aGUgcXVhbnRpZmllcmxvb3Agd2hlbiBnaXQgbWFza2luZyBpcyB1c2VkXG4gICAgICAgIGZvciAodmFyIHRuZHggPSAobmR4SW5pdGlhbGl6ZXIubGVuZ3RoID4gMCA/IG5keEluaXRpYWxpemVyLnNoaWZ0KCkgOiAwKTsgdG5keCA8IG1hc2tUb2tlbi5tYXRjaGVzLmxlbmd0aDsgdG5keCsrKSB7XG4gICAgICAgICAgICBpZiAobWFza1Rva2VuLm1hdGNoZXNbdG5keF0uaXNRdWFudGlmaWVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gaGFuZGxlTWF0Y2gobWFza1Rva2VuLm1hdGNoZXNbdG5keF0sIFt0bmR4XS5jb25jYXQobG9vcE5keCksIHF1YW50aWZpZXJSZWN1cnNlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgdGVzdFBvcyA9PT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRlc3RQb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSXNNYXRjaE9mKHRva2VuR3JvdXAsIG1hdGNoKSB7XG4gICAgICAgIGxldCBpc01hdGNoID0gdG9rZW5Hcm91cC5tYXRjaGVzLmluZGV4T2YobWF0Y2gpICE9IC0xO1xuICAgICAgICBpZiAoIWlzTWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuR3JvdXAubWF0Y2hlcy5mb3JFYWNoKChtdGNoLCBuZHgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobXRjaC5tYXRjaGVzICE9PSB1bmRlZmluZWQgJiYgIWlzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNNYXRjaCA9IElzTWF0Y2hPZihtdGNoLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTWF0Y2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VMb2NhdG9ycyhwb3MsIHRlc3RzKSB7XG4gICAgICAgIGxldCBsb2NhdG9yID0gW10sIGFsdGVybmF0aW9uO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGVzdHMpKSB0ZXN0cyA9IFt0ZXN0c107XG5cbiAgICAgICAgaWYgKHRlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0ZXN0c1swXS5hbHRlcm5hdGlvbiA9PT0gdW5kZWZpbmVkIHx8IG9wdHMua2VlcFN0YXRpYyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxvY2F0b3IgPSBkZXRlcm1pbmVUZXN0VGVtcGxhdGUuY2FsbChpbnB1dG1hc2ssIHBvcywgdGVzdHMuc2xpY2UoKSkubG9jYXRvci5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhdG9yLmxlbmd0aCA9PT0gMCkgbG9jYXRvciA9IHRlc3RzWzBdLmxvY2F0b3Iuc2xpY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodHN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0c3QuZGVmICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbiA9IHRzdC5hbHRlcm5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdG9yID0gdHN0LmxvY2F0b3Iuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRzdC5sb2NhdG9yW2FsdGVybmF0aW9uXSAmJiBsb2NhdG9yW2FsdGVybmF0aW9uXS50b1N0cmluZygpLmluZGV4T2YodHN0LmxvY2F0b3JbYWx0ZXJuYXRpb25dKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRvclthbHRlcm5hdGlvbl0gKz0gXCIsXCIgKyB0c3QubG9jYXRvclthbHRlcm5hdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2F0b3I7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAgIGlmIChuZHhJbnRsenIgPT09IHVuZGVmaW5lZCkgeyAvL2RldGVybWluZSBpbmRleCBpbml0aWFsaXplclxuICAgICAgICAgICAgdmFyIHByZXZpb3VzUG9zID0gcG9zIC0gMSxcbiAgICAgICAgICAgICAgICB0ZXN0O1xuICAgICAgICAgICAgd2hpbGUgKCh0ZXN0ID0gbWFza3NldC52YWxpZFBvc2l0aW9uc1twcmV2aW91c1Bvc10gfHwgbWFza3NldC50ZXN0c1twcmV2aW91c1Bvc10pID09PSB1bmRlZmluZWQgJiYgcHJldmlvdXNQb3MgPiAtMSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVzdCAhPT0gdW5kZWZpbmVkICYmIHByZXZpb3VzUG9zID4gLTEpIHtcbiAgICAgICAgICAgICAgICBuZHhJbml0aWFsaXplciA9IG1lcmdlTG9jYXRvcnMocHJldmlvdXNQb3MsIHRlc3QpO1xuICAgICAgICAgICAgICAgIGNhY2hlRGVwZW5kZW5jeSA9IG5keEluaXRpYWxpemVyLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgdGVzdFBvcyA9IHByZXZpb3VzUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXNrc2V0LnRlc3RzW3Bvc10gJiYgbWFza3NldC50ZXN0c1twb3NdWzBdLmNkID09PSBjYWNoZURlcGVuZGVuY3kpIHsgLy9jYWNoZURlcGVuZGVuY3kgaXMgc2V0IG9uIGFsbCB0ZXN0cywganVzdCBjaGVjayBvbiB0aGUgZmlyc3RcbiAgICAgICAgICAgIHJldHVybiBtYXNrc2V0LnRlc3RzW3Bvc107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbXRuZHggPSBuZHhJbml0aWFsaXplci5zaGlmdCgpOyBtdG5keCA8IG1hc2tUb2tlbnMubGVuZ3RoOyBtdG5keCsrKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSByZXNvbHZlVGVzdEZyb21Ub2tlbihtYXNrVG9rZW5zW210bmR4XSwgbmR4SW5pdGlhbGl6ZXIsIFttdG5keF0pO1xuICAgICAgICAgICAgaWYgKChtYXRjaCAmJiB0ZXN0UG9zID09PSBwb3MpIHx8IHRlc3RQb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDAgfHwgaW5zZXJ0U3RvcCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgbWF0Y2g6IHtcbiAgICAgICAgICAgICAgICBmbjogbnVsbCxcbiAgICAgICAgICAgICAgICBzdGF0aWM6IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxpdHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNhc2luZzogbnVsbCxcbiAgICAgICAgICAgICAgICBkZWY6IFwiXCIsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2NhdG9yOiBbXSxcbiAgICAgICAgICAgIG1sb2M6IHt9LFxuICAgICAgICAgICAgY2Q6IGNhY2hlRGVwZW5kZW5jeVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAobmR4SW50bHpyICE9PSB1bmRlZmluZWQgJiYgbWFza3NldC50ZXN0c1twb3NdKSB7IC8vcHJpb3JpdGl6ZSBmdWxsIHRlc3RzIGZvciBjYWNoaW5nXG4gICAgICAgIHJlc3VsdCA9ICQuZXh0ZW5kKHRydWUsIFtdLCBtYXRjaGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYXNrc2V0LnRlc3RzW3Bvc10gPSAkLmV4dGVuZCh0cnVlLCBbXSwgbWF0Y2hlcyk7IC8vc2V0IGEgY2xvbmUgdG8gcHJldmVudCBvdmVyd3JpdGluZyBzb21lIHByb3BzXG4gICAgICAgIHJlc3VsdCA9IG1hc2tzZXQudGVzdHNbcG9zXTtcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyhwb3MgKyBcIiAtIFwiICsgSlNPTi5zdHJpbmdpZnkobWF0Y2hlcykpO1xuICAgIC8vY2xlYW51cCBvcHRpb25hbGl0eSBtYXJraW5nXG4gICAgbWF0Y2hlcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICB0Lm1hdGNoLm9wdGlvbmFsaXR5ID0gdC5tYXRjaC5kZWZPcHRpb25hbGl0eSB8fCBmYWxzZTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQge1xuICAgIGRldGVybWluZVRlc3RUZW1wbGF0ZSxcbiAgICBnZXREZWNpc2lvblRha2VyLFxuICAgIGdldFBsYWNlaG9sZGVyLFxuICAgIGdldFRlc3QsXG4gICAgZ2V0VGVzdHMsXG4gICAgZ2V0VGVzdFRlbXBsYXRlXG59IGZyb20gXCIuL3ZhbGlkYXRpb24tdGVzdHNcIjtcbmltcG9ydCB7a2V5Q29kZSwga2V5c30gZnJvbSBcIi4va2V5Y29kZS5qc1wiO1xuaW1wb3J0IHtcbiAgICBkZXRlcm1pbmVMYXN0UmVxdWlyZWRQb3NpdGlvbiwgZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbixcbiAgICBnZXRCdWZmZXIsXG4gICAgZ2V0TGFzdFZhbGlkUG9zaXRpb24sXG4gICAgaXNNYXNrLFxuICAgIHJlc2V0TWFza1NldCxcbiAgICBzZWVrTmV4dCxcbiAgICBzZWVrUHJldmlvdXNcbn0gZnJvbSBcIi4vcG9zaXRpb25pbmdcIjtcbmltcG9ydCB7RXZlbnRIYW5kbGVyc30gZnJvbSBcIi4vZXZlbnRoYW5kbGVyc1wiO1xuXG5leHBvcnQge1xuICAgIGFsdGVybmF0ZSxcbiAgICBjaGVja0FsdGVybmF0aW9uTWF0Y2gsXG4gICAgaXNDb21wbGV0ZSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBpc1ZhbGlkLFxuICAgIHJlZnJlc2hGcm9tQnVmZmVyLFxuICAgIHJldmFsaWRhdGVNYXNrLFxuICAgIGhhbmRsZVJlbW92ZVxufTtcblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBhbHRlcm5hdGUobWFza1BvcywgYywgc3RyaWN0LCBmcm9tSXNWYWxpZCwgckFsdFBvcywgc2VsZWN0aW9uKSB7IC8vcG9zID09IHRydWUgPT4gZ2VuZXJhbGl6ZVxuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMsXG4gICAgICAgICQgPSB0aGlzLmRlcGVuZGVuY3lMaWIsXG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHMsXG4gICAgICAgIG1hc2tzZXQgPSBpbnB1dG1hc2subWFza3NldDtcblxuICAgIHZhciB2YWxpZFBzQ2xvbmUgPSAkLmV4dGVuZCh0cnVlLCBbXSwgbWFza3NldC52YWxpZFBvc2l0aW9ucyksXG4gICAgICAgIHRzdENsb25lID0gJC5leHRlbmQodHJ1ZSwge30sIG1hc2tzZXQudGVzdHMpLFxuICAgICAgICBsYXN0QWx0LFxuICAgICAgICBhbHRlcm5hdGlvbixcbiAgICAgICAgaXNWYWxpZFJzbHQgPSBmYWxzZSwgcmV0dXJuUnNsdCA9IGZhbHNlLFxuICAgICAgICBhbHRQb3MsIHByZXZBbHRQb3MsIGksIHZhbGlkUG9zLFxuICAgICAgICBkZWNpc2lvblBvcyxcbiAgICAgICAgbEFsdFBvcyA9IHJBbHRQb3MgIT09IHVuZGVmaW5lZCA/IHJBbHRQb3MgOiBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzayksIG5leHRQb3MsIGlucHV0LCBiZWdpbiwgZW5kO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBiZWdpbiA9IHNlbGVjdGlvbi5iZWdpbjtcbiAgICAgICAgZW5kID0gc2VsZWN0aW9uLmVuZDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5iZWdpbiA+IHNlbGVjdGlvbi5lbmQpIHtcbiAgICAgICAgICAgIGJlZ2luID0gc2VsZWN0aW9uLmVuZDtcbiAgICAgICAgICAgIGVuZCA9IHNlbGVjdGlvbi5iZWdpbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobEFsdFBvcyA9PT0gLTEgJiYgckFsdFBvcyA9PT0gdW5kZWZpbmVkKSB7IC8vZG8gbm90IHJlY3Vyc2Ugd2hlbiBhbHJlYWR5IHBhc3RlIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgbGFzdEFsdCA9IDA7XG4gICAgICAgIHByZXZBbHRQb3MgPSBnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBsYXN0QWx0KTtcbiAgICAgICAgYWx0ZXJuYXRpb24gPSBwcmV2QWx0UG9zLmFsdGVybmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZmluZCBsYXN0IG1vZGlmaWVkIGFsdGVybmF0aW9uXG4gICAgICAgIGZvciAoOyBsQWx0UG9zID49IDA7IGxBbHRQb3MtLSkge1xuICAgICAgICAgICAgYWx0UG9zID0gbWFza3NldC52YWxpZFBvc2l0aW9uc1tsQWx0UG9zXTtcbiAgICAgICAgICAgIGlmIChhbHRQb3MgJiYgYWx0UG9zLmFsdGVybmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobEFsdFBvcyA8PSAobWFza1BvcyB8fCAwKSAmJiBwcmV2QWx0UG9zICYmIHByZXZBbHRQb3MubG9jYXRvclthbHRQb3MuYWx0ZXJuYXRpb25dICE9PSBhbHRQb3MubG9jYXRvclthbHRQb3MuYWx0ZXJuYXRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0QWx0ID0gbEFsdFBvcztcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbiA9IG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbbGFzdEFsdF0uYWx0ZXJuYXRpb247XG4gICAgICAgICAgICAgICAgcHJldkFsdFBvcyA9IGFsdFBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbHRlcm5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlY2lzaW9uUG9zID0gcGFyc2VJbnQobGFzdEFsdCk7XG4gICAgICAgIG1hc2tzZXQuZXhjbHVkZXNbZGVjaXNpb25Qb3NdID0gbWFza3NldC5leGNsdWRlc1tkZWNpc2lvblBvc10gfHwgW107XG4gICAgICAgIGlmIChtYXNrUG9zICE9PSB0cnVlKSB7IC8vZ2VuZXJhbGl6ZVxuICAgICAgICAgICAgbWFza3NldC5leGNsdWRlc1tkZWNpc2lvblBvc10ucHVzaChnZXREZWNpc2lvblRha2VyKHByZXZBbHRQb3MpICsgXCI6XCIgKyBwcmV2QWx0UG9zLmFsdGVybmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWxpZElucHV0cyA9IFtdLCByZXN1bHRQb3MgPSAtMTtcbiAgICAgICAgZm9yIChpID0gZGVjaXNpb25Qb3M7IGkgPCBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywgdW5kZWZpbmVkLCB0cnVlKSArIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdFBvcyA9PT0gLTEgJiYgbWFza1BvcyA8PSBpICYmIGMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbGlkSW5wdXRzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0UG9zID0gdmFsaWRJbnB1dHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkUG9zID0gbWFza3NldC52YWxpZFBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmICh2YWxpZFBvcyAmJiB2YWxpZFBvcy5nZW5lcmF0ZWRJbnB1dCAhPT0gdHJ1ZSAmJiAoc2VsZWN0aW9uID09PSB1bmRlZmluZWQgfHwgKGkgPCBiZWdpbiB8fCBpID49IGVuZCkpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRJbnB1dHMucHVzaCh2YWxpZFBvcy5pbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbWFza3NldC52YWxpZFBvc2l0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0UG9zID09PSAtMSAmJiBjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbGlkSW5wdXRzLnB1c2goYyk7XG4gICAgICAgICAgICByZXN1bHRQb3MgPSB2YWxpZElucHV0cy5sZW5ndGggLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKG1hc2tzZXQuZXhjbHVkZXNbZGVjaXNpb25Qb3NdICE9PSB1bmRlZmluZWQgJiYgbWFza3NldC5leGNsdWRlc1tkZWNpc2lvblBvc10ubGVuZ3RoIDwgMTApIHtcbiAgICAgICAgICAgIC8vIG1hc2tzZXQudGVzdHNbZGVjaXNpb25Qb3NdID0gdW5kZWZpbmVkOyAvL2NsZWFyIGRlY2lzaW9uUG9zXG4gICAgICAgICAgICBtYXNrc2V0LnRlc3RzID0ge307ICAvL2NsZWFyIGFsbFxuICAgICAgICAgICAgcmVzZXRNYXNrU2V0LmNhbGwoaW5wdXRtYXNrLCB0cnVlKTsgLy9jbGVhciBnZXRidWZmZXJcbiAgICAgICAgICAgIGlzVmFsaWRSc2x0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWxpZElucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5leHRQb3MgPSBpc1ZhbGlkUnNsdC5jYXJldCB8fCAoZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChpbnB1dG1hc2ssIHVuZGVmaW5lZCwgdHJ1ZSkgKyAxKTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHZhbGlkSW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIC8vIG5leHRQb3MgPSB0cmFuc2xhdGVQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywgbmV4dFBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaXNWYWxpZFJzbHQgPSBpc1ZhbGlkLmNhbGwoaW5wdXRtYXNrLCBuZXh0UG9zLCBpbnB1dCwgZmFsc2UsIGZyb21Jc1ZhbGlkLCB0cnVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSByZXN1bHRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuUnNsdCA9IGlzVmFsaWRSc2x0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFza1BvcyA9PSB0cnVlICYmIGlzVmFsaWRSc2x0KSB7ICAvL3JldHVybiB2YWxpZHBvc2l0aW9uIG9uIGdlbmVyYWxpc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuUnNsdCA9IHtjYXJldFBvczogaX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkUnNsdCkge1xuICAgICAgICAgICAgICAgIHJlc2V0TWFza1NldC5jYWxsKGlucHV0bWFzayk7XG4gICAgICAgICAgICAgICAgcHJldkFsdFBvcyA9IGdldFRlc3QuY2FsbChpbnB1dG1hc2ssIGRlY2lzaW9uUG9zKTsgIC8vZ2V0IHRoZSBjdXJyZW50IGRlY2lzaW9uUG9zIHRvIGV4Y2x1ZGUgfiBuZWVkcyB0byBiZSBiZWZvcmUgcmVzdG9yaW5nIHRoZSBpbml0aWFsIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAvL3Jlc2V0ICYgcmV2ZXJ0XG4gICAgICAgICAgICAgICAgbWFza3NldC52YWxpZFBvc2l0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIFtdLCB2YWxpZFBzQ2xvbmUpO1xuICAgICAgICAgICAgICAgIG1hc2tzZXQudGVzdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgdHN0Q2xvbmUpOyAvL3JlZnJlc2ggdGVzdHMgYWZ0ZXIgcG9zc2libGUgYWx0ZXJuYXRpbmdcbiAgICAgICAgICAgICAgICBpZiAobWFza3NldC5leGNsdWRlc1tkZWNpc2lvblBvc10pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2lzaW9uVGFrZXIgPSBnZXREZWNpc2lvblRha2VyKHByZXZBbHRQb3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFza3NldC5leGNsdWRlc1tkZWNpc2lvblBvc10uaW5kZXhPZihkZWNpc2lvblRha2VyICsgXCI6XCIgKyBwcmV2QWx0UG9zLmFsdGVybmF0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblJzbHQgPSBhbHRlcm5hdGUuY2FsbChpbnB1dG1hc2ssIG1hc2tQb3MsIGMsIHN0cmljdCwgZnJvbUlzVmFsaWQsIGRlY2lzaW9uUG9zIC0gMSwgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hc2tzZXQuZXhjbHVkZXNbZGVjaXNpb25Qb3NdLnB1c2goZGVjaXNpb25UYWtlciArIFwiOlwiICsgcHJldkFsdFBvcy5hbHRlcm5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGRlY2lzaW9uUG9zOyBpIDwgZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChpbnB1dG1hc2ssIHVuZGVmaW5lZCwgdHJ1ZSkgKyAxOyBpKyspIGRlbGV0ZSBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vbGF0ZXN0IGFsdGVybmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblJzbHQgPSBhbHRlcm5hdGUuY2FsbChpbnB1dG1hc2ssIG1hc2tQb3MsIGMsIHN0cmljdCwgZnJvbUlzVmFsaWQsIGRlY2lzaW9uUG9zIC0gMSwgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvL3Jlc2V0IGFsdGVybmF0aW9uIGV4Y2x1ZGVzXG4gICAgaWYgKCFyZXR1cm5Sc2x0IHx8IG9wdHMua2VlcFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgZGVsZXRlIG1hc2tzZXQuZXhjbHVkZXNbZGVjaXNpb25Qb3NdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuUnNsdDtcbn1cblxuZnVuY3Rpb24gY2FzaW5nKGVsZW0sIHRlc3QsIHBvcykge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdHMsXG4gICAgICAgIG1hc2tzZXQgPSB0aGlzLm1hc2tzZXQ7XG5cbiAgICBzd2l0Y2ggKG9wdHMuY2FzaW5nIHx8IHRlc3QuY2FzaW5nKSB7XG4gICAgICAgIGNhc2UgXCJ1cHBlclwiOlxuICAgICAgICAgICAgZWxlbSA9IGVsZW0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibG93ZXJcIjpcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICB2YXIgcG9zQmVmb3JlID0gbWFza3NldC52YWxpZFBvc2l0aW9uc1twb3MgLSAxXTtcbiAgICAgICAgICAgIGlmIChwb3MgPT09IDAgfHwgcG9zQmVmb3JlICYmIHBvc0JlZm9yZS5pbnB1dCA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlLlNwYWNlKSkge1xuICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5jYXNpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gobWFza3NldC52YWxpZFBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgZWxlbSA9IG9wdHMuY2FzaW5nLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbGVtO1xufVxuXG4vL3RvYmUgcHV0IG9uIHByb3RvdHlwZT9cbmZ1bmN0aW9uIGNoZWNrQWx0ZXJuYXRpb25NYXRjaChhbHRBcnIxLCBhbHRBcnIyLCBuYSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdHM7XG5cbiAgICB2YXIgYWx0QXJyQyA9IG9wdHMuZ3JlZWR5ID8gYWx0QXJyMiA6IGFsdEFycjIuc2xpY2UoMCwgMSksXG4gICAgICAgIGlzTWF0Y2ggPSBmYWxzZSxcbiAgICAgICAgbmFBcnIgPSBuYSAhPT0gdW5kZWZpbmVkID8gbmEuc3BsaXQoXCIsXCIpIDogW10sXG4gICAgICAgIG5hTmR4O1xuXG4gICAgLy9yZW1vdmUgbm8gYWx0ZXJuYXRlIGluZGV4ZXMgZnJvbSBhbHRlcm5hdGlvbiBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChuYU5keCA9IGFsdEFycjEuaW5kZXhPZihuYUFycltpXSkpICE9PSAtMSkge1xuICAgICAgICAgICAgYWx0QXJyMS5zcGxpY2UobmFOZHgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYWxuZHggPSAwOyBhbG5keCA8IGFsdEFycjEubGVuZ3RoOyBhbG5keCsrKSB7XG4gICAgICAgIGlmIChhbHRBcnJDLmluY2x1ZGVzKGFsdEFycjFbYWxuZHhdKSkge1xuICAgICAgICAgICAgaXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNNYXRjaDtcbn1cblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiBoYW5kbGVSZW1vdmUoaW5wdXQsIGMsIHBvcywgc3RyaWN0LCBmcm9tSXNWYWxpZCkge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMsIG1hc2tzZXQgPSB0aGlzLm1hc2tzZXQsIG9wdHMgPSB0aGlzLm9wdHM7XG5cbiAgICBpZiAob3B0cy5udW1lcmljSW5wdXQgfHwgaW5wdXRtYXNrLmlzUlRMKSB7XG4gICAgICAgIGlmIChjID09PSBrZXlzLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgYyA9IGtleXMuRGVsZXRlO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IGtleXMuRGVsZXRlKSB7XG4gICAgICAgICAgICBjID0ga2V5cy5CYWNrc3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXRtYXNrLmlzUlRMKSB7XG4gICAgICAgICAgICB2YXIgcGVuZCA9IHBvcy5lbmQ7XG4gICAgICAgICAgICBwb3MuZW5kID0gcG9zLmJlZ2luO1xuICAgICAgICAgICAgcG9zLmJlZ2luID0gcGVuZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsdnAgPSBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBpZiAocG9zLmVuZCA+PSBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLmxlbmd0aCAmJiBsdnAgPj0gcG9zLmVuZCkgeyAvL2hhbmRsZSBudW1lcmljIG5lZ2F0ZSBzeW1ib2wgb2Zmc2V0LCBkdWUgdG8gIGR5bmFtaWMgaml0IG1hc2tpbmdcbiAgICAgICAgcG9zLmVuZCA9IGx2cCArIDE7XG4gICAgfVxuXG4gICAgaWYgKGMgPT09IGtleXMuQmFja3NwYWNlKSB7XG4gICAgICAgIGlmICgocG9zLmVuZCAtIHBvcy5iZWdpbiA8IDEpKSB7XG4gICAgICAgICAgICBwb3MuYmVnaW4gPSBzZWVrUHJldmlvdXMuY2FsbChpbnB1dG1hc2ssIHBvcy5iZWdpbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGMgPT09IGtleXMuRGVsZXRlKSB7XG4gICAgICAgIGlmIChwb3MuYmVnaW4gPT09IHBvcy5lbmQpIHtcbiAgICAgICAgICAgIHBvcy5lbmQgPSBpc01hc2suY2FsbChpbnB1dG1hc2ssIHBvcy5lbmQsIHRydWUsIHRydWUpID8gcG9zLmVuZCArIDEgOiBzZWVrTmV4dC5jYWxsKGlucHV0bWFzaywgcG9zLmVuZCkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBvZmZzZXQ7XG4gICAgaWYgKChvZmZzZXQgPSByZXZhbGlkYXRlTWFzay5jYWxsKGlucHV0bWFzaywgcG9zKSkgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChzdHJpY3QgIT09IHRydWUgJiYgb3B0cy5rZWVwU3RhdGljICE9PSBmYWxzZSB8fCAob3B0cy5yZWdleCAhPT0gbnVsbCAmJiBnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBwb3MuYmVnaW4pLm1hdGNoLmRlZi5pbmRleE9mKFwifFwiKSAhPT0gLTEpKSB7IC8vVE9ETyBORUVEUyBCRVRURVIgQ0hFQ0sgV0hFTiBUTyBBTFRFUk5BVEUgIH4gb3B0cyByZWdleCBpc25cInQgZ29vZCBlbm91Z2hcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBhbHRlcm5hdGUuY2FsbChpbnB1dG1hc2ssIHRydWUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdQb3MgPSByZXN1bHQuY2FyZXQgIT09IHVuZGVmaW5lZCA/IHJlc3VsdC5jYXJldCA6IChyZXN1bHQucG9zID8gc2Vla05leHQuY2FsbChpbnB1dG1hc2ssIHJlc3VsdC5wb3MuYmVnaW4gPyByZXN1bHQucG9zLmJlZ2luIDogcmVzdWx0LnBvcykgOiBnZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywgLTEsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBpZiAoYyAhPT0ga2V5cy5EZWxldGUgfHwgcG9zLmJlZ2luID4gbmV3UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcy5iZWdpbiA9PSBuZXdQb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgbWFza3NldC5wID0gYyA9PT0ga2V5cy5EZWxldGUgPyBwb3MuYmVnaW4gKyBvZmZzZXQgOiBwb3MuYmVnaW47XG4gICAgICAgICAgICBtYXNrc2V0LnAgPSBkZXRlcm1pbmVOZXdDYXJldFBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCB7XG4gICAgICAgICAgICAgICAgYmVnaW46IG1hc2tzZXQucCxcbiAgICAgICAgICAgICAgICBlbmQ6IG1hc2tzZXQucFxuICAgICAgICAgICAgfSwgZmFsc2UsIG9wdHMuaW5zZXJ0TW9kZSA9PT0gZmFsc2UgJiYgYyA9PT0ga2V5cy5CYWNrc3BhY2UgPyBcIm5vbmVcIiA6IHVuZGVmaW5lZCkuYmVnaW47XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vdG9iZSBwdXQgb24gcHJvdG90eXBlP1xuZnVuY3Rpb24gaXNDb21wbGV0ZShidWZmZXIpIHsgLy9yZXR1cm4gdHJ1ZSAvIGZhbHNlIC8gdW5kZWZpbmVkIChyZXBlYXQgKilcbiAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLCBvcHRzID0gdGhpcy5vcHRzLCBtYXNrc2V0ID0gdGhpcy5tYXNrc2V0O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmlzQ29tcGxldGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG9wdHMuaXNDb21wbGV0ZShidWZmZXIsIG9wdHMpO1xuICAgIGlmIChvcHRzLnJlcGVhdCA9PT0gXCIqXCIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIGNvbXBsZXRlID0gZmFsc2UsXG4gICAgICAgIGxycCA9IGRldGVybWluZUxhc3RSZXF1aXJlZFBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCB0cnVlKSxcbiAgICAgICAgYW1sID0gc2Vla1ByZXZpb3VzLmNhbGwoaW5wdXRtYXNrLCBscnAubCk7XG5cbiAgICBpZiAobHJwLmRlZiA9PT0gdW5kZWZpbmVkIHx8IGxycC5kZWYubmV3QmxvY2tNYXJrZXIgfHwgbHJwLmRlZi5vcHRpb25hbGl0eSB8fCBscnAuZGVmLm9wdGlvbmFsUXVhbnRpZmllcikge1xuICAgICAgICBjb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGFtbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGVzdCA9IGdldFRlc3RUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaywgaSkubWF0Y2g7XG4gICAgICAgICAgICBpZiAoKHRlc3Quc3RhdGljICE9PSB0cnVlICYmIG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbaV0gPT09IHVuZGVmaW5lZCAmJiB0ZXN0Lm9wdGlvbmFsaXR5ICE9PSB0cnVlICYmIHRlc3Qub3B0aW9uYWxRdWFudGlmaWVyICE9PSB0cnVlKSB8fCAodGVzdC5zdGF0aWMgPT09IHRydWUgJiYgYnVmZmVyW2ldICE9PSBnZXRQbGFjZWhvbGRlci5jYWxsKGlucHV0bWFzaywgaSwgdGVzdCkpKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tcGxldGU7XG59XG5cbmZ1bmN0aW9uIGlzU2VsZWN0aW9uKHBvc09iaikge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMsXG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHMsIGluc2VydE1vZGVPZmZzZXQgPSBvcHRzLmluc2VydE1vZGUgPyAwIDogMTtcbiAgICByZXR1cm4gaW5wdXRtYXNrLmlzUlRMID8gKHBvc09iai5iZWdpbiAtIHBvc09iai5lbmQpID4gaW5zZXJ0TW9kZU9mZnNldCA6IChwb3NPYmouZW5kIC0gcG9zT2JqLmJlZ2luKSA+IGluc2VydE1vZGVPZmZzZXQ7XG59XG5cbi8vdG9iZSBwdXQgb24gcHJvdG90eXBlP1xuZnVuY3Rpb24gaXNWYWxpZChwb3MsIGMsIHN0cmljdCwgZnJvbUlzVmFsaWQsIGZyb21BbHRlcm5hdGUsIHZhbGlkYXRlT25seSwgZnJvbUNoZWNrdmFsKSB7IC8vc3RyaWN0IHRydWUgfiBubyBjb3JyZWN0aW9uIG9yIGF1dG9maWxsXG4gICAgY29uc3QgaW5wdXRtYXNrID0gdGhpcyxcbiAgICAgICAgJCA9IHRoaXMuZGVwZW5kZW5jeUxpYixcbiAgICAgICAgb3B0cyA9IHRoaXMub3B0cyxcbiAgICAgICAgbWFza3NldCA9IGlucHV0bWFzay5tYXNrc2V0O1xuXG4gICAgc3RyaWN0ID0gc3RyaWN0ID09PSB0cnVlOyAvL2Fsd2F5cyBzZXQgYSB2YWx1ZSB0byBzdHJpY3QgdG8gcHJldmVudCBwb3NzaWJsZSBzdHJhbmdlIGJlaGF2aW9yIGluIHRoZSBleHRlbnNpb25zXG5cbiAgICB2YXIgbWFza1BvcyA9IHBvcztcbiAgICBpZiAocG9zLmJlZ2luICE9PSB1bmRlZmluZWQpIHsgLy9wb3NpdGlvbiB3YXMgYSBwb3NpdGlvbiBvYmplY3QgLSB1c2VkIHRvIGhhbmRsZSBhIGRlbGV0ZSBieSB0eXBpbmcgb3ZlciBhIHNlbGVjdGlvblxuICAgICAgICBtYXNrUG9zID0gaW5wdXRtYXNrLmlzUlRMID8gcG9zLmVuZCA6IHBvcy5iZWdpbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQ29tbWFuZE9iamVjdChjb21tYW5kT2JqKSB7XG4gICAgICAgIGlmIChjb21tYW5kT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjb21tYW5kT2JqLnJlbW92ZSAhPT0gdW5kZWZpbmVkKSB7IC8vcmVtb3ZlIHBvc2l0aW9uKHMpXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbW1hbmRPYmoucmVtb3ZlKSkgY29tbWFuZE9iai5yZW1vdmUgPSBbY29tbWFuZE9iai5yZW1vdmVdO1xuICAgICAgICAgICAgICAgIGNvbW1hbmRPYmoucmVtb3ZlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0bWFzay5pc1JUTCA/IGEucG9zIC0gYi5wb3MgOiBiLnBvcyAtIGEucG9zO1xuICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGxtbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZU1hc2suY2FsbChpbnB1dG1hc2ssIHtiZWdpbjogbG1udCwgZW5kOiBsbW50ICsgMX0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbW1hbmRPYmoucmVtb3ZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRPYmouaW5zZXJ0ICE9PSB1bmRlZmluZWQpIHsgLy9pbnNlcnQgcG9zaXRpb24ocylcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29tbWFuZE9iai5pbnNlcnQpKSBjb21tYW5kT2JqLmluc2VydCA9IFtjb21tYW5kT2JqLmluc2VydF07XG4gICAgICAgICAgICAgICAgY29tbWFuZE9iai5pbnNlcnQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRtYXNrLmlzUlRMID8gYi5wb3MgLSBhLnBvcyA6IGEucG9zIC0gYi5wb3M7XG4gICAgICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAobG1udCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG1udC5jICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkLmNhbGwoaW5wdXRtYXNrLCBsbW50LnBvcywgbG1udC5jLCBsbW50LnN0cmljdCAhPT0gdW5kZWZpbmVkID8gbG1udC5zdHJpY3QgOiB0cnVlLCBsbW50LmZyb21Jc1ZhbGlkICE9PSB1bmRlZmluZWQgPyBsbW50LmZyb21Jc1ZhbGlkIDogZnJvbUlzVmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29tbWFuZE9iai5pbnNlcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21tYW5kT2JqLnJlZnJlc2hGcm9tQnVmZmVyICYmIGNvbW1hbmRPYmouYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZnJlc2ggPSBjb21tYW5kT2JqLnJlZnJlc2hGcm9tQnVmZmVyO1xuICAgICAgICAgICAgICAgIHJlZnJlc2hGcm9tQnVmZmVyLmNhbGwoaW5wdXRtYXNrLCByZWZyZXNoID09PSB0cnVlID8gcmVmcmVzaCA6IHJlZnJlc2guc3RhcnQsIHJlZnJlc2guZW5kLCBjb21tYW5kT2JqLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgY29tbWFuZE9iai5yZWZyZXNoRnJvbUJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbW1hbmRPYmoucmV3cml0ZVBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXNrUG9zID0gY29tbWFuZE9iai5yZXdyaXRlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgLy8gY29tbWFuZE9iai5yZXdyaXRlUG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29tbWFuZE9iaiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRPYmo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2lzVmFsaWQocG9zaXRpb24sIGMsIHN0cmljdCkge1xuICAgICAgICB2YXIgcnNsdCA9IGZhbHNlO1xuICAgICAgICBnZXRUZXN0cy5jYWxsKGlucHV0bWFzaywgcG9zaXRpb24pLmV2ZXJ5KGZ1bmN0aW9uICh0c3QsIG5keCkge1xuICAgICAgICAgICAgdmFyIHRlc3QgPSB0c3QubWF0Y2g7XG4gICAgICAgICAgICAvL21ha2Ugc3VyZSB0aGUgYnVmZmVyIGlzIHNldCBhbmQgY29ycmVjdFxuICAgICAgICAgICAgZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICh0ZXN0LmppdCAmJiBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3NlZWtQcmV2aW91cy5jYWxsKGlucHV0bWFzaywgcG9zaXRpb24pXSA9PT0gdW5kZWZpbmVkKSAvL2lnbm9yZSBpZiBqaXQgaXMgbm90IGRlc2lyYWJsZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJzbHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gaXMgZmFsc2Ugb3IgYSBqc29uIG9iamVjdCA9PiB7IHBvczogPz8sIGM6ID8/fSBvciB0cnVlXG4gICAgICAgICAgICAgICAgcnNsdCA9IHRlc3QuZm4gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgIHRlc3QuZm4udGVzdChjLCBtYXNrc2V0LCBwb3NpdGlvbiwgc3RyaWN0LCBvcHRzLCBpc1NlbGVjdGlvbi5jYWxsKGlucHV0bWFzaywgcG9zKSkgOiAoYyA9PT0gdGVzdC5kZWYgfHwgYyA9PT0gb3B0cy5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyKSAmJiB0ZXN0LmRlZiAhPT0gXCJcIiA/IC8vbm9uIG1hc2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBnZXRQbGFjZWhvbGRlci5jYWxsKGlucHV0bWFzaywgcG9zaXRpb24sIHRlc3QsIHRydWUpIHx8IHRlc3QuZGVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyc2x0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gcnNsdC5jICE9PSB1bmRlZmluZWQgPyByc2x0LmMgOiBjLCB2YWxpZGF0ZWRQb3MgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBlbGVtID0gKGVsZW0gPT09IG9wdHMuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciAmJiB0ZXN0LnN0YXRpYyA9PT0gdHJ1ZSkgP1xuICAgICAgICAgICAgICAgICAgICAoZ2V0UGxhY2Vob2xkZXIuY2FsbChpbnB1dG1hc2ssIHBvc2l0aW9uLCB0ZXN0LCB0cnVlKSB8fCB0ZXN0LmRlZikgOiBlbGVtO1xuXG4gICAgICAgICAgICAgICAgcnNsdCA9IHByb2Nlc3NDb21tYW5kT2JqZWN0KHJzbHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJzbHQgIT09IHRydWUgJiYgcnNsdC5wb3MgIT09IHVuZGVmaW5lZCAmJiByc2x0LnBvcyAhPT0gcG9zaXRpb24pIHsgLy90aGVpciBpcyBhIHBvc2l0aW9uIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRQb3MgPSByc2x0LnBvcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocnNsdCAhPT0gdHJ1ZSAmJiByc2x0LnBvcyA9PT0gdW5kZWZpbmVkICYmIHJzbHQuYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy9icmVha291dCBpZiBub3RoaW5nIHRvIGluc2VydFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXZhbGlkYXRlTWFzay5jYWxsKGlucHV0bWFzaywgcG9zLCAkLmV4dGVuZCh7fSwgdHN0LCB7XG4gICAgICAgICAgICAgICAgICAgIFwiaW5wdXRcIjogY2FzaW5nLmNhbGwoaW5wdXRtYXNrLCBlbGVtLCB0ZXN0LCB2YWxpZGF0ZWRQb3MpXG4gICAgICAgICAgICAgICAgfSksIGZyb21Jc1ZhbGlkLCB2YWxpZGF0ZWRQb3MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByc2x0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy9icmVhayBmcm9tIGxvb3BcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnNsdDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgcG9zaXRpb25zQ2xvbmUgPSAkLmV4dGVuZCh0cnVlLCB7fSwgbWFza3NldC52YWxpZFBvc2l0aW9ucyk7IC8vY2xvbmUgdGhlIGN1cnJlbnRQb3NpdGlvbnNcblxuICAgIGlmIChvcHRzLmtlZXBTdGF0aWMgPT09IGZhbHNlICYmIG1hc2tzZXQuZXhjbHVkZXNbbWFza1Bvc10gIT09IHVuZGVmaW5lZCAmJiBmcm9tQWx0ZXJuYXRlICE9PSB0cnVlICYmIGZyb21Jc1ZhbGlkICE9PSB0cnVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBtYXNrUG9zOyBpIDwgKGlucHV0bWFzay5pc1JUTCA/IHBvcy5iZWdpbiA6IHBvcy5lbmQpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtYXNrc2V0LmV4Y2x1ZGVzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXNrc2V0LmV4Y2x1ZGVzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXNrc2V0LnRlc3RzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnByZVZhbGlkYXRpb24gPT09IFwiZnVuY3Rpb25cIiAmJiBmcm9tSXNWYWxpZCAhPT0gdHJ1ZSAmJiB2YWxpZGF0ZU9ubHkgIT09IHRydWUpIHtcbiAgICAgICAgcmVzdWx0ID0gb3B0cy5wcmVWYWxpZGF0aW9uLmNhbGwoaW5wdXRtYXNrLCBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spLCBtYXNrUG9zLCBjLCBpc1NlbGVjdGlvbi5jYWxsKGlucHV0bWFzaywgcG9zKSwgb3B0cywgbWFza3NldCwgcG9zLCBzdHJpY3QgfHwgZnJvbUFsdGVybmF0ZSk7XG4gICAgICAgIHJlc3VsdCA9IHByb2Nlc3NDb21tYW5kT2JqZWN0KHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHsgLy9wcmVWYWxpZGF0aW9uIHJlc3VsdFxuICAgICAgICByZXN1bHQgPSBfaXNWYWxpZChtYXNrUG9zLCBjLCBzdHJpY3QpO1xuICAgICAgICBpZiAoKCFzdHJpY3QgfHwgZnJvbUlzVmFsaWQgPT09IHRydWUpICYmIHJlc3VsdCA9PT0gZmFsc2UgJiYgdmFsaWRhdGVPbmx5ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFBvc1ZhbGlkID0gbWFza3NldC52YWxpZFBvc2l0aW9uc1ttYXNrUG9zXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UG9zVmFsaWQgJiYgY3VycmVudFBvc1ZhbGlkLm1hdGNoLnN0YXRpYyA9PT0gdHJ1ZSAmJiAoY3VycmVudFBvc1ZhbGlkLm1hdGNoLmRlZiA9PT0gYyB8fCBjID09PSBvcHRzLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBcImNhcmV0XCI6IHNlZWtOZXh0LmNhbGwoaW5wdXRtYXNrLCBtYXNrUG9zKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmluc2VydE1vZGUgfHwgbWFza3NldC52YWxpZFBvc2l0aW9uc1tzZWVrTmV4dC5jYWxsKGlucHV0bWFzaywgbWFza1BvcyldID09PSB1bmRlZmluZWQgfHwgcG9zLmVuZCA+IG1hc2tQb3MpIHsgLy9kb2VzIHRoZSBpbnB1dCBtYXRjaCBvbiBhIGZ1cnRoZXIgcG9zaXRpb24/XG4gICAgICAgICAgICAgICAgICAgIHZhciBza2lwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXNrc2V0LmppdE9mZnNldFttYXNrUG9zXSAmJiBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3NlZWtOZXh0LmNhbGwoaW5wdXRtYXNrLCBtYXNrUG9zKV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXNWYWxpZC5jYWxsKGlucHV0bWFzaywgbWFza1BvcyArIG1hc2tzZXQuaml0T2Zmc2V0W21hc2tQb3NdLCBjLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21BbHRlcm5hdGUgIT09IHRydWUpIHJlc3VsdC5jYXJldCA9IG1hc2tQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5lbmQgPiBtYXNrUG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW21hc2tQb3NdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2tpcCAmJiAhaXNNYXNrLmNhbGwoaW5wdXRtYXNrLCBtYXNrUG9zLCBvcHRzLmtlZXBTdGF0aWMgJiYgbWFza1BvcyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5Qb3MgPSBtYXNrUG9zICsgMSwgc25Qb3MgPSBzZWVrTmV4dC5jYWxsKGlucHV0bWFzaywgbWFza1BvcywgZmFsc2UsIG1hc2tQb3MgIT09IDApOyBuUG9zIDw9IHNuUG9zOyBuUG9zKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIWlzTWFzayhuUG9zLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFx0Y29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9pc1ZhbGlkKG5Qb3MsIGMsIHN0cmljdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJhY2tiYWNrUG9zaXRpb25zLmNhbGwoaW5wdXRtYXNrLCBtYXNrUG9zLCByZXN1bHQucG9zICE9PSB1bmRlZmluZWQgPyByZXN1bHQucG9zIDogblBvcykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrUG9zID0gblBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0bWFzay5oYXNBbHRlcm5hdG9yICYmIGZyb21BbHRlcm5hdGUgIT09IHRydWUgJiYgIXN0cmljdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UgJiYgb3B0cy5rZWVwU3RhdGljICYmIChpc0NvbXBsZXRlLmNhbGwoaW5wdXRtYXNrLCBnZXRCdWZmZXIuY2FsbChpbnB1dG1hc2spKSB8fCBtYXNrUG9zID09PSAwKSkgeyAvL3RyeSBmdXp6eSBhbHRlcm5hdG9yIGxvZ2ljXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYWx0ZXJuYXRlLmNhbGwoaW5wdXRtYXNrLCBtYXNrUG9zLCBjLCBzdHJpY3QsIGZyb21Jc1ZhbGlkLCB1bmRlZmluZWQsIHBvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU2VsZWN0aW9uLmNhbGwoaW5wdXRtYXNrLCBwb3MpICYmIG1hc2tzZXQudGVzdHNbbWFza1Bvc10gJiYgbWFza3NldC50ZXN0c1ttYXNrUG9zXS5sZW5ndGggPiAxICYmIG9wdHMua2VlcFN0YXRpYykgeyAvL3NlbGVjdGlvbiBjbGVhcnMgYW4gYWx0ZXJuYXRlZCBrZWVwc3RhdGljIG1hc2sgfiAjMjE4OVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFsdGVybmF0ZS5jYWxsKGlucHV0bWFzaywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PSB0cnVlICYmIG9wdHMubnVtZXJpY0lucHV0ICE9PSB0cnVlICYmIG1hc2tzZXQudGVzdHNbbWFza1Bvc10gJiYgbWFza3NldC50ZXN0c1ttYXNrUG9zXS5sZW5ndGggPiAxICYmIGdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoaW5wdXRtYXNrLCB1bmRlZmluZWQsIHRydWUpID4gbWFza1Bvcykge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQWx0ZXJuYXRpbmdcIik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYWx0ZXJuYXRlLmNhbGwoaW5wdXRtYXNrLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBcInBvc1wiOiBtYXNrUG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5wb3N0VmFsaWRhdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIGZyb21Jc1ZhbGlkICE9PSB0cnVlICYmIHZhbGlkYXRlT25seSAhPT0gdHJ1ZSkge1xuICAgICAgICB2YXIgcG9zdFJlc3VsdCA9IG9wdHMucG9zdFZhbGlkYXRpb24uY2FsbChpbnB1dG1hc2ssIGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzaywgdHJ1ZSksIHBvcy5iZWdpbiAhPT0gdW5kZWZpbmVkID8gKGlucHV0bWFzay5pc1JUTCA/IHBvcy5lbmQgOiBwb3MuYmVnaW4pIDogcG9zLCBjLCByZXN1bHQsIG9wdHMsIG1hc2tzZXQsIHN0cmljdCwgZnJvbUNoZWNrdmFsKTtcbiAgICAgICAgaWYgKHBvc3RSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcG9zdFJlc3VsdCA9PT0gdHJ1ZSA/IHJlc3VsdCA6IHBvc3RSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5wb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQucG9zID0gbWFza1BvcztcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSB8fCB2YWxpZGF0ZU9ubHkgPT09IHRydWUpIHtcbiAgICAgICAgcmVzZXRNYXNrU2V0LmNhbGwoaW5wdXRtYXNrLCB0cnVlKTtcbiAgICAgICAgbWFza3NldC52YWxpZFBvc2l0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIFtdLCBwb3NpdGlvbnNDbG9uZSk7IC8vcmV2ZXJ0IHZhbGlkYXRpb24gY2hhbmdlc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNrYmFja1Bvc2l0aW9ucy5jYWxsKGlucHV0bWFzaywgdW5kZWZpbmVkLCBtYXNrUG9zLCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgZW5kUmVzdWx0ID0gcHJvY2Vzc0NvbW1hbmRPYmplY3QocmVzdWx0KTtcbiAgICAvLyBjb25zb2xlLmxvZyhcInJldHVybmVkIHJlc3VsdCBcIiArIEpTT04uc3RyaW5naWZ5KGVuZFJlc3VsdCkpO1xuICAgIGlmIChpbnB1dG1hc2subWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGdldEJ1ZmZlci5jYWxsKGlucHV0bWFzayk7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gaW5wdXRtYXNrLm1heExlbmd0aCAmJiAhZnJvbUlzVmFsaWQpIHtcbiAgICAgICAgICAgIHJlc2V0TWFza1NldC5jYWxsKGlucHV0bWFzaywgdHJ1ZSk7XG4gICAgICAgICAgICBtYXNrc2V0LnZhbGlkUG9zaXRpb25zID0gJC5leHRlbmQodHJ1ZSwgW10sIHBvc2l0aW9uc0Nsb25lKTsgLy9yZXZlcnQgdmFsaWRhdGlvbiBjaGFuZ2VzXG4gICAgICAgICAgICBlbmRSZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kUmVzdWx0O1xufVxuXG4vL3RvYmUgcHV0IG9uIHByb3RvdHlwZT9cbmZ1bmN0aW9uIHBvc2l0aW9uQ2FuTWF0Y2hEZWZpbml0aW9uKHBvcywgdGVzdERlZmluaXRpb24sIG9wdHMpIHtcbiAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLFxuICAgICAgICBtYXNrc2V0ID0gdGhpcy5tYXNrc2V0O1xuXG4gICAgdmFyIHZhbGlkID0gZmFsc2UsXG4gICAgICAgIHRlc3RzID0gZ2V0VGVzdHMuY2FsbChpbnB1dG1hc2ssIHBvcyk7XG4gICAgZm9yICh2YXIgdG5keCA9IDA7IHRuZHggPCB0ZXN0cy5sZW5ndGg7IHRuZHgrKykge1xuICAgICAgICBpZiAodGVzdHNbdG5keF0ubWF0Y2ggJiZcbiAgICAgICAgICAgICgodGVzdHNbdG5keF0ubWF0Y2hbXCJuYXRpdmVEZWZcIl0gPT09IHRlc3REZWZpbml0aW9uLm1hdGNoW29wdHMuc2hpZnRQb3NpdGlvbnMgPyBcImRlZlwiIDogXCJuYXRpdmVEZWZcIl0gJiYgKCFvcHRzLnNoaWZ0UG9zaXRpb25zIHx8ICF0ZXN0RGVmaW5pdGlvbi5tYXRjaC5zdGF0aWMpKSB8fFxuICAgICAgICAgICAgICAgIHRlc3RzW3RuZHhdLm1hdGNoW1wibmF0aXZlRGVmXCJdID09PSB0ZXN0RGVmaW5pdGlvbi5tYXRjaFtcIm5hdGl2ZURlZlwiXSB8fFxuICAgICAgICAgICAgICAgIChvcHRzLnJlZ2V4ICYmICF0ZXN0c1t0bmR4XS5tYXRjaC5zdGF0aWMgJiYgdGVzdHNbdG5keF0ubWF0Y2guZm4udGVzdCh0ZXN0RGVmaW5pdGlvbi5pbnB1dCwgbWFza3NldCwgcG9zLCBmYWxzZSwgb3B0cykpKSkge1xuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGVzdHNbdG5keF0ubWF0Y2ggJiYgdGVzdHNbdG5keF0ubWF0Y2hbXCJkZWZcIl0gPT09IHRlc3REZWZpbml0aW9uLm1hdGNoW1wibmF0aXZlRGVmXCJdKSB7XG4gICAgICAgICAgICB2YWxpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG1hc2tzZXQuaml0T2Zmc2V0W3Bvc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsaWQgPSBwb3NpdGlvbkNhbk1hdGNoRGVmaW5pdGlvbi5jYWxsKGlucHV0bWFzaywgcG9zICsgbWFza3NldC5qaXRPZmZzZXRbcG9zXSwgdGVzdERlZmluaXRpb24sIG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbn1cblxuLy90b2JlIHB1dCBvbiBwcm90b3R5cGU/XG5mdW5jdGlvbiByZWZyZXNoRnJvbUJ1ZmZlcihzdGFydCwgZW5kLCBidWZmZXIpIHtcbiAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLFxuICAgICAgICBtYXNrc2V0ID0gdGhpcy5tYXNrc2V0LFxuICAgICAgICBvcHRzID0gdGhpcy5vcHRzLFxuICAgICAgICAkID0gdGhpcy5kZXBlbmRlbmN5TGliO1xuICAgIC8vIGNoZWNrVmFsLmNhbGwoaW5wdXRtYXNrLCBlbCwgZmFsc2UsIHRydWUsIGlzUlRMID8gYnVmZmVyLnJldmVyc2UoKSA6IGJ1ZmZlcik7XG4gICAgdmFyIGksIHAsIHNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgPSBvcHRzLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIsXG4gICAgICAgIGJmZnIgPSBpbnB1dG1hc2suaXNSVEwgPyBidWZmZXIuc2xpY2UoKS5yZXZlcnNlKCkgOiBidWZmZXI7XG4gICAgb3B0cy5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyID0gXCJcIjtcbiAgICBpZiAoc3RhcnQgPT09IHRydWUpIHtcbiAgICAgICAgcmVzZXRNYXNrU2V0LmNhbGwoaW5wdXRtYXNrKTtcbiAgICAgICAgbWFza3NldC50ZXN0cyA9IHt9OyAvL3JlZnJlc2ggdGVzdHMgYWZ0ZXIgcG9zc2libGUgYWx0ZXJuYXRpbmdcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICBwID0gZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbi5jYWxsKGlucHV0bWFzaywge2JlZ2luOiAwLCBlbmQ6IDB9LCBmYWxzZSkuYmVnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBrZXlwcmVzcyA9IG5ldyAkLkV2ZW50KFwia2V5cHJlc3NcIik7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBrZXlwcmVzcy5rZXkgPSBiZmZyW2ldLnRvU3RyaW5nKCk7XG4gICAgICAgIGlucHV0bWFzay5pZ25vcmFibGUgPSBmYWxzZTsgLy9tYWtlIHN1cmUgaWdub3JhYmxlIGlzIGlnbm9yZWQgOy0pXG4gICAgICAgIHZhciB2YWxSZXN1bHQgPSBFdmVudEhhbmRsZXJzLmtleXByZXNzRXZlbnQuY2FsbChpbnB1dG1hc2ssIGtleXByZXNzLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHApO1xuICAgICAgICBpZiAodmFsUmVzdWx0ICE9PSBmYWxzZSAmJiB2YWxSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcCA9IHZhbFJlc3VsdC5mb3J3YXJkUG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRzLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgPSBza2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyO1xufVxuXG4vL3RvYmUgcHV0IG9uIHByb3RvdHlwZT9cbi8vZmlsbCBpbiBiZXN0IHBvc2l0aW9ucyBhY2NvcmRpbmcgdGhlIGN1cnJlbnQgaW5wdXRcbmZ1bmN0aW9uIHRyYWNrYmFja1Bvc2l0aW9ucyhvcmlnaW5hbFBvcywgbmV3UG9zLCBmaWxsT25seSkge1xuICAgIGNvbnN0IGlucHV0bWFzayA9IHRoaXMsXG4gICAgICAgIG1hc2tzZXQgPSB0aGlzLm1hc2tzZXQsXG4gICAgICAgICQgPSB0aGlzLmRlcGVuZGVuY3lMaWI7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcInRyYWNrYmFja1Bvc2l0aW9ucyBcIiArIG9yaWdpbmFsUG9zICsgXCIgXCIgKyBuZXdQb3MpO1xuICAgIGlmIChvcmlnaW5hbFBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vZmluZCBwcmV2aW91cyB2YWxpZFxuICAgICAgICBmb3IgKG9yaWdpbmFsUG9zID0gbmV3UG9zIC0gMTsgb3JpZ2luYWxQb3MgPiAwOyBvcmlnaW5hbFBvcy0tKSB7XG4gICAgICAgICAgICBpZiAobWFza3NldC52YWxpZFBvc2l0aW9uc1tvcmlnaW5hbFBvc10pIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIHBzID0gb3JpZ2luYWxQb3M7IHBzIDwgbmV3UG9zOyBwcysrKSB7XG4gICAgICAgIGlmIChtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3BzXSA9PT0gdW5kZWZpbmVkICYmICFpc01hc2suY2FsbChpbnB1dG1hc2ssIHBzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHZhciB2cCA9IHBzID09IDAgPyBnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBwcykgOiBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW3BzIC0gMV07XG4gICAgICAgICAgICBpZiAodnApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdHMgPSBnZXRUZXN0cy5jYWxsKGlucHV0bWFzaywgcHMpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RzW3Rlc3RzLmxlbmd0aCAtIDFdLm1hdGNoLmRlZiA9PT0gXCJcIikgdGVzdHMucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJlc3RNYXRjaCA9IGRldGVybWluZVRlc3RUZW1wbGF0ZS5jYWxsKGlucHV0bWFzaywgcHMsIHRlc3RzKSwgbnA7XG4gICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCAmJiAoYmVzdE1hdGNoLm1hdGNoLmppdCAhPT0gdHJ1ZSB8fCAoYmVzdE1hdGNoLm1hdGNoLm5ld0Jsb2NrTWFya2VyID09PSBcIm1hc3RlclwiICYmIChucCA9IG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbcHMgKyAxXSkgJiYgbnAubWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyID09PSB0cnVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gJC5leHRlbmQoe30sIGJlc3RNYXRjaCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnB1dFwiOiBnZXRQbGFjZWhvbGRlci5jYWxsKGlucHV0bWFzaywgcHMsIGJlc3RNYXRjaC5tYXRjaCwgdHJ1ZSkgfHwgYmVzdE1hdGNoLm1hdGNoLmRlZlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmdlbmVyYXRlZElucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZU1hc2suY2FsbChpbnB1dG1hc2ssIHBzLCBiZXN0TWF0Y2gsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxsT25seSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXZhbGlkYXRlIHRoZSBuZXcgcG9zaXRpb24gdG8gdXBkYXRlIHRoZSBsb2NhdG9yIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ZwSW5wdXQgPSBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW25ld1Bvc10uaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW25ld1Bvc10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZC5jYWxsKGlucHV0bWFzaywgbmV3UG9zLCBjdnBJbnB1dCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vdG9iZSBwdXQgb24gcHJvdG90eXBlP1xuZnVuY3Rpb24gcmV2YWxpZGF0ZU1hc2socG9zLCB2YWxpZFRlc3QsIGZyb21Jc1ZhbGlkLCB2YWxpZGF0ZWRQb3MpIHtcbiAgICBjb25zdCBpbnB1dG1hc2sgPSB0aGlzLFxuICAgICAgICBtYXNrc2V0ID0gdGhpcy5tYXNrc2V0LFxuICAgICAgICBvcHRzID0gdGhpcy5vcHRzLFxuICAgICAgICAkID0gdGhpcy5kZXBlbmRlbmN5TGliO1xuXG4gICAgZnVuY3Rpb24gSXNFbmNsb3NlZFN0YXRpYyhwb3MsIHZhbGlkcywgc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBwb3NNYXRjaCA9IHZhbGlkc1twb3NdO1xuICAgICAgICBpZiAocG9zTWF0Y2ggIT09IHVuZGVmaW5lZCAmJiBwb3NNYXRjaC5tYXRjaC5zdGF0aWMgPT09IHRydWUgJiYgcG9zTWF0Y2gubWF0Y2gub3B0aW9uYWxpdHkgIT09IHRydWUgJiYgKHZhbGlkc1swXSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkc1swXS5hbHRlcm5hdGlvbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgdmFyIHByZXZNYXRjaCA9IHNlbGVjdGlvbi5iZWdpbiA8PSBwb3MgLSAxID8gdmFsaWRzW3BvcyAtIDFdICYmIHZhbGlkc1twb3MgLSAxXS5tYXRjaC5zdGF0aWMgPT09IHRydWUgJiYgdmFsaWRzW3BvcyAtIDFdIDogdmFsaWRzW3BvcyAtIDFdLFxuICAgICAgICAgICAgICAgIG5leHRNYXRjaCA9IHNlbGVjdGlvbi5lbmQgPiBwb3MgKyAxID8gdmFsaWRzW3BvcyArIDFdICYmIHZhbGlkc1twb3MgKyAxXS5tYXRjaC5zdGF0aWMgPT09IHRydWUgJiYgdmFsaWRzW3BvcyArIDFdIDogdmFsaWRzW3BvcyArIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHByZXZNYXRjaCAmJiBuZXh0TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXQgPSAwLCBiZWdpbiA9IHBvcy5iZWdpbiAhPT0gdW5kZWZpbmVkID8gcG9zLmJlZ2luIDogcG9zLCBlbmQgPSBwb3MuZW5kICE9PSB1bmRlZmluZWQgPyBwb3MuZW5kIDogcG9zLFxuICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgaWYgKHBvcy5iZWdpbiA+IHBvcy5lbmQpIHtcbiAgICAgICAgYmVnaW4gPSBwb3MuZW5kO1xuICAgICAgICBlbmQgPSBwb3MuYmVnaW47XG4gICAgfVxuXG4gICAgdmFsaWRhdGVkUG9zID0gdmFsaWRhdGVkUG9zICE9PSB1bmRlZmluZWQgPyB2YWxpZGF0ZWRQb3MgOiBiZWdpbjtcbiAgICBpZiAoZnJvbUlzVmFsaWQgPT09IHVuZGVmaW5lZCAmJiAoYmVnaW4gIT09IGVuZCB8fCAob3B0cy5pbnNlcnRNb2RlICYmIG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbdmFsaWRhdGVkUG9zXSAhPT0gdW5kZWZpbmVkKSB8fCB2YWxpZFRlc3QgPT09IHVuZGVmaW5lZCB8fCB2YWxpZFRlc3QubWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyIHx8IHZhbGlkVGVzdC5tYXRjaC5vcHRpb25hbGl0eSkpIHtcbiAgICAgICAgLy9yZXBvc2l0aW9uICYgcmV2YWxpZGF0ZSBvdGhlcnNcbiAgICAgICAgdmFyIHBvc2l0aW9uc0Nsb25lID0gJC5leHRlbmQodHJ1ZSwge30sIG1hc2tzZXQudmFsaWRQb3NpdGlvbnMpLFxuICAgICAgICAgICAgbHZwID0gZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChpbnB1dG1hc2ssIHVuZGVmaW5lZCwgdHJ1ZSksXG4gICAgICAgICAgICBpO1xuICAgICAgICBtYXNrc2V0LnAgPSBiZWdpbjsgLy9uZWVkZWQgZm9yIGFsdGVybmF0ZWQgcG9zaXRpb24gYWZ0ZXIgb3ZlcnR5cGUgc2VsZWN0aW9uXG5cbiAgICAgICAgZm9yIChpID0gbHZwOyBpID49IGJlZ2luOyBpLS0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtYXNrc2V0LnZhbGlkUG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKHZhbGlkVGVzdCA9PT0gdW5kZWZpbmVkKSBkZWxldGUgbWFza3NldC50ZXN0c1tpICsgMV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IHZhbGlkYXRlZFBvcyxcbiAgICAgICAgICAgIHBvc01hdGNoID0gaiwgdCwgY2FuTWF0Y2gsIHRlc3Q7XG5cbiAgICAgICAgaWYgKHZhbGlkVGVzdCkge1xuICAgICAgICAgICAgbWFza3NldC52YWxpZFBvc2l0aW9uc1t2YWxpZGF0ZWRQb3NdID0gJC5leHRlbmQodHJ1ZSwge30sIHZhbGlkVGVzdCk7XG4gICAgICAgICAgICBwb3NNYXRjaCsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gdmFsaWRUZXN0ID8gZW5kIDogZW5kIC0gMTsgaSA8PSBsdnA7IGkrKykge1xuICAgICAgICAgICAgaWYgKCh0ID0gcG9zaXRpb25zQ2xvbmVbaV0pICE9PSB1bmRlZmluZWQgJiYgdC5nZW5lcmF0ZWRJbnB1dCAhPT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIChpID49IGVuZCB8fCAoaSA+PSBiZWdpbiAmJiBJc0VuY2xvc2VkU3RhdGljKGksIHBvc2l0aW9uc0Nsb25lLCB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiBiZWdpbixcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgICAgICB9KSkpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRlc3QgPSBnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBwb3NNYXRjaCksIHRlc3QubWF0Y2guZGVmICE9PSBcIlwiKSB7IC8vbG9vcCBuZWVkZWQgdG8gbWF0Y2ggZnVydGhlciBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjYW5NYXRjaCA9IHBvc2l0aW9uQ2FuTWF0Y2hEZWZpbml0aW9uLmNhbGwoaW5wdXRtYXNrLCBwb3NNYXRjaCwgdCwgb3B0cykpICE9PSBmYWxzZSB8fCB0Lm1hdGNoLmRlZiA9PT0gXCIrXCIpIHsgLy92YWxpZGF0ZWQgbWF0Y2ggLy93ZSBzdGlsbCBuZWVkIHNvbWUgaGFja2VyeSBmb3IgdGhlICsgdmFsaWRhdG9yIChudW1lcmljIGFsaWFzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQubWF0Y2guZGVmID09PSBcIitcIikgZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpc1ZhbGlkLmNhbGwoaW5wdXRtYXNrLCBwb3NNYXRjaCwgdC5pbnB1dCwgdC5tYXRjaC5kZWYgIT09IFwiK1wiLCAvKnQubWF0Y2guZGVmICE9PSBcIitcIiovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSByZXN1bHQgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IChyZXN1bHQucG9zIHx8IHBvc01hdGNoKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkICYmIGNhbk1hdGNoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRUZXN0ID09PSB1bmRlZmluZWQgJiYgdC5tYXRjaC5zdGF0aWMgJiYgaSA9PT0gcG9zLmJlZ2luKSBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQgJiYgZ2V0QnVmZmVyLmNhbGwoaW5wdXRtYXNrKSwgcG9zTWF0Y2ggPiBtYXNrc2V0Lm1hc2tMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvc01hdGNoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZXRUZXN0LmNhbGwoaW5wdXRtYXNrLCBwb3NNYXRjaCkubWF0Y2guZGVmID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9yZXN0b3JlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgcG9zTWF0Y2ggPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWxpZCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgbWFza3NldC52YWxpZFBvc2l0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIFtdLCBwb3NpdGlvbnNDbG9uZSk7XG4gICAgICAgICAgICByZXNldE1hc2tTZXQuY2FsbChpbnB1dG1hc2ssIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWxpZFRlc3QgJiYgZ2V0VGVzdC5jYWxsKGlucHV0bWFzaywgdmFsaWRhdGVkUG9zKS5tYXRjaC5jZCA9PT0gdmFsaWRUZXN0Lm1hdGNoLmNkKSB7XG4gICAgICAgIG1hc2tzZXQudmFsaWRQb3NpdGlvbnNbdmFsaWRhdGVkUG9zXSA9ICQuZXh0ZW5kKHRydWUsIHt9LCB2YWxpZFRlc3QpO1xuICAgIH1cblxuICAgIHJlc2V0TWFza1NldC5jYWxsKGlucHV0bWFzaywgdHJ1ZSk7XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHJlZmxlY3RBcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0ICE9PSBudWxsICYmIFJlZmxlY3QuYXBwbHk7XG52YXIgYmFkQXJyYXlMaWtlO1xudmFyIGlzQ2FsbGFibGVNYXJrZXI7XG5pZiAodHlwZW9mIHJlZmxlY3RBcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdHRyeSB7XG5cdFx0YmFkQXJyYXlMaWtlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnbGVuZ3RoJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRocm93IGlzQ2FsbGFibGVNYXJrZXI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aXNDYWxsYWJsZU1hcmtlciA9IHt9O1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG5cdFx0cmVmbGVjdEFwcGx5KGZ1bmN0aW9uICgpIHsgdGhyb3cgNDI7IH0sIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRpZiAoXyAhPT0gaXNDYWxsYWJsZU1hcmtlcikge1xuXHRcdFx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcblx0XHR9XG5cdH1cbn0gZWxzZSB7XG5cdHJlZmxlY3RBcHBseSA9IG51bGw7XG59XG5cbnZhciBjb25zdHJ1Y3RvclJlZ2V4ID0gL15cXHMqY2xhc3NcXGIvO1xudmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGdW5jdGlvbih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHZhciBmblN0ciA9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChmblN0cik7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIG5vdCBhIGZ1bmN0aW9uXG5cdH1cbn07XG5cbnZhciB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uVG9TdHIodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbnZhciBkZGFDbGFzcyA9ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXSc7IC8vIElFIDExXG52YXIgZGRhQ2xhc3MyID0gJ1tvYmplY3QgSFRNTCBkb2N1bWVudC5hbGwgY2xhc3NdJztcbnZhciBkZGFDbGFzczMgPSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nOyAvLyBJRSA5LTEwXG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnOyAvLyBiZXR0ZXI6IHVzZSBgaGFzLXRvc3RyaW5ndGFnYFxuXG52YXIgaXNJRTY4ID0gISgwIGluIFssXSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc3BhcnNlLWFycmF5cywgY29tbWEtc3BhY2luZ1xuXG52YXIgaXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKCkgeyByZXR1cm4gZmFsc2U7IH07XG5pZiAodHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0Jykge1xuXHQvLyBGaXJlZm94IDMgY2Fub25pY2FsaXplcyBEREEgdG8gdW5kZWZpbmVkIHdoZW4gaXQncyBub3QgYWNjZXNzZWQgZGlyZWN0bHlcblx0dmFyIGFsbCA9IGRvY3VtZW50LmFsbDtcblx0aWYgKHRvU3RyLmNhbGwoYWxsKSA9PT0gdG9TdHIuY2FsbChkb2N1bWVudC5hbGwpKSB7XG5cdFx0aXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKHZhbHVlKSB7XG5cdFx0XHQvKiBnbG9iYWxzIGRvY3VtZW50OiBmYWxzZSAqL1xuXHRcdFx0Ly8gaW4gSUUgNi04LCB0eXBlb2YgZG9jdW1lbnQuYWxsIGlzIFwib2JqZWN0XCIgYW5kIGl0J3MgdHJ1dGh5XG5cdFx0XHRpZiAoKGlzSUU2OCB8fCAhdmFsdWUpICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRzdHIgPT09IGRkYUNsYXNzXG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IGRkYUNsYXNzMlxuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczMgLy8gb3BlcmEgMTIuMTZcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gb2JqZWN0Q2xhc3MgLy8gSUUgNi04XG5cdFx0XHRcdFx0KSAmJiB2YWx1ZSgnJykgPT0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEFwcGx5XG5cdD8gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR0cnkge1xuXHRcdFx0cmVmbGVjdEFwcGx5KHZhbHVlLCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gIWlzRVM2Q2xhc3NGbih2YWx1ZSkgJiYgdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuXHR9XG5cdDogZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfVxuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBzdHJDbGFzcyA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdGlmIChzdHJDbGFzcyAhPT0gZm5DbGFzcyAmJiBzdHJDbGFzcyAhPT0gZ2VuQ2xhc3MgJiYgISgvXlxcW29iamVjdCBIVE1MLykudGVzdChzdHJDbGFzcykpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0cmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBOdW1iZXIpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKE51bWJlci5pc05hTiAmJiBOdW1iZXIuaXNOYU4oTmFOKSAmJiAhTnVtYmVyLmlzTmFOKCdhJykpIHtcblx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2dvcGQnKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHR9XG5cdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgYW55VHJ1ZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghYW55VHJ1ZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YW55VHJ1ZSA9IGdldHRlci5jYWxsKHZhbHVlKSA9PT0gdHlwZWRBcnJheTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGFueVRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0cmV0dXJuICRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTE7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IEVNQUlMX1JFR0VYUCA9IC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC87XG5jb25zdCBJTlRFR0VSX1JFR0VYUCA9IC9eLT9bMC05XVxcZCokLztcbmNvbnN0IFBBU1NXT1JEX1JFR0VYUCA9IC9eKD89LipbQS1aYS16XSkoPz0uKlxcZCkuezgsfSQvO1xuY29uc3QgU1RST05HX1BBU1NXT1JEX1JFR0VYUCA9IC9eKD89LipbYS16XSkoPz0uKltBLVpdKSg/PS4qXFxkKSg/PS4qW0AkISUqPyZdKVtBLVphLXpcXGRAJCElKj8mXXs4LH0kLztcbmNvbnN0IGlzRW1wdHkgPSAodmFsdWUpID0+IHtcbiAgbGV0IG5ld1ZhbCA9IHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbmV3VmFsID0gdmFsdWUudHJpbSgpO1xuICB9XG4gIHJldHVybiAhbmV3VmFsO1xufTtcbmNvbnN0IGlzRW1haWwgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIEVNQUlMX1JFR0VYUC50ZXN0KHZhbHVlKTtcbn07XG5jb25zdCBpc0xlbmd0aE1vcmVUaGFuTWF4ID0gKHZhbHVlLCBsZW4pID0+IHtcbiAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IGxlbjtcbn07XG5jb25zdCBpc0xlbmd0aExlc3NUaGFuTWluID0gKHZhbHVlLCBsZW4pID0+IHtcbiAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8IGxlbjtcbn07XG5jb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhaXNOYU4oK3ZhbHVlKSAmJiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbmNvbnN0IGlzSW50ZWdlciA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gSU5URUdFUl9SRUdFWFAudGVzdCh2YWx1ZSk7XG59O1xuY29uc3QgaXNQYXNzd29yZCA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gUEFTU1dPUkRfUkVHRVhQLnRlc3QodmFsdWUpO1xufTtcbmNvbnN0IGlzU3Ryb25nUGFzc3dvcmQgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIFNUUk9OR19QQVNTV09SRF9SRUdFWFAudGVzdCh2YWx1ZSk7XG59O1xuY29uc3QgaXNOdW1iZXJNb3JlVGhhbk1heCA9ICh2YWx1ZSwgbGVuKSA9PiB7XG4gIHJldHVybiB2YWx1ZSA+IGxlbjtcbn07XG5jb25zdCBpc051bWJlckxlc3NUaGFuTWluID0gKHZhbHVlLCBsZW4pID0+IHtcbiAgcmV0dXJuIHZhbHVlIDwgbGVuO1xufTtcbmNvbnN0IGlzSW52YWxpZE9yRW1wdHlTdHJpbmcgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSA9PT0gXCJcIjtcbn07XG52YXIgUnVsZXMgPSAvKiBAX19QVVJFX18gKi8gKChSdWxlczIpID0+IHtcbiAgUnVsZXMyW1wiUmVxdWlyZWRcIl0gPSBcInJlcXVpcmVkXCI7XG4gIFJ1bGVzMltcIkVtYWlsXCJdID0gXCJlbWFpbFwiO1xuICBSdWxlczJbXCJNaW5MZW5ndGhcIl0gPSBcIm1pbkxlbmd0aFwiO1xuICBSdWxlczJbXCJNYXhMZW5ndGhcIl0gPSBcIm1heExlbmd0aFwiO1xuICBSdWxlczJbXCJQYXNzd29yZFwiXSA9IFwicGFzc3dvcmRcIjtcbiAgUnVsZXMyW1wiTnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbiAgUnVsZXMyW1wiSW50ZWdlclwiXSA9IFwiaW50ZWdlclwiO1xuICBSdWxlczJbXCJNYXhOdW1iZXJcIl0gPSBcIm1heE51bWJlclwiO1xuICBSdWxlczJbXCJNaW5OdW1iZXJcIl0gPSBcIm1pbk51bWJlclwiO1xuICBSdWxlczJbXCJTdHJvbmdQYXNzd29yZFwiXSA9IFwic3Ryb25nUGFzc3dvcmRcIjtcbiAgUnVsZXMyW1wiQ3VzdG9tUmVnZXhwXCJdID0gXCJjdXN0b21SZWdleHBcIjtcbiAgUnVsZXMyW1wiTWluRmlsZXNDb3VudFwiXSA9IFwibWluRmlsZXNDb3VudFwiO1xuICBSdWxlczJbXCJNYXhGaWxlc0NvdW50XCJdID0gXCJtYXhGaWxlc0NvdW50XCI7XG4gIFJ1bGVzMltcIkZpbGVzXCJdID0gXCJmaWxlc1wiO1xuICByZXR1cm4gUnVsZXMyO1xufSkoUnVsZXMgfHwge30pO1xudmFyIEdyb3VwUnVsZXMgPSAvKiBAX19QVVJFX18gKi8gKChHcm91cFJ1bGVzMikgPT4ge1xuICBHcm91cFJ1bGVzMltcIlJlcXVpcmVkXCJdID0gXCJyZXF1aXJlZFwiO1xuICByZXR1cm4gR3JvdXBSdWxlczI7XG59KShHcm91cFJ1bGVzIHx8IHt9KTtcbnZhciBDdXN0b21TdHlsZVRhZ0lkcyA9IC8qIEBfX1BVUkVfXyAqLyAoKEN1c3RvbVN0eWxlVGFnSWRzMikgPT4ge1xuICBDdXN0b21TdHlsZVRhZ0lkczJbXCJMYWJlbFwiXSA9IFwibGFiZWxcIjtcbiAgQ3VzdG9tU3R5bGVUYWdJZHMyW1wiTGFiZWxBcnJvd1wiXSA9IFwibGFiZWxBcnJvd1wiO1xuICByZXR1cm4gQ3VzdG9tU3R5bGVUYWdJZHMyO1xufSkoQ3VzdG9tU3R5bGVUYWdJZHMgfHwge30pO1xuY29uc3QgZGVmYXVsdERpY3Rpb25hcnkgPSBbXG4gIHtcbiAgICBrZXk6IFJ1bGVzLlJlcXVpcmVkLFxuICAgIGRpY3Q6IHtcbiAgICAgIGVuOiBcIlRoZSBmaWVsZCBpcyByZXF1aXJlZFwiXG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiBSdWxlcy5FbWFpbCxcbiAgICBkaWN0OiB7XG4gICAgICBlbjogXCJFbWFpbCBoYXMgaW52YWxpZCBmb3JtYXRcIlxuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogUnVsZXMuTWF4TGVuZ3RoLFxuICAgIGRpY3Q6IHtcbiAgICAgIGVuOiBcIlRoZSBmaWVsZCBtdXN0IGNvbnRhaW4gYSBtYXhpbXVtIG9mIDp2YWx1ZSBjaGFyYWN0ZXJzXCJcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6IFJ1bGVzLk1pbkxlbmd0aCxcbiAgICBkaWN0OiB7XG4gICAgICBlbjogXCJUaGUgZmllbGQgbXVzdCBjb250YWluIGEgbWluaW11bSBvZiA6dmFsdWUgY2hhcmFjdGVyc1wiXG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiBSdWxlcy5QYXNzd29yZCxcbiAgICBkaWN0OiB7XG4gICAgICBlbjogXCJQYXNzd29yZCBtdXN0IGNvbnRhaW4gbWluaW11bSBlaWdodCBjaGFyYWN0ZXJzLCBhdCBsZWFzdCBvbmUgbGV0dGVyIGFuZCBvbmUgbnVtYmVyXCJcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6IFJ1bGVzLlN0cm9uZ1Bhc3N3b3JkLFxuICAgIGRpY3Q6IHtcbiAgICAgIGVuOiBcIlBhc3N3b3JkIHNob3VsZCBjb250YWluIG1pbmltdW0gZWlnaHQgY2hhcmFjdGVycywgYXQgbGVhc3Qgb25lIHVwcGVyY2FzZSBsZXR0ZXIsIG9uZSBsb3dlcmNhc2UgbGV0dGVyLCBvbmUgbnVtYmVyIGFuZCBvbmUgc3BlY2lhbCBjaGFyYWN0ZXJcIlxuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogUnVsZXMuTnVtYmVyLFxuICAgIGRpY3Q6IHtcbiAgICAgIGVuOiBcIlZhbHVlIHNob3VsZCBiZSBhIG51bWJlclwiXG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiBSdWxlcy5NYXhOdW1iZXIsXG4gICAgZGljdDoge1xuICAgICAgZW46IFwiTnVtYmVyIHNob3VsZCBiZSBsZXNzIG9yIGVxdWFsIHRoYW4gOnZhbHVlXCJcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6IFJ1bGVzLk1pbk51bWJlcixcbiAgICBkaWN0OiB7XG4gICAgICBlbjogXCJOdW1iZXIgc2hvdWxkIGJlIG1vcmUgb3IgZXF1YWwgdGhhbiA6dmFsdWVcIlxuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogUnVsZXMuTWluRmlsZXNDb3VudCxcbiAgICBkaWN0OiB7XG4gICAgICBlbjogXCJGaWxlcyBjb3VudCBzaG91bGQgYmUgbW9yZSBvciBlcXVhbCB0aGFuIDp2YWx1ZVwiXG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiBSdWxlcy5NYXhGaWxlc0NvdW50LFxuICAgIGRpY3Q6IHtcbiAgICAgIGVuOiBcIkZpbGVzIGNvdW50IHNob3VsZCBiZSBsZXNzIG9yIGVxdWFsIHRoYW4gOnZhbHVlXCJcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6IFJ1bGVzLkZpbGVzLFxuICAgIGRpY3Q6IHtcbiAgICAgIGVuOiBcIlVwbG9hZGVkIGZpbGVzIGhhdmUgb25lIG9yIHNldmVyYWwgaW52YWxpZCBwcm9wZXJ0aWVzIChleHRlbnNpb24vc2l6ZS90eXBlIGV0YykuXCJcbiAgICB9XG4gIH1cbl07XG5jb25zdCBERUZBVUxUX0VSUk9SX0ZJRUxEX01FU1NBR0UgPSBcIlZhbHVlIGlzIGluY29ycmVjdFwiO1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGwgJiYgXCJ0aGVuXCIgaW4gdmFsICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgZ2V0Tm9kZVBhcmVudHMgPSAoZWwpID0+IHtcbiAgbGV0IGVsZW0gPSBlbDtcbiAgY29uc3QgZWxzID0gW107XG4gIHdoaWxlIChlbGVtKSB7XG4gICAgZWxzLnVuc2hpZnQoZWxlbSk7XG4gICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZWxzO1xufTtcbmNvbnN0IGdldENsb3Nlc3RQYXJlbnQgPSAoZ3JvdXBzLCBwYXJlbnRzKSA9PiB7XG4gIGNvbnN0IHJldmVyc2VkUGFyZW50cyA9IFsuLi5wYXJlbnRzXS5yZXZlcnNlKCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSByZXZlcnNlZFBhcmVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb25zdCBwYXJlbnQgPSByZXZlcnNlZFBhcmVudHNbaV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZ3JvdXBzKSB7XG4gICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1trZXldO1xuICAgICAgaWYgKGdyb3VwLmdyb3VwRWxlbSA9PT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiBba2V5LCBncm91cF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldENsYXNzTGlzdCA9IChjbGFzc0xpc3QpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NMaXN0KSkge1xuICAgIHJldHVybiBjbGFzc0xpc3QuZmlsdGVyKChjbHMpID0+IGNscy5sZW5ndGggPiAwKTtcbiAgfVxuICBpZiAodHlwZW9mIGNsYXNzTGlzdCA9PT0gXCJzdHJpbmdcIiAmJiBjbGFzc0xpc3QudHJpbSgpKSB7XG4gICAgcmV0dXJuIFsuLi5jbGFzc0xpc3Quc3BsaXQoXCIgXCIpLmZpbHRlcigoY2xzKSA9PiBjbHMubGVuZ3RoID4gMCldO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5jb25zdCBpc0VsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudDtcbn07XG5jb25zdCBlcnJvckxhYmVsQ3NzID0gYC5qdXN0LXZhbGlkYXRlLWVycm9yLWxhYmVsW2RhdGEtdG9vbHRpcD10cnVlXXtwb3NpdGlvbjpmaXhlZDtwYWRkaW5nOjRweCA4cHg7YmFja2dyb3VuZDojNDIzZjNmO2NvbG9yOiNmZmY7d2hpdGUtc3BhY2U6bm93cmFwO3otaW5kZXg6MTA7Ym9yZGVyLXJhZGl1czo0cHg7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTVweCl9Lmp1c3QtdmFsaWRhdGUtZXJyb3ItbGFiZWxbZGF0YS10b29sdGlwPXRydWVdOmJlZm9yZXtjb250ZW50OicnO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyLWxlZnQ6c29saWQgNXB4IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDpzb2xpZCA1cHggdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTpzb2xpZCA1cHggIzQyM2YzZjtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjM7ZGlzcGxheTpibG9jaztib3R0b206LTVweDt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZyk7bGVmdDpjYWxjKDUwJSAtIDVweCl9Lmp1c3QtdmFsaWRhdGUtZXJyb3ItbGFiZWxbZGF0YS10b29sdGlwPXRydWVdW2RhdGEtZGlyZWN0aW9uPWxlZnRde3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01cHgpfS5qdXN0LXZhbGlkYXRlLWVycm9yLWxhYmVsW2RhdGEtdG9vbHRpcD10cnVlXVtkYXRhLWRpcmVjdGlvbj1sZWZ0XTpiZWZvcmV7cmlnaHQ6LTdweDtib3R0b206YXV0bztsZWZ0OmF1dG87dG9wOmNhbGMoNTAlIC0gMnB4KTt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX0uanVzdC12YWxpZGF0ZS1lcnJvci1sYWJlbFtkYXRhLXRvb2x0aXA9dHJ1ZV1bZGF0YS1kaXJlY3Rpb249cmlnaHRde3RyYW5zZm9ybTp0cmFuc2xhdGVYKDVweCl9Lmp1c3QtdmFsaWRhdGUtZXJyb3ItbGFiZWxbZGF0YS10b29sdGlwPXRydWVdW2RhdGEtZGlyZWN0aW9uPXJpZ2h0XTpiZWZvcmV7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0Oi03cHg7dG9wOmNhbGMoNTAlIC0gMnB4KTt0cmFuc2Zvcm06cm90YXRlKC05MGRlZyl9Lmp1c3QtdmFsaWRhdGUtZXJyb3ItbGFiZWxbZGF0YS10b29sdGlwPXRydWVdW2RhdGEtZGlyZWN0aW9uPWJvdHRvbV17dHJhbnNmb3JtOnRyYW5zbGF0ZVkoNXB4KX0uanVzdC12YWxpZGF0ZS1lcnJvci1sYWJlbFtkYXRhLXRvb2x0aXA9dHJ1ZV1bZGF0YS1kaXJlY3Rpb249Ym90dG9tXTpiZWZvcmV7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OmNhbGMoNTAlIC0gNXB4KTt0b3A6LTVweDt0cmFuc2Zvcm06cm90YXRlKDApfWA7XG5jb25zdCBUT09MVElQX0FSUk9XX0hFSUdIVCA9IDU7XG5jb25zdCBkZWZhdWx0R2xvYmFsQ29uZmlnID0ge1xuICBlcnJvckZpZWxkU3R5bGU6IHtcbiAgICBjb2xvcjogXCIjYjgxMTExXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjQjgxMTExXCJcbiAgfSxcbiAgZXJyb3JGaWVsZENzc0NsYXNzOiBcImp1c3QtdmFsaWRhdGUtZXJyb3ItZmllbGRcIixcbiAgc3VjY2Vzc0ZpZWxkQ3NzQ2xhc3M6IFwianVzdC12YWxpZGF0ZS1zdWNjZXNzLWZpZWxkXCIsXG4gIGVycm9yTGFiZWxTdHlsZToge1xuICAgIGNvbG9yOiBcIiNiODExMTFcIlxuICB9LFxuICBlcnJvckxhYmVsQ3NzQ2xhc3M6IFwianVzdC12YWxpZGF0ZS1lcnJvci1sYWJlbFwiLFxuICBzdWNjZXNzTGFiZWxDc3NDbGFzczogXCJqdXN0LXZhbGlkYXRlLXN1Y2Nlc3MtbGFiZWxcIixcbiAgZm9jdXNJbnZhbGlkRmllbGQ6IHRydWUsXG4gIGxvY2tGb3JtOiB0cnVlLFxuICB0ZXN0aW5nTW9kZTogZmFsc2UsXG4gIHZhbGlkYXRlQmVmb3JlU3VibWl0dGluZzogZmFsc2Vcbn07XG5jbGFzcyBKdXN0VmFsaWRhdGUge1xuICBjb25zdHJ1Y3Rvcihmb3JtLCBnbG9iYWxDb25maWcsIGRpY3RMb2NhbGUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZm9ybVwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmllbGRzXCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ3JvdXBGaWVsZHNcIiwge30pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlcnJvcnNcIiwge30pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc1ZhbGlkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNTdWJtaXR0ZWRcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnbG9iYWxDb25maWdcIiwgZGVmYXVsdEdsb2JhbENvbmZpZyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVycm9yTGFiZWxzXCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3VjY2Vzc0xhYmVsc1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImV2ZW50TGlzdGVuZXJzXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGljdExvY2FsZVwiLCBkZWZhdWx0RGljdGlvbmFyeSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImN1cnJlbnRMb2NhbGVcIiwgXCJlblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY3VzdG9tU3R5bGVUYWdzXCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib25TdWNjZXNzQ2FsbGJhY2tcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9uRmFpbENhbGxiYWNrXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvblZhbGlkYXRlQ2FsbGJhY2tcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRvb2x0aXBzXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGFzdFNjcm9sbFBvc2l0aW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc1Njcm9sbFRpY2tcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpZWxkSWRzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRLZXlCeUZpZWxkU2VsZWN0b3JcIiwgKGZpZWxkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5maWVsZElkcy5nZXQoZmllbGQpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRGaWVsZFNlbGVjdG9yQnlLZXlcIiwgKGtleSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbZmllbGRTZWxlY3Rvciwga10gb2YgdGhpcy5maWVsZElkcykge1xuICAgICAgICBpZiAoa2V5ID09PSBrKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldENvbXBhdGlibGVGaWVsZHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZmllbGRzID0ge307XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCBuZXdLZXkgPSBrZXk7XG4gICAgICAgIGNvbnN0IGZpZWxkU2VsZWN0b3IgPSB0aGlzLmdldEZpZWxkU2VsZWN0b3JCeUtleShrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkU2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBuZXdLZXkgPSBmaWVsZFNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkc1tuZXdLZXldID0geyAuLi50aGlzLmZpZWxkc1trZXldIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldEtleUJ5RmllbGRTZWxlY3RvclwiLCAoZmllbGQpID0+IHtcbiAgICAgIGlmICh0aGlzLmZpZWxkSWRzLmhhcyhmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRJZHMuZ2V0KGZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IFN0cmluZyh0aGlzLmZpZWxkSWRzLnNpemUgKyAxKTtcbiAgICAgIHRoaXMuZmllbGRJZHMuc2V0KGZpZWxkLCBrZXkpO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVmcmVzaEFsbFRvb2x0aXBzXCIsICgpID0+IHtcbiAgICAgIHRoaXMudG9vbHRpcHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBpdGVtLnJlZnJlc2goKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVEb2N1bWVudFNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmxhc3RTY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgaWYgKCF0aGlzLmlzU2Nyb2xsVGljaykge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlZnJlc2hBbGxUb29sdGlwcygpO1xuICAgICAgICAgIHRoaXMuaXNTY3JvbGxUaWNrID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlzU2Nyb2xsVGljayA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZvcm1TdWJtaXRIYW5kbGVyXCIsIChldikgPT4ge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuaXNTdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy52YWxpZGF0ZUhhbmRsZXIoZXYpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVGaWVsZENoYW5nZVwiLCAodGFyZ2V0KSA9PiB7XG4gICAgICBsZXQgZm91bmRLZXk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmZpZWxkcykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgICAgIGlmIChmaWVsZC5lbGVtID09PSB0YXJnZXQpIHtcbiAgICAgICAgICBmb3VuZEtleSA9IGtleTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmb3VuZEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZpZWxkc1tmb3VuZEtleV0udG91Y2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnZhbGlkYXRlRmllbGQoZm91bmRLZXksIHRydWUpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVHcm91cENoYW5nZVwiLCAodGFyZ2V0KSA9PiB7XG4gICAgICBsZXQgZm91bmRLZXk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmdyb3VwRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5ncm91cEZpZWxkc1trZXldO1xuICAgICAgICBpZiAoZ3JvdXAuZWxlbXMuZmluZCgoZWxlbSkgPT4gZWxlbSA9PT0gdGFyZ2V0KSkge1xuICAgICAgICAgIGZvdW5kS2V5ID0ga2V5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ3JvdXBGaWVsZHNbZm91bmRLZXldLnRvdWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy52YWxpZGF0ZUdyb3VwKGZvdW5kS2V5LCB0cnVlKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlckNoYW5nZVwiLCAoZXYpID0+IHtcbiAgICAgIGlmICghZXYudGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlRmllbGRDaGFuZ2UoZXYudGFyZ2V0KTtcbiAgICAgIHRoaXMuaGFuZGxlR3JvdXBDaGFuZ2UoZXYudGFyZ2V0KTtcbiAgICAgIHRoaXMucmVuZGVyRXJyb3JzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5pbml0aWFsaXplKGZvcm0sIGdsb2JhbENvbmZpZywgZGljdExvY2FsZSk7XG4gIH1cbiAgaW5pdGlhbGl6ZShmb3JtLCBnbG9iYWxDb25maWcsIGRpY3RMb2NhbGUpIHtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuZXJyb3JzID0ge307XG4gICAgdGhpcy5pc1ZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5pc1N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZ2xvYmFsQ29uZmlnID0gZGVmYXVsdEdsb2JhbENvbmZpZztcbiAgICB0aGlzLmVycm9yTGFiZWxzID0ge307XG4gICAgdGhpcy5zdWNjZXNzTGFiZWxzID0ge307XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuY3VzdG9tU3R5bGVUYWdzID0ge307XG4gICAgdGhpcy50b29sdGlwcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudExvY2FsZSA9IFwiZW5cIjtcbiAgICBpZiAodHlwZW9mIGZvcm0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGZvcm0pO1xuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIGBGb3JtIHdpdGggJHtmb3JtfSBzZWxlY3RvciBub3QgZm91bmQhIFBsZWFzZSBjaGVjayB0aGUgZm9ybSBzZWxlY3RvcmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Rm9ybShlbGVtKTtcbiAgICB9IGVsc2UgaWYgKGZvcm0gaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc2V0Rm9ybShmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBGb3JtIHNlbGVjdG9yIGlzIG5vdCB2YWxpZC4gUGxlYXNlIHNwZWNpZnkgYSBzdHJpbmcgc2VsZWN0b3Igb3IgYSBET00gZWxlbWVudC5gXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmdsb2JhbENvbmZpZyA9IHsgLi4uZGVmYXVsdEdsb2JhbENvbmZpZywgLi4uZ2xvYmFsQ29uZmlnIH07XG4gICAgaWYgKGRpY3RMb2NhbGUpIHtcbiAgICAgIHRoaXMuZGljdExvY2FsZSA9IFsuLi5kaWN0TG9jYWxlLCAuLi5kZWZhdWx0RGljdGlvbmFyeV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVG9vbHRpcCgpKSB7XG4gICAgICBjb25zdCBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHN0eWxlVGFnLnRleHRDb250ZW50ID0gZXJyb3JMYWJlbENzcztcbiAgICAgIHRoaXMuY3VzdG9tU3R5bGVUYWdzW0N1c3RvbVN0eWxlVGFnSWRzLkxhYmVsXSA9IGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcihcInNjcm9sbFwiLCBkb2N1bWVudCwgdGhpcy5oYW5kbGVEb2N1bWVudFNjcm9sbCk7XG4gICAgfVxuICB9XG4gIGdldExvY2FsaXNlZFN0cmluZyhydWxlLCBydWxlVmFsdWUsIGN1c3RvbU1zZykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzZWFyY2ggPSBjdXN0b21Nc2cgIT0gbnVsbCA/IGN1c3RvbU1zZyA6IHJ1bGU7XG4gICAgbGV0IGxvY2FsaXNlZFN0ciA9IChfYSA9IHRoaXMuZGljdExvY2FsZS5maW5kKChpdGVtKSA9PiBpdGVtLmtleSA9PT0gc2VhcmNoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpY3RbdGhpcy5jdXJyZW50TG9jYWxlXTtcbiAgICBpZiAoIWxvY2FsaXNlZFN0cikge1xuICAgICAgaWYgKGN1c3RvbU1zZykge1xuICAgICAgICBsb2NhbGlzZWRTdHIgPSBjdXN0b21Nc2c7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsb2NhbGlzZWRTdHIgJiYgcnVsZVZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHN3aXRjaCAocnVsZSkge1xuICAgICAgICBjYXNlIFJ1bGVzLk1heExlbmd0aDpcbiAgICAgICAgY2FzZSBSdWxlcy5NaW5MZW5ndGg6XG4gICAgICAgIGNhc2UgUnVsZXMuTWF4TnVtYmVyOlxuICAgICAgICBjYXNlIFJ1bGVzLk1pbk51bWJlcjpcbiAgICAgICAgY2FzZSBSdWxlcy5NaW5GaWxlc0NvdW50OlxuICAgICAgICBjYXNlIFJ1bGVzLk1heEZpbGVzQ291bnQ6XG4gICAgICAgICAgbG9jYWxpc2VkU3RyID0gbG9jYWxpc2VkU3RyLnJlcGxhY2UoXCI6dmFsdWVcIiwgU3RyaW5nKHJ1bGVWYWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxpc2VkU3RyIHx8IGN1c3RvbU1zZyB8fCBERUZBVUxUX0VSUk9SX0ZJRUxEX01FU1NBR0U7XG4gIH1cbiAgZ2V0RmllbGRFcnJvck1lc3NhZ2UoZmllbGRSdWxlLCBlbGVtKSB7XG4gICAgY29uc3QgbXNnID0gdHlwZW9mIGZpZWxkUnVsZS5lcnJvck1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IGZpZWxkUnVsZS5lcnJvck1lc3NhZ2UodGhpcy5nZXRFbGVtVmFsdWUoZWxlbSksIHRoaXMuZmllbGRzKSA6IGZpZWxkUnVsZS5lcnJvck1lc3NhZ2U7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TG9jYWxpc2VkU3RyaW5nKGZpZWxkUnVsZS5ydWxlLCBmaWVsZFJ1bGUudmFsdWUsIG1zZyk7XG4gIH1cbiAgZ2V0RmllbGRTdWNjZXNzTWVzc2FnZShzdWNjZXNzTWVzc2FnZSwgZWxlbSkge1xuICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBzdWNjZXNzTWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiID8gc3VjY2Vzc01lc3NhZ2UodGhpcy5nZXRFbGVtVmFsdWUoZWxlbSksIHRoaXMuZmllbGRzKSA6IHN1Y2Nlc3NNZXNzYWdlO1xuICAgIHJldHVybiB0aGlzLmdldExvY2FsaXNlZFN0cmluZyh2b2lkIDAsIHZvaWQgMCwgbXNnKTtcbiAgfVxuICBnZXRHcm91cEVycm9yTWVzc2FnZShncm91cFJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMb2NhbGlzZWRTdHJpbmcoXG4gICAgICBncm91cFJ1bGUucnVsZSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIGdyb3VwUnVsZS5lcnJvck1lc3NhZ2VcbiAgICApO1xuICB9XG4gIGdldEdyb3VwU3VjY2Vzc01lc3NhZ2UoZ3JvdXBSdWxlKSB7XG4gICAgaWYgKCFncm91cFJ1bGUuc3VjY2Vzc01lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldExvY2FsaXNlZFN0cmluZyhcbiAgICAgIHZvaWQgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIGdyb3VwUnVsZS5zdWNjZXNzTWVzc2FnZVxuICAgICk7XG4gIH1cbiAgc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKSB7XG4gICAgdGhpcy5maWVsZHNba2V5XS5pc1ZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5maWVsZHNba2V5XS5lcnJvck1lc3NhZ2UgPSB0aGlzLmdldEZpZWxkRXJyb3JNZXNzYWdlKFxuICAgICAgZmllbGRSdWxlLFxuICAgICAgdGhpcy5maWVsZHNba2V5XS5lbGVtXG4gICAgKTtcbiAgfVxuICBzZXRGaWVsZFZhbGlkKGtleSwgc3VjY2Vzc01lc3NhZ2UpIHtcbiAgICB0aGlzLmZpZWxkc1trZXldLmlzVmFsaWQgPSB0cnVlO1xuICAgIGlmIChzdWNjZXNzTWVzc2FnZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmZpZWxkc1trZXldLnN1Y2Nlc3NNZXNzYWdlID0gdGhpcy5nZXRGaWVsZFN1Y2Nlc3NNZXNzYWdlKFxuICAgICAgICBzdWNjZXNzTWVzc2FnZSxcbiAgICAgICAgdGhpcy5maWVsZHNba2V5XS5lbGVtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBzZXRHcm91cEludmFsaWQoa2V5LCBncm91cFJ1bGUpIHtcbiAgICB0aGlzLmdyb3VwRmllbGRzW2tleV0uaXNWYWxpZCA9IGZhbHNlO1xuICAgIHRoaXMuZ3JvdXBGaWVsZHNba2V5XS5lcnJvck1lc3NhZ2UgPSB0aGlzLmdldEdyb3VwRXJyb3JNZXNzYWdlKGdyb3VwUnVsZSk7XG4gIH1cbiAgc2V0R3JvdXBWYWxpZChrZXksIGdyb3VwUnVsZSkge1xuICAgIHRoaXMuZ3JvdXBGaWVsZHNba2V5XS5pc1ZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLmdyb3VwRmllbGRzW2tleV0uc3VjY2Vzc01lc3NhZ2UgPSB0aGlzLmdldEdyb3VwU3VjY2Vzc01lc3NhZ2UoZ3JvdXBSdWxlKTtcbiAgfVxuICBnZXRFbGVtVmFsdWUoZWxlbSkge1xuICAgIHN3aXRjaCAoZWxlbS50eXBlKSB7XG4gICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgcmV0dXJuIGVsZW0uY2hlY2tlZDtcbiAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgIHJldHVybiBlbGVtLmZpbGVzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGVsZW0udmFsdWU7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlR3JvdXBSdWxlKGtleSwgZWxlbXMsIGdyb3VwUnVsZSkge1xuICAgIHN3aXRjaCAoZ3JvdXBSdWxlLnJ1bGUpIHtcbiAgICAgIGNhc2UgR3JvdXBSdWxlcy5SZXF1aXJlZDoge1xuICAgICAgICBpZiAoZWxlbXMuZXZlcnkoKGVsZW0pID0+ICFlbGVtLmNoZWNrZWQpKSB7XG4gICAgICAgICAgdGhpcy5zZXRHcm91cEludmFsaWQoa2V5LCBncm91cFJ1bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0R3JvdXBWYWxpZChrZXksIGdyb3VwUnVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFsaWRhdGVGaWVsZFJ1bGUoa2V5LCBlbGVtLCBmaWVsZFJ1bGUsIGFmdGVySW5wdXRDaGFuZ2VkID0gZmFsc2UpIHtcbiAgICBjb25zdCBydWxlVmFsdWUgPSBmaWVsZFJ1bGUudmFsdWU7XG4gICAgY29uc3QgZWxlbVZhbHVlID0gdGhpcy5nZXRFbGVtVmFsdWUoZWxlbSk7XG4gICAgaWYgKGZpZWxkUnVsZS5wbHVnaW4pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZpZWxkUnVsZS5wbHVnaW4oXG4gICAgICAgIGVsZW1WYWx1ZSxcbiAgICAgICAgdGhpcy5nZXRDb21wYXRpYmxlRmllbGRzKClcbiAgICAgICk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZmllbGRSdWxlLnJ1bGUpIHtcbiAgICAgIGNhc2UgUnVsZXMuUmVxdWlyZWQ6IHtcbiAgICAgICAgaWYgKGlzRW1wdHkoZWxlbVZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgUnVsZXMuRW1haWw6IHtcbiAgICAgICAgaWYgKGlzSW52YWxpZE9yRW1wdHlTdHJpbmcoZWxlbVZhbHVlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbWFpbChlbGVtVmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBSdWxlcy5NYXhMZW5ndGg6IHtcbiAgICAgICAgaWYgKHJ1bGVWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBWYWx1ZSBmb3IgJHtmaWVsZFJ1bGUucnVsZX0gcnVsZSBmb3IgWyR7a2V5fV0gZmllbGQgaXMgbm90IGRlZmluZWQuIFRoZSBmaWVsZCB3aWxsIGJlIGFsd2F5cyBpbnZhbGlkLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJ1bGVWYWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yICR7ZmllbGRSdWxlLnJ1bGV9IHJ1bGUgZm9yIFske2tleX1dIHNob3VsZCBiZSBhIG51bWJlci4gVGhlIGZpZWxkIHdpbGwgYmUgYWx3YXlzIGludmFsaWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ludmFsaWRPckVtcHR5U3RyaW5nKGVsZW1WYWx1ZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMZW5ndGhNb3JlVGhhbk1heChlbGVtVmFsdWUsIHJ1bGVWYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFJ1bGVzLk1pbkxlbmd0aDoge1xuICAgICAgICBpZiAocnVsZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFZhbHVlIGZvciAke2ZpZWxkUnVsZS5ydWxlfSBydWxlIGZvciBbJHtrZXl9XSBmaWVsZCBpcyBub3QgZGVmaW5lZC4gVGhlIGZpZWxkIHdpbGwgYmUgYWx3YXlzIGludmFsaWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZVZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBWYWx1ZSBmb3IgJHtmaWVsZFJ1bGUucnVsZX0gcnVsZSBmb3IgWyR7a2V5fV0gc2hvdWxkIGJlIGEgbnVtYmVyLiBUaGUgZmllbGQgd2lsbCBiZSBhbHdheXMgaW52YWxpZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW52YWxpZE9yRW1wdHlTdHJpbmcoZWxlbVZhbHVlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xlbmd0aExlc3NUaGFuTWluKGVsZW1WYWx1ZSwgcnVsZVZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgUnVsZXMuUGFzc3dvcmQ6IHtcbiAgICAgICAgaWYgKGlzSW52YWxpZE9yRW1wdHlTdHJpbmcoZWxlbVZhbHVlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQYXNzd29yZChlbGVtVmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBSdWxlcy5TdHJvbmdQYXNzd29yZDoge1xuICAgICAgICBpZiAoaXNJbnZhbGlkT3JFbXB0eVN0cmluZyhlbGVtVmFsdWUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cm9uZ1Bhc3N3b3JkKGVsZW1WYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFJ1bGVzLk51bWJlcjoge1xuICAgICAgICBpZiAoaXNJbnZhbGlkT3JFbXB0eVN0cmluZyhlbGVtVmFsdWUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc051bWJlcihlbGVtVmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBSdWxlcy5JbnRlZ2VyOiB7XG4gICAgICAgIGlmIChpc0ludmFsaWRPckVtcHR5U3RyaW5nKGVsZW1WYWx1ZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSW50ZWdlcihlbGVtVmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBSdWxlcy5NYXhOdW1iZXI6IHtcbiAgICAgICAgaWYgKHJ1bGVWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBWYWx1ZSBmb3IgJHtmaWVsZFJ1bGUucnVsZX0gcnVsZSBmb3IgWyR7a2V5fV0gZmllbGQgaXMgbm90IGRlZmluZWQuIFRoZSBmaWVsZCB3aWxsIGJlIGFsd2F5cyBpbnZhbGlkLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJ1bGVWYWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yICR7ZmllbGRSdWxlLnJ1bGV9IHJ1bGUgZm9yIFske2tleX1dIGZpZWxkIHNob3VsZCBiZSBhIG51bWJlci4gVGhlIGZpZWxkIHdpbGwgYmUgYWx3YXlzIGludmFsaWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ludmFsaWRPckVtcHR5U3RyaW5nKGVsZW1WYWx1ZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSArZWxlbVZhbHVlO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG51bSkgfHwgaXNOdW1iZXJNb3JlVGhhbk1heChudW0sIHJ1bGVWYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFJ1bGVzLk1pbk51bWJlcjoge1xuICAgICAgICBpZiAocnVsZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFZhbHVlIGZvciAke2ZpZWxkUnVsZS5ydWxlfSBydWxlIGZvciBbJHtrZXl9XSBmaWVsZCBpcyBub3QgZGVmaW5lZC4gVGhlIGZpZWxkIHdpbGwgYmUgYWx3YXlzIGludmFsaWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZVZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBWYWx1ZSBmb3IgJHtmaWVsZFJ1bGUucnVsZX0gcnVsZSBmb3IgWyR7a2V5fV0gZmllbGQgc2hvdWxkIGJlIGEgbnVtYmVyLiBUaGUgZmllbGQgd2lsbCBiZSBhbHdheXMgaW52YWxpZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW52YWxpZE9yRW1wdHlTdHJpbmcoZWxlbVZhbHVlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bSA9ICtlbGVtVmFsdWU7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4obnVtKSB8fCBpc051bWJlckxlc3NUaGFuTWluKG51bSwgcnVsZVZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgUnVsZXMuQ3VzdG9tUmVnZXhwOiB7XG4gICAgICAgIGlmIChydWxlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yICR7ZmllbGRSdWxlLnJ1bGV9IHJ1bGUgZm9yIFske2tleX1dIGZpZWxkIGlzIG5vdCBkZWZpbmVkLiBUaGlzIGZpZWxkIHdpbGwgYmUgYWx3YXlzIGludmFsaWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVnZXhwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAocnVsZVZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yICR7ZmllbGRSdWxlLnJ1bGV9IHJ1bGUgZm9yIFske2tleX1dIHNob3VsZCBiZSBhIHZhbGlkIHJlZ2V4cC4gVGhpcyBmaWVsZCB3aWxsIGJlIGFsd2F5cyBpbnZhbGlkLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHIgPSBTdHJpbmcoZWxlbVZhbHVlKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gXCJcIiAmJiAhcmVnZXhwLnRlc3Qoc3RyKSkge1xuICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgUnVsZXMuTWluRmlsZXNDb3VudDoge1xuICAgICAgICBpZiAocnVsZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFZhbHVlIGZvciAke2ZpZWxkUnVsZS5ydWxlfSBydWxlIGZvciBbJHtrZXl9XSBmaWVsZCBpcyBub3QgZGVmaW5lZC4gVGhpcyBmaWVsZCB3aWxsIGJlIGFsd2F5cyBpbnZhbGlkLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJ1bGVWYWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yICR7ZmllbGRSdWxlLnJ1bGV9IHJ1bGUgZm9yIFske2tleX1dIGZpZWxkIHNob3VsZCBiZSBhIG51bWJlci4gVGhlIGZpZWxkIHdpbGwgYmUgYWx3YXlzIGludmFsaWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZWxlbVZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBlbGVtVmFsdWUubGVuZ3RoKSAmJiBlbGVtVmFsdWUubGVuZ3RoIDwgcnVsZVZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBSdWxlcy5NYXhGaWxlc0NvdW50OiB7XG4gICAgICAgIGlmIChydWxlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yICR7ZmllbGRSdWxlLnJ1bGV9IHJ1bGUgZm9yIFske2tleX1dIGZpZWxkIGlzIG5vdCBkZWZpbmVkLiBUaGlzIGZpZWxkIHdpbGwgYmUgYWx3YXlzIGludmFsaWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZVZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBWYWx1ZSBmb3IgJHtmaWVsZFJ1bGUucnVsZX0gcnVsZSBmb3IgWyR7a2V5fV0gZmllbGQgc2hvdWxkIGJlIGEgbnVtYmVyLiBUaGUgZmllbGQgd2lsbCBiZSBhbHdheXMgaW52YWxpZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShlbGVtVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1WYWx1ZS5sZW5ndGgpICYmIGVsZW1WYWx1ZS5sZW5ndGggPiBydWxlVmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFJ1bGVzLkZpbGVzOiB7XG4gICAgICAgIGlmIChydWxlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yICR7ZmllbGRSdWxlLnJ1bGV9IHJ1bGUgZm9yIFske2tleX1dIGZpZWxkIGlzIG5vdCBkZWZpbmVkLiBUaGlzIGZpZWxkIHdpbGwgYmUgYWx3YXlzIGludmFsaWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJ1bGVWYWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yICR7ZmllbGRSdWxlLnJ1bGV9IHJ1bGUgZm9yIFske2tleX1dIGZpZWxkIHNob3VsZCBiZSBhbiBvYmplY3QuIFRoaXMgZmllbGQgd2lsbCBiZSBhbHdheXMgaW52YWxpZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGVzQ29uZmlnID0gcnVsZVZhbHVlLmZpbGVzO1xuICAgICAgICBpZiAodHlwZW9mIGZpbGVzQ29uZmlnICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBWYWx1ZSBmb3IgJHtmaWVsZFJ1bGUucnVsZX0gcnVsZSBmb3IgWyR7a2V5fV0gZmllbGQgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGZpbGVzIGFycmF5LiBUaGlzIGZpZWxkIHdpbGwgYmUgYWx3YXlzIGludmFsaWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0ZpbGVQcm9wc0ludmFsaWQgPSAoZmlsZSwgZmlsZUNvbmZpZykgPT4ge1xuICAgICAgICAgIGNvbnN0IG1pblNpemVJbnZhbGlkID0gTnVtYmVyLmlzRmluaXRlKGZpbGVDb25maWcubWluU2l6ZSkgJiYgZmlsZS5zaXplIDwgZmlsZUNvbmZpZy5taW5TaXplO1xuICAgICAgICAgIGNvbnN0IG1heFNpemVJbnZhbGlkID0gTnVtYmVyLmlzRmluaXRlKGZpbGVDb25maWcubWF4U2l6ZSkgJiYgZmlsZS5zaXplID4gZmlsZUNvbmZpZy5tYXhTaXplO1xuICAgICAgICAgIGNvbnN0IG5hbWVJbnZhbGlkID0gQXJyYXkuaXNBcnJheShmaWxlQ29uZmlnLm5hbWVzKSAmJiAhZmlsZUNvbmZpZy5uYW1lcy5pbmNsdWRlcyhmaWxlLm5hbWUpO1xuICAgICAgICAgIGNvbnN0IGV4dEludmFsaWQgPSBBcnJheS5pc0FycmF5KGZpbGVDb25maWcuZXh0ZW5zaW9ucykgJiYgIWZpbGVDb25maWcuZXh0ZW5zaW9ucy5pbmNsdWRlcyhcbiAgICAgICAgICAgIGZpbGUubmFtZS5zcGxpdChcIi5cIilbZmlsZS5uYW1lLnNwbGl0KFwiLlwiKS5sZW5ndGggLSAxXVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgdHlwZUludmFsaWQgPSBBcnJheS5pc0FycmF5KGZpbGVDb25maWcudHlwZXMpICYmICFmaWxlQ29uZmlnLnR5cGVzLmluY2x1ZGVzKGZpbGUudHlwZSk7XG4gICAgICAgICAgcmV0dXJuIG1pblNpemVJbnZhbGlkIHx8IG1heFNpemVJbnZhbGlkIHx8IG5hbWVJbnZhbGlkIHx8IGV4dEludmFsaWQgfHwgdHlwZUludmFsaWQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbVZhbHVlID09PSBcIm9iamVjdFwiICYmIGVsZW1WYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZvciAobGV0IGZpbGVJZHggPSAwLCBsZW4gPSBlbGVtVmFsdWUubGVuZ3RoOyBmaWxlSWR4IDwgbGVuOyArK2ZpbGVJZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBlbGVtVmFsdWUuaXRlbShmaWxlSWR4KTtcbiAgICAgICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsZXNJbnZhbGlkID0gaXNGaWxlUHJvcHNJbnZhbGlkKGZpbGUsIGZpbGVzQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChmaWxlc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRSdWxlLnZhbGlkYXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBWYWxpZGF0b3IgZm9yIGN1c3RvbSBydWxlIGZvciBbJHtrZXl9XSBmaWVsZCBzaG91bGQgYmUgYSBmdW5jdGlvbi4gVGhpcyBmaWVsZCB3aWxsIGJlIGFsd2F5cyBpbnZhbGlkLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmllbGRSdWxlLnZhbGlkYXRvcihcbiAgICAgICAgICBlbGVtVmFsdWUsXG4gICAgICAgICAgdGhpcy5nZXRDb21wYXRpYmxlRmllbGRzKClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09IFwiYm9vbGVhblwiICYmIHR5cGVvZiByZXN1bHQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgVmFsaWRhdG9yIHJldHVybiB2YWx1ZSBmb3IgWyR7a2V5fV0gZmllbGQgc2hvdWxkIGJlIGJvb2xlYW4gb3IgZnVuY3Rpb24uIEl0IHdpbGwgYmUgY2FzdCB0byBib29sZWFuLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAoYWZ0ZXJJbnB1dENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGRzW2tleV0uYXN5bmNDaGVja1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkc1trZXldLmFzeW5jQ2hlY2tQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gcmVzdWx0KCk7XG4gICAgICAgICAgICBpZiAoIWlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGBWYWxpZGF0b3IgZnVuY3Rpb24gZm9yIGN1c3RvbSBydWxlIGZvciBbJHtrZXl9XSBmaWVsZCBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZS4gVGhpcyBmaWVsZCB3aWxsIGJlIGFsd2F5cyBpbnZhbGlkLmBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRGaWVsZEludmFsaWQoa2V5LCBmaWVsZFJ1bGUpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghcmVzcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmllbGRJbnZhbGlkKGtleSwgZmllbGRSdWxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICB0aGlzLnNldEZpZWxkSW52YWxpZChrZXksIGZpZWxkUnVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNGb3JtVmFsaWQoKSB7XG4gICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBPYmplY3QudmFsdWVzKHRoaXMuZmllbGRzKS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IE9iamVjdC52YWx1ZXModGhpcy5maWVsZHMpW2ldO1xuICAgICAgaWYgKGl0ZW0uaXNWYWxpZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzVmFsaWQgPSB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uaXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE9iamVjdC52YWx1ZXModGhpcy5ncm91cEZpZWxkcykubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBPYmplY3QudmFsdWVzKHRoaXMuZ3JvdXBGaWVsZHMpW2ldO1xuICAgICAgaWYgKGl0ZW0uaXNWYWxpZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzVmFsaWQgPSB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uaXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG4gIH1cbiAgdmFsaWRhdGVGaWVsZChrZXksIGFmdGVySW5wdXRDaGFuZ2VkID0gZmFsc2UpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkc1trZXldO1xuICAgIGZpZWxkLmlzVmFsaWQgPSB0cnVlO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgWy4uLmZpZWxkLnJ1bGVzXS5yZXZlcnNlKCkuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gdGhpcy52YWxpZGF0ZUZpZWxkUnVsZShcbiAgICAgICAga2V5LFxuICAgICAgICBmaWVsZC5lbGVtLFxuICAgICAgICBydWxlLFxuICAgICAgICBhZnRlcklucHV0Q2hhbmdlZFxuICAgICAgKTtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKHJlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGZpZWxkLmlzVmFsaWQpIHtcbiAgICAgIHRoaXMuc2V0RmllbGRWYWxpZChrZXksIChfYSA9IGZpZWxkLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN1Y2Nlc3NNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcykuZmluYWxseSgoKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKGFmdGVySW5wdXRDaGFuZ2VkKSB7XG4gICAgICAgIChfYTIgPSB0aGlzLm9uVmFsaWRhdGVDYWxsYmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKHRoaXMsIHtcbiAgICAgICAgICBpc1ZhbGlkOiB0aGlzLmlzRm9ybVZhbGlkKCksXG4gICAgICAgICAgaXNTdWJtaXR0ZWQ6IHRoaXMuaXNTdWJtaXR0ZWQsXG4gICAgICAgICAgZmllbGRzOiB0aGlzLmdldENvbXBhdGlibGVGaWVsZHMoKSxcbiAgICAgICAgICBncm91cHM6IHsgLi4udGhpcy5ncm91cEZpZWxkcyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldmFsaWRhdGVGaWVsZChmaWVsZFNlbGVjdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZFNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmICFpc0VsZW1lbnQoZmllbGRTZWxlY3RvcikpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgRmllbGQgc2VsZWN0b3IgaXMgbm90IHZhbGlkLiBQbGVhc2Ugc3BlY2lmeSBhIHN0cmluZyBzZWxlY3RvciBvciBhIHZhbGlkIERPTSBlbGVtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5QnlGaWVsZFNlbGVjdG9yKGZpZWxkU2VsZWN0b3IpO1xuICAgIGlmICgha2V5IHx8ICF0aGlzLmZpZWxkc1trZXldKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGaWVsZCBub3QgZm91bmQuIENoZWNrIHRoZSBmaWVsZCBzZWxlY3Rvci5gKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMudmFsaWRhdGVGaWVsZChrZXksIHRydWUpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyRmllbGRTdHlsZShrZXkpO1xuICAgICAgICB0aGlzLmNsZWFyRmllbGRMYWJlbChrZXkpO1xuICAgICAgICB0aGlzLnJlbmRlckZpZWxkRXJyb3Ioa2V5LCB0cnVlKTtcbiAgICAgICAgcmVzb2x2ZSghIXRoaXMuZmllbGRzW2tleV0uaXNWYWxpZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXZhbGlkYXRlR3JvdXAoZ3JvdXBTZWxlY3Rvcikge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBTZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiAhaXNFbGVtZW50KGdyb3VwU2VsZWN0b3IpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYEdyb3VwIHNlbGVjdG9yIGlzIG5vdCB2YWxpZC4gUGxlYXNlIHNwZWNpZnkgYSBzdHJpbmcgc2VsZWN0b3Igb3IgYSB2YWxpZCBET00gZWxlbWVudC5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleUJ5RmllbGRTZWxlY3Rvcihncm91cFNlbGVjdG9yKTtcbiAgICBpZiAoIWtleSB8fCAhdGhpcy5ncm91cEZpZWxkc1trZXldKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBHcm91cCBub3QgZm91bmQuIENoZWNrIHRoZSBncm91cCBzZWxlY3Rvci5gKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMudmFsaWRhdGVHcm91cChrZXkpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyRmllbGRMYWJlbChrZXkpO1xuICAgICAgICB0aGlzLnJlbmRlckdyb3VwRXJyb3Ioa2V5LCB0cnVlKTtcbiAgICAgICAgcmVzb2x2ZSghIXRoaXMuZ3JvdXBGaWVsZHNba2V5XS5pc1ZhbGlkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlR3JvdXAoa2V5LCBhZnRlcklucHV0Q2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSB0aGlzLmdyb3VwRmllbGRzW2tleV07XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBbLi4uZ3JvdXAucnVsZXNdLnJldmVyc2UoKS5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICBjb25zdCByZXMgPSB0aGlzLnZhbGlkYXRlR3JvdXBSdWxlKGtleSwgZ3JvdXAuZWxlbXMsIHJ1bGUpO1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2gocmVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChhZnRlcklucHV0Q2hhbmdlZCkge1xuICAgICAgICAoX2EgPSB0aGlzLm9uVmFsaWRhdGVDYWxsYmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywge1xuICAgICAgICAgIGlzVmFsaWQ6IHRoaXMuaXNGb3JtVmFsaWQoKSxcbiAgICAgICAgICBpc1N1Ym1pdHRlZDogdGhpcy5pc1N1Ym1pdHRlZCxcbiAgICAgICAgICBmaWVsZHM6IHRoaXMuZ2V0Q29tcGF0aWJsZUZpZWxkcygpLFxuICAgICAgICAgIGdyb3VwczogeyAuLi50aGlzLmdyb3VwRmllbGRzIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZm9jdXNJbnZhbGlkRmllbGQoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5maWVsZHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZHNba2V5XTtcbiAgICAgIGlmICghZmllbGQuaXNWYWxpZCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGZpZWxkLmVsZW0uZm9jdXMoKSwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhZnRlclN1Ym1pdFZhbGlkYXRpb24oZm9yY2VSZXZhbGlkYXRpb24gPSBmYWxzZSkge1xuICAgIHRoaXMucmVuZGVyRXJyb3JzKGZvcmNlUmV2YWxpZGF0aW9uKTtcbiAgICBpZiAodGhpcy5nbG9iYWxDb25maWcuZm9jdXNJbnZhbGlkRmllbGQpIHtcbiAgICAgIHRoaXMuZm9jdXNJbnZhbGlkRmllbGQoKTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUoZm9yY2VSZXZhbGlkYXRpb24gPSBmYWxzZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMudmFsaWRhdGVGaWVsZChrZXkpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmdyb3VwRmllbGRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMudmFsaWRhdGVHcm91cChrZXkpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuYWZ0ZXJTdWJtaXRWYWxpZGF0aW9uKGZvcmNlUmV2YWxpZGF0aW9uKTtcbiAgICAgICAgKF9hID0gdGhpcy5vblZhbGlkYXRlQ2FsbGJhY2spID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICBpc1ZhbGlkOiB0aGlzLmlzRm9ybVZhbGlkKCksXG4gICAgICAgICAgaXNTdWJtaXR0ZWQ6IHRoaXMuaXNTdWJtaXR0ZWQsXG4gICAgICAgICAgZmllbGRzOiB0aGlzLmdldENvbXBhdGlibGVGaWVsZHMoKSxcbiAgICAgICAgICBncm91cHM6IHsgLi4udGhpcy5ncm91cEZpZWxkcyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvbHZlKCEhcHJvbWlzZXMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLnZhbGlkYXRlSGFuZGxlcih2b2lkIDAsIHRydWUpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5nbG9iYWxDb25maWcuZm9jdXNJbnZhbGlkRmllbGQpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzSW52YWxpZEZpZWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSh0aGlzLmlzVmFsaWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGVIYW5kbGVyKGV2LCBmb3JjZVJldmFsaWRhdGlvbiA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZ2xvYmFsQ29uZmlnLmxvY2tGb3JtKSB7XG4gICAgICB0aGlzLmxvY2tGb3JtKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGZvcmNlUmV2YWxpZGF0aW9uKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAodGhpcy5nbG9iYWxDb25maWcubG9ja0Zvcm0pIHtcbiAgICAgICAgdGhpcy51bmxvY2tGb3JtKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICAgIChfYSA9IHRoaXMub25TdWNjZXNzQ2FsbGJhY2spID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChfYiA9IHRoaXMub25GYWlsQ2FsbGJhY2spID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIHRoaXMuZ2V0Q29tcGF0aWJsZUZpZWxkcygpLCB0aGlzLmdyb3VwRmllbGRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXRGb3JtKGZvcm0pIHtcbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuZm9ybS5zZXRBdHRyaWJ1dGUoXCJub3ZhbGlkYXRlXCIsIFwibm92YWxpZGF0ZVwiKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMuZm9ybSwgdGhpcy5mb3JtU3VibWl0SGFuZGxlcik7XG4gICAgdGhpcy5hZGRMaXN0ZW5lcihcInN1Ym1pdFwiLCB0aGlzLmZvcm0sIHRoaXMuZm9ybVN1Ym1pdEhhbmRsZXIpO1xuICB9XG4gIGFkZExpc3RlbmVyKHR5cGUsIGVsZW0sIGhhbmRsZXIpIHtcbiAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5wdXNoKHsgdHlwZSwgZWxlbSwgZnVuYzogaGFuZGxlciB9KTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcih0eXBlLCBlbGVtLCBoYW5kbGVyKSB7XG4gICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmZpbHRlcihcbiAgICAgIChpdGVtKSA9PiBpdGVtLnR5cGUgIT09IHR5cGUgfHwgaXRlbS5lbGVtICE9PSBlbGVtXG4gICAgKTtcbiAgfVxuICBhZGRGaWVsZChmaWVsZFNlbGVjdG9yLCBydWxlcywgY29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZFNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmICFpc0VsZW1lbnQoZmllbGRTZWxlY3RvcikpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgRmllbGQgc2VsZWN0b3IgaXMgbm90IHZhbGlkLiBQbGVhc2Ugc3BlY2lmeSBhIHN0cmluZyBzZWxlY3RvciBvciBhIHZhbGlkIERPTSBlbGVtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBlbGVtO1xuICAgIGlmICh0eXBlb2YgZmllbGRTZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZWxlbSA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yKGZpZWxkU2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtID0gZmllbGRTZWxlY3RvcjtcbiAgICB9XG4gICAgaWYgKCFlbGVtKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYEZpZWxkIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIERPTSEgUGxlYXNlIGNoZWNrIHRoZSBmaWVsZCBzZWxlY3Rvci5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocnVsZXMpIHx8ICFydWxlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgUnVsZXMgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5IGFuZCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAxIGVsZW1lbnQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcnVsZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKCEoXCJydWxlXCIgaW4gaXRlbSB8fCBcInZhbGlkYXRvclwiIGluIGl0ZW0gfHwgXCJwbHVnaW5cIiBpbiBpdGVtKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgUnVsZXMgYXJndW1lbnQgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBydWxlIG9yIHZhbGlkYXRvciBwcm9wZXJ0eS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIWl0ZW0udmFsaWRhdG9yICYmICFpdGVtLnBsdWdpbiAmJiAoIWl0ZW0ucnVsZSB8fCAhT2JqZWN0LnZhbHVlcyhSdWxlcykuaW5jbHVkZXMoaXRlbS5ydWxlKSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgYFJ1bGUgc2hvdWxkIGJlIG9uZSBvZiB0aGVzZSB0eXBlczogJHtPYmplY3QudmFsdWVzKFJ1bGVzKS5qb2luKFxuICAgICAgICAgICAgXCIsIFwiXG4gICAgICAgICAgKX0uIFByb3ZpZGVkIHZhbHVlOiAke2l0ZW0ucnVsZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5zZXRLZXlCeUZpZWxkU2VsZWN0b3IoZmllbGRTZWxlY3Rvcik7XG4gICAgdGhpcy5maWVsZHNba2V5XSA9IHtcbiAgICAgIGVsZW0sXG4gICAgICBydWxlcyxcbiAgICAgIGlzVmFsaWQ6IHZvaWQgMCxcbiAgICAgIHRvdWNoZWQ6IGZhbHNlLFxuICAgICAgY29uZmlnXG4gICAgfTtcbiAgICB0aGlzLnNldExpc3RlbmVycyhlbGVtKTtcbiAgICBpZiAodGhpcy5pc1N1Ym1pdHRlZCB8fCB0aGlzLmdsb2JhbENvbmZpZy52YWxpZGF0ZUJlZm9yZVN1Ym1pdHRpbmcpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVGaWVsZChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmVGaWVsZChmaWVsZFNlbGVjdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZFNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmICFpc0VsZW1lbnQoZmllbGRTZWxlY3RvcikpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgRmllbGQgc2VsZWN0b3IgaXMgbm90IHZhbGlkLiBQbGVhc2Ugc3BlY2lmeSBhIHN0cmluZyBzZWxlY3RvciBvciBhIHZhbGlkIERPTSBlbGVtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5QnlGaWVsZFNlbGVjdG9yKGZpZWxkU2VsZWN0b3IpO1xuICAgIGlmICgha2V5IHx8ICF0aGlzLmZpZWxkc1trZXldKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGaWVsZCBub3QgZm91bmQuIENoZWNrIHRoZSBmaWVsZCBzZWxlY3Rvci5gKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRMaXN0ZW5lclR5cGUodGhpcy5maWVsZHNba2V5XS5lbGVtLnR5cGUpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgdGhpcy5maWVsZHNba2V5XS5lbGVtLCB0aGlzLmhhbmRsZXJDaGFuZ2UpO1xuICAgIHRoaXMuY2xlYXJFcnJvcnMoKTtcbiAgICBkZWxldGUgdGhpcy5maWVsZHNba2V5XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmVHcm91cChncm91cCkge1xuICAgIGlmICh0eXBlb2YgZ3JvdXAgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgR3JvdXAgc2VsZWN0b3IgaXMgbm90IHZhbGlkLiBQbGVhc2Ugc3BlY2lmeSBhIHN0cmluZyBzZWxlY3Rvci5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleUJ5RmllbGRTZWxlY3Rvcihncm91cCk7XG4gICAgaWYgKCFrZXkgfHwgIXRoaXMuZ3JvdXBGaWVsZHNba2V5XSkge1xuICAgICAgY29uc29sZS5lcnJvcihgR3JvdXAgbm90IGZvdW5kLiBDaGVjayB0aGUgZ3JvdXAgc2VsZWN0b3IuYCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5ncm91cEZpZWxkc1trZXldLmVsZW1zLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldExpc3RlbmVyVHlwZShlbGVtLnR5cGUpO1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBlbGVtLCB0aGlzLmhhbmRsZXJDaGFuZ2UpO1xuICAgIH0pO1xuICAgIHRoaXMuY2xlYXJFcnJvcnMoKTtcbiAgICBkZWxldGUgdGhpcy5ncm91cEZpZWxkc1trZXldO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFJlcXVpcmVkR3JvdXAoZ3JvdXBGaWVsZCwgZXJyb3JNZXNzYWdlLCBjb25maWcsIHN1Y2Nlc3NNZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cEZpZWxkICE9PSBcInN0cmluZ1wiICYmICFpc0VsZW1lbnQoZ3JvdXBGaWVsZCkpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgR3JvdXAgc2VsZWN0b3IgaXMgbm90IHZhbGlkLiBQbGVhc2Ugc3BlY2lmeSBhIHN0cmluZyBzZWxlY3RvciBvciBhIHZhbGlkIERPTSBlbGVtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBlbGVtO1xuICAgIGlmICh0eXBlb2YgZ3JvdXBGaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZWxlbSA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yKGdyb3VwRmllbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtID0gZ3JvdXBGaWVsZDtcbiAgICB9XG4gICAgaWYgKCFlbGVtKSB7XG4gICAgICB0aHJvdyBFcnJvcihgR3JvdXAgc2VsZWN0b3Igbm90IGZvdW5kISBQbGVhc2UgY2hlY2sgdGhlIGdyb3VwIHNlbGVjdG9yLmApO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dHMgPSBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcbiAgICBjb25zdCBjaGlsZHJlbklucHV0cyA9IEFycmF5LmZyb20oaW5wdXRzKS5maWx0ZXIoKGlucHV0KSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBnZXRDbG9zZXN0UGFyZW50KHRoaXMuZ3JvdXBGaWVsZHMsIGdldE5vZGVQYXJlbnRzKGlucHV0KSk7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRbMV0uZWxlbXMuZmluZCgoZWxlbTIpID0+IGVsZW0yICE9PSBpbnB1dCk7XG4gICAgfSk7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5zZXRLZXlCeUZpZWxkU2VsZWN0b3IoZ3JvdXBGaWVsZCk7XG4gICAgdGhpcy5ncm91cEZpZWxkc1trZXldID0ge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJ1bGU6IEdyb3VwUnVsZXMuUmVxdWlyZWQsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgICAgIHN1Y2Nlc3NNZXNzYWdlXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBncm91cEVsZW06IGVsZW0sXG4gICAgICBlbGVtczogY2hpbGRyZW5JbnB1dHMsXG4gICAgICB0b3VjaGVkOiBmYWxzZSxcbiAgICAgIGlzVmFsaWQ6IHZvaWQgMCxcbiAgICAgIGNvbmZpZ1xuICAgIH07XG4gICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICB0aGlzLnNldExpc3RlbmVycyhpbnB1dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0TGlzdGVuZXJUeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgY2FzZSBcInNlbGVjdC1vbmVcIjpcbiAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICBjYXNlIFwicmFkaW9cIjoge1xuICAgICAgICByZXR1cm4gXCJjaGFuZ2VcIjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIFwiaW5wdXRcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0TGlzdGVuZXJzKGVsZW0pIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRMaXN0ZW5lclR5cGUoZWxlbS50eXBlKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGVsZW0sIHRoaXMuaGFuZGxlckNoYW5nZSk7XG4gICAgdGhpcy5hZGRMaXN0ZW5lcih0eXBlLCBlbGVtLCB0aGlzLmhhbmRsZXJDaGFuZ2UpO1xuICB9XG4gIGNsZWFyRmllbGRMYWJlbChrZXkpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IHRoaXMuZXJyb3JMYWJlbHNba2V5XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgIChfYiA9IHRoaXMuc3VjY2Vzc0xhYmVsc1trZXldKSA9PSBudWxsID8gdm9pZCAwIDogX2IucmVtb3ZlKCk7XG4gIH1cbiAgY2xlYXJGaWVsZFN0eWxlKGtleSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgY29uc3QgZXJyb3JTdHlsZSA9ICgoX2EgPSBmaWVsZC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5lcnJvckZpZWxkU3R5bGUpIHx8IHRoaXMuZ2xvYmFsQ29uZmlnLmVycm9yRmllbGRTdHlsZTtcbiAgICBPYmplY3Qua2V5cyhlcnJvclN0eWxlKS5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICBmaWVsZC5lbGVtLnN0eWxlW2tleTJdID0gXCJcIjtcbiAgICB9KTtcbiAgICBjb25zdCBzdWNjZXNzU3R5bGUgPSAoKF9iID0gZmllbGQuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc3VjY2Vzc0ZpZWxkU3R5bGUpIHx8IHRoaXMuZ2xvYmFsQ29uZmlnLnN1Y2Nlc3NGaWVsZFN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN1Y2Nlc3NTdHlsZSkuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgZmllbGQuZWxlbS5zdHlsZVtrZXkyXSA9IFwiXCI7XG4gICAgfSk7XG4gICAgZmllbGQuZWxlbS5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgLi4uZ2V0Q2xhc3NMaXN0KFxuICAgICAgICAoKF9jID0gZmllbGQuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZXJyb3JGaWVsZENzc0NsYXNzKSB8fCB0aGlzLmdsb2JhbENvbmZpZy5lcnJvckZpZWxkQ3NzQ2xhc3NcbiAgICAgICksXG4gICAgICAuLi5nZXRDbGFzc0xpc3QoXG4gICAgICAgICgoX2QgPSBmaWVsZC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfZC5zdWNjZXNzRmllbGRDc3NDbGFzcykgfHwgdGhpcy5nbG9iYWxDb25maWcuc3VjY2Vzc0ZpZWxkQ3NzQ2xhc3NcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGNsZWFyRXJyb3JzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgT2JqZWN0LmtleXModGhpcy5lcnJvckxhYmVscykuZm9yRWFjaChcbiAgICAgIChrZXkpID0+IHRoaXMuZXJyb3JMYWJlbHNba2V5XS5yZW1vdmUoKVxuICAgICk7XG4gICAgT2JqZWN0LmtleXModGhpcy5zdWNjZXNzTGFiZWxzKS5mb3JFYWNoKFxuICAgICAgKGtleSkgPT4gdGhpcy5zdWNjZXNzTGFiZWxzW2tleV0ucmVtb3ZlKClcbiAgICApO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZmllbGRzKSB7XG4gICAgICB0aGlzLmNsZWFyRmllbGRTdHlsZShrZXkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmdyb3VwRmllbGRzKSB7XG4gICAgICBjb25zdCBncm91cCA9IHRoaXMuZ3JvdXBGaWVsZHNba2V5XTtcbiAgICAgIGNvbnN0IGVycm9yU3R5bGUgPSAoKF9hID0gZ3JvdXAuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZXJyb3JGaWVsZFN0eWxlKSB8fCB0aGlzLmdsb2JhbENvbmZpZy5lcnJvckZpZWxkU3R5bGU7XG4gICAgICBPYmplY3Qua2V5cyhlcnJvclN0eWxlKS5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICAgIGdyb3VwLmVsZW1zLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgIGVsZW0uc3R5bGVba2V5Ml0gPSBcIlwiO1xuICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICAgIC4uLmdldENsYXNzTGlzdChcbiAgICAgICAgICAgICAgKChfYTIgPSBncm91cC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZXJyb3JGaWVsZENzc0NsYXNzKSB8fCB0aGlzLmdsb2JhbENvbmZpZy5lcnJvckZpZWxkQ3NzQ2xhc3NcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3VjY2Vzc1N0eWxlID0gKChfYiA9IGdyb3VwLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN1Y2Nlc3NGaWVsZFN0eWxlKSB8fCB0aGlzLmdsb2JhbENvbmZpZy5zdWNjZXNzRmllbGRTdHlsZSB8fCB7fTtcbiAgICAgIE9iamVjdC5rZXlzKHN1Y2Nlc3NTdHlsZSkuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgICBncm91cC5lbGVtcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICBlbGVtLnN0eWxlW2tleTJdID0gXCJcIjtcbiAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgICAuLi5nZXRDbGFzc0xpc3QoXG4gICAgICAgICAgICAgICgoX2EyID0gZ3JvdXAuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnN1Y2Nlc3NGaWVsZENzc0NsYXNzKSB8fCB0aGlzLmdsb2JhbENvbmZpZy5zdWNjZXNzRmllbGRDc3NDbGFzc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMudG9vbHRpcHMgPSBbXTtcbiAgfVxuICBpc1Rvb2x0aXAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nbG9iYWxDb25maWcudG9vbHRpcDtcbiAgfVxuICBsb2NrRm9ybSgpIHtcbiAgICBjb25zdCBlbGVtcyA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XCJcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgZWxlbXNbaV0uc2V0QXR0cmlidXRlKFxuICAgICAgICBcImRhdGEtanVzdC12YWxpZGF0ZS1mYWxsYmFjay1kaXNhYmxlZFwiLFxuICAgICAgICBlbGVtc1tpXS5kaXNhYmxlZCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiXG4gICAgICApO1xuICAgICAgZWxlbXNbaV0uc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgIGVsZW1zW2ldLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgIGVsZW1zW2ldLnN0eWxlLndlYmtpdEZpbHRlciA9IFwiZ3JheXNjYWxlKDEwMCUpXCI7XG4gICAgICBlbGVtc1tpXS5zdHlsZS5maWx0ZXIgPSBcImdyYXlzY2FsZSgxMDAlKVwiO1xuICAgIH1cbiAgfVxuICB1bmxvY2tGb3JtKCkge1xuICAgIGNvbnN0IGVsZW1zID0gdGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICBcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3RcIlxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoZWxlbXNbaV0uZ2V0QXR0cmlidXRlKFwiZGF0YS1qdXN0LXZhbGlkYXRlLWZhbGxiYWNrLWRpc2FibGVkXCIpICE9PSBcInRydWVcIikge1xuICAgICAgICBlbGVtc1tpXS5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICAgIH1cbiAgICAgIGVsZW1zW2ldLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIlwiO1xuICAgICAgZWxlbXNbaV0uc3R5bGUud2Via2l0RmlsdGVyID0gXCJcIjtcbiAgICAgIGVsZW1zW2ldLnN0eWxlLmZpbHRlciA9IFwiXCI7XG4gICAgfVxuICB9XG4gIHJlbmRlclRvb2x0aXAoZWxlbSwgZXJyb3JMYWJlbCwgcG9zaXRpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZXJyb3JMYWJlbFJlY3QgPSBlcnJvckxhYmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uIHx8ICgoX2EgPSB0aGlzLmdsb2JhbENvbmZpZy50b29sdGlwKSA9PSBudWxsID8gdm9pZCAwIDogX2EucG9zaXRpb24pO1xuICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICBjYXNlIFwibGVmdFwiOiB7XG4gICAgICAgIGVycm9yTGFiZWwuc3R5bGUudG9wID0gYCR7dG9wICsgaGVpZ2h0IC8gMiAtIGVycm9yTGFiZWxSZWN0LmhlaWdodCAvIDJ9cHhgO1xuICAgICAgICBlcnJvckxhYmVsLnN0eWxlLmxlZnQgPSBgJHtsZWZ0IC0gZXJyb3JMYWJlbFJlY3Qud2lkdGggLSBUT09MVElQX0FSUk9XX0hFSUdIVH1weGA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvcFwiOiB7XG4gICAgICAgIGVycm9yTGFiZWwuc3R5bGUudG9wID0gYCR7dG9wIC0gZXJyb3JMYWJlbFJlY3QuaGVpZ2h0IC0gVE9PTFRJUF9BUlJPV19IRUlHSFR9cHhgO1xuICAgICAgICBlcnJvckxhYmVsLnN0eWxlLmxlZnQgPSBgJHtsZWZ0ICsgd2lkdGggLyAyIC0gZXJyb3JMYWJlbFJlY3Qud2lkdGggLyAyfXB4YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmlnaHRcIjoge1xuICAgICAgICBlcnJvckxhYmVsLnN0eWxlLnRvcCA9IGAke3RvcCArIGhlaWdodCAvIDIgLSBlcnJvckxhYmVsUmVjdC5oZWlnaHQgLyAyfXB4YDtcbiAgICAgICAgZXJyb3JMYWJlbC5zdHlsZS5sZWZ0ID0gYCR7bGVmdCArIHdpZHRoICsgVE9PTFRJUF9BUlJPV19IRUlHSFR9cHhgO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJib3R0b21cIjoge1xuICAgICAgICBlcnJvckxhYmVsLnN0eWxlLnRvcCA9IGAke3RvcCArIGhlaWdodCArIFRPT0xUSVBfQVJST1dfSEVJR0hUfXB4YDtcbiAgICAgICAgZXJyb3JMYWJlbC5zdHlsZS5sZWZ0ID0gYCR7bGVmdCArIHdpZHRoIC8gMiAtIGVycm9yTGFiZWxSZWN0LndpZHRoIC8gMn1weGA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlcnJvckxhYmVsLmRhdGFzZXQuZGlyZWN0aW9uID0gcG9zO1xuICAgIGNvbnN0IHJlZnJlc2ggPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlbmRlclRvb2x0aXAoZWxlbSwgZXJyb3JMYWJlbCwgcG9zaXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZnJlc2hcbiAgICB9O1xuICB9XG4gIGNyZWF0ZUVycm9yTGFiZWxFbGVtKGtleSwgZXJyb3JNZXNzYWdlLCBjb25maWcpIHtcbiAgICBjb25zdCBlcnJvckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlcnJvckxhYmVsLmlubmVySFRNTCA9IGVycm9yTWVzc2FnZTtcbiAgICBjb25zdCBjdXN0b21FcnJvckxhYmVsU3R5bGUgPSB0aGlzLmlzVG9vbHRpcCgpID8gY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZXJyb3JMYWJlbFN0eWxlIDogKGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmVycm9yTGFiZWxTdHlsZSkgfHwgdGhpcy5nbG9iYWxDb25maWcuZXJyb3JMYWJlbFN0eWxlO1xuICAgIE9iamVjdC5hc3NpZ24oZXJyb3JMYWJlbC5zdHlsZSwgY3VzdG9tRXJyb3JMYWJlbFN0eWxlKTtcbiAgICBlcnJvckxhYmVsLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi5nZXRDbGFzc0xpc3QoXG4gICAgICAgIChjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5lcnJvckxhYmVsQ3NzQ2xhc3MpIHx8IHRoaXMuZ2xvYmFsQ29uZmlnLmVycm9yTGFiZWxDc3NDbGFzc1xuICAgICAgKSxcbiAgICAgIFwianVzdC12YWxpZGF0ZS1lcnJvci1sYWJlbFwiXG4gICAgKTtcbiAgICBpZiAodGhpcy5pc1Rvb2x0aXAoKSkge1xuICAgICAgZXJyb3JMYWJlbC5kYXRhc2V0LnRvb2x0aXAgPSBcInRydWVcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2xvYmFsQ29uZmlnLnRlc3RpbmdNb2RlKSB7XG4gICAgICBlcnJvckxhYmVsLmRhdGFzZXQudGVzdElkID0gYGVycm9yLWxhYmVsLSR7a2V5fWA7XG4gICAgfVxuICAgIHRoaXMuZXJyb3JMYWJlbHNba2V5XSA9IGVycm9yTGFiZWw7XG4gICAgcmV0dXJuIGVycm9yTGFiZWw7XG4gIH1cbiAgY3JlYXRlU3VjY2Vzc0xhYmVsRWxlbShrZXksIHN1Y2Nlc3NNZXNzYWdlLCBjb25maWcpIHtcbiAgICBpZiAoc3VjY2Vzc01lc3NhZ2UgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN1Y2Nlc3NMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc3VjY2Vzc0xhYmVsLmlubmVySFRNTCA9IHN1Y2Nlc3NNZXNzYWdlO1xuICAgIGNvbnN0IGN1c3RvbVN1Y2Nlc3NMYWJlbFN0eWxlID0gKGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLnN1Y2Nlc3NMYWJlbFN0eWxlKSB8fCB0aGlzLmdsb2JhbENvbmZpZy5zdWNjZXNzTGFiZWxTdHlsZTtcbiAgICBPYmplY3QuYXNzaWduKHN1Y2Nlc3NMYWJlbC5zdHlsZSwgY3VzdG9tU3VjY2Vzc0xhYmVsU3R5bGUpO1xuICAgIHN1Y2Nlc3NMYWJlbC5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4uZ2V0Q2xhc3NMaXN0KFxuICAgICAgICAoY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuc3VjY2Vzc0xhYmVsQ3NzQ2xhc3MpIHx8IHRoaXMuZ2xvYmFsQ29uZmlnLnN1Y2Nlc3NMYWJlbENzc0NsYXNzXG4gICAgICApLFxuICAgICAgXCJqdXN0LXZhbGlkYXRlLXN1Y2Nlc3MtbGFiZWxcIlxuICAgICk7XG4gICAgaWYgKHRoaXMuZ2xvYmFsQ29uZmlnLnRlc3RpbmdNb2RlKSB7XG4gICAgICBzdWNjZXNzTGFiZWwuZGF0YXNldC50ZXN0SWQgPSBgc3VjY2Vzcy1sYWJlbC0ke2tleX1gO1xuICAgIH1cbiAgICB0aGlzLnN1Y2Nlc3NMYWJlbHNba2V5XSA9IHN1Y2Nlc3NMYWJlbDtcbiAgICByZXR1cm4gc3VjY2Vzc0xhYmVsO1xuICB9XG4gIHJlbmRlckVycm9yc0NvbnRhaW5lcihsYWJlbCwgZXJyb3JzQ29udGFpbmVyKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZXJyb3JzQ29udGFpbmVyIHx8IHRoaXMuZ2xvYmFsQ29uZmlnLmVycm9yc0NvbnRhaW5lcjtcbiAgICBpZiAodHlwZW9mIGNvbnRhaW5lciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgZWxlbSA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBFcnJvciBjb250YWluZXIgd2l0aCAke2NvbnRhaW5lcn0gc2VsZWN0b3Igbm90IGZvdW5kLiBFcnJvcnMgd2lsbCBiZSByZW5kZXJlZCBhcyB1c3VhbGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5lciAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRXJyb3IgY29udGFpbmVyIG5vdCBmb3VuZC4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIG9yIGV4aXN0aW5nIEVsZW1lbnQuIEVycm9ycyB3aWxsIGJlIHJlbmRlcmVkIGFzIHVzdWFsYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlbmRlckdyb3VwTGFiZWwoZWxlbSwgbGFiZWwsIGVycm9yc0NvbnRhaW5lciwgaXNTdWNjZXNzKSB7XG4gICAgaWYgKCFpc1N1Y2Nlc3MpIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVkSW5FcnJvcnNDb250YWluZXIgPSB0aGlzLnJlbmRlckVycm9yc0NvbnRhaW5lcihcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGVycm9yc0NvbnRhaW5lclxuICAgICAgKTtcbiAgICAgIGlmIChyZW5kZXJlZEluRXJyb3JzQ29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbS5hcHBlbmRDaGlsZChsYWJlbCk7XG4gIH1cbiAgcmVuZGVyRmllbGRMYWJlbChlbGVtLCBsYWJlbCwgZXJyb3JzQ29udGFpbmVyLCBpc1N1Y2Nlc3MpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgaWYgKCFpc1N1Y2Nlc3MpIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVkSW5FcnJvcnNDb250YWluZXIgPSB0aGlzLnJlbmRlckVycm9yc0NvbnRhaW5lcihcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGVycm9yc0NvbnRhaW5lclxuICAgICAgKTtcbiAgICAgIGlmIChyZW5kZXJlZEluRXJyb3JzQ29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVsZW0udHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IGVsZW0udHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgICBjb25zdCBsYWJlbEVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBgbGFiZWxbZm9yPVwiJHtlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpfVwiXWBcbiAgICAgICk7XG4gICAgICBpZiAoKChfYiA9IChfYSA9IGVsZW0ucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRhZ05hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpKSA9PT0gXCJsYWJlbFwiKSB7XG4gICAgICAgIChfZCA9IChfYyA9IGVsZW0ucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnBhcmVudEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsRWxlbSkge1xuICAgICAgICAoX2UgPSBsYWJlbEVsZW0ucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChfZiA9IGVsZW0ucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKF9nID0gZWxlbS5wYXJlbnRFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2cuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIH1cbiAgfVxuICBzaG93TGFiZWxzKGZpZWxkcywgaXNFcnJvcikge1xuICAgIE9iamVjdC5rZXlzKGZpZWxkcykuZm9yRWFjaCgoZmllbGROYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IGZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXlCeUZpZWxkU2VsZWN0b3IoZmllbGROYW1lKTtcbiAgICAgIGlmICgha2V5IHx8ICF0aGlzLmZpZWxkc1trZXldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZpZWxkIG5vdCBmb3VuZC4gQ2hlY2sgdGhlIGZpZWxkIHNlbGVjdG9yLmApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgICBmaWVsZC5pc1ZhbGlkID0gIWlzRXJyb3I7XG4gICAgICB0aGlzLmNsZWFyRmllbGRTdHlsZShrZXkpO1xuICAgICAgdGhpcy5jbGVhckZpZWxkTGFiZWwoa2V5KTtcbiAgICAgIHRoaXMucmVuZGVyRmllbGRFcnJvcihrZXksIGZhbHNlLCBlcnJvcik7XG4gICAgICBpZiAoaSA9PT0gMCAmJiB0aGlzLmdsb2JhbENvbmZpZy5mb2N1c0ludmFsaWRGaWVsZCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGZpZWxkLmVsZW0uZm9jdXMoKSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2hvd0Vycm9ycyhmaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkcyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiW3Nob3dFcnJvcnNdOiBFcnJvcnMgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGtleTogdmFsdWUgZm9ybWF0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuc2hvd0xhYmVscyhmaWVsZHMsIHRydWUpO1xuICB9XG4gIHNob3dTdWNjZXNzTGFiZWxzKGZpZWxkcykge1xuICAgIGlmICh0eXBlb2YgZmllbGRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJbc2hvd1N1Y2Nlc3NMYWJlbHNdOiBMYWJlbHMgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGtleTogdmFsdWUgZm9ybWF0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuc2hvd0xhYmVscyhmaWVsZHMsIGZhbHNlKTtcbiAgfVxuICByZW5kZXJGaWVsZEVycm9yKGtleSwgZm9yY2VkID0gZmFsc2UsIG1lc3NhZ2UpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgaWYgKGZpZWxkLmlzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmlzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGZpZWxkLmlzVmFsaWQgPT09IHZvaWQgMCB8fCAhZm9yY2VkICYmICF0aGlzLmlzU3VibWl0dGVkICYmICFmaWVsZC50b3VjaGVkICYmIG1lc3NhZ2UgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmllbGQuaXNWYWxpZCkge1xuICAgICAgaWYgKCFmaWVsZC5hc3luY0NoZWNrUGVuZGluZykge1xuICAgICAgICBjb25zdCBzdWNjZXNzTGFiZWwgPSB0aGlzLmNyZWF0ZVN1Y2Nlc3NMYWJlbEVsZW0oXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBmaWVsZC5zdWNjZXNzTWVzc2FnZSxcbiAgICAgICAgICBmaWVsZC5jb25maWdcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3NMYWJlbCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyRmllbGRMYWJlbChcbiAgICAgICAgICAgIGZpZWxkLmVsZW0sXG4gICAgICAgICAgICBzdWNjZXNzTGFiZWwsXG4gICAgICAgICAgICAoX2EgPSBmaWVsZC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5lcnJvcnNDb250YWluZXIsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZC5lbGVtLmNsYXNzTGlzdC5hZGQoXG4gICAgICAgICAgLi4uZ2V0Q2xhc3NMaXN0KFxuICAgICAgICAgICAgKChfYiA9IGZpZWxkLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN1Y2Nlc3NGaWVsZENzc0NsYXNzKSB8fCB0aGlzLmdsb2JhbENvbmZpZy5zdWNjZXNzRmllbGRDc3NDbGFzc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmllbGQuZWxlbS5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4uZ2V0Q2xhc3NMaXN0KFxuICAgICAgICAoKF9jID0gZmllbGQuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZXJyb3JGaWVsZENzc0NsYXNzKSB8fCB0aGlzLmdsb2JhbENvbmZpZy5lcnJvckZpZWxkQ3NzQ2xhc3NcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IGVycm9yTGFiZWwgPSB0aGlzLmNyZWF0ZUVycm9yTGFiZWxFbGVtKFxuICAgICAga2V5LFxuICAgICAgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGZpZWxkLmVycm9yTWVzc2FnZSxcbiAgICAgIGZpZWxkLmNvbmZpZ1xuICAgICk7XG4gICAgdGhpcy5yZW5kZXJGaWVsZExhYmVsKFxuICAgICAgZmllbGQuZWxlbSxcbiAgICAgIGVycm9yTGFiZWwsXG4gICAgICAoX2QgPSBmaWVsZC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfZC5lcnJvcnNDb250YWluZXJcbiAgICApO1xuICAgIGlmICh0aGlzLmlzVG9vbHRpcCgpKSB7XG4gICAgICB0aGlzLnRvb2x0aXBzLnB1c2goXG4gICAgICAgIHRoaXMucmVuZGVyVG9vbHRpcChcbiAgICAgICAgICBmaWVsZC5lbGVtLFxuICAgICAgICAgIGVycm9yTGFiZWwsXG4gICAgICAgICAgKF9mID0gKF9lID0gZmllbGQuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2UudG9vbHRpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnBvc2l0aW9uXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJlbmRlckdyb3VwRXJyb3Ioa2V5LCBmb3JjZSA9IHRydWUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgZ3JvdXAgPSB0aGlzLmdyb3VwRmllbGRzW2tleV07XG4gICAgaWYgKGdyb3VwLmlzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmlzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmlzVmFsaWQgPT09IHZvaWQgMCB8fCAhZm9yY2UgJiYgIXRoaXMuaXNTdWJtaXR0ZWQgJiYgIWdyb3VwLnRvdWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmlzVmFsaWQpIHtcbiAgICAgIGdyb3VwLmVsZW1zLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2IyO1xuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIGVsZW0uc3R5bGUsXG4gICAgICAgICAgKChfYTIgPSBncm91cC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc3VjY2Vzc0ZpZWxkU3R5bGUpIHx8IHRoaXMuZ2xvYmFsQ29uZmlnLnN1Y2Nlc3NGaWVsZFN0eWxlXG4gICAgICAgICk7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChcbiAgICAgICAgICAuLi5nZXRDbGFzc0xpc3QoXG4gICAgICAgICAgICAoKF9iMiA9IGdyb3VwLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5zdWNjZXNzRmllbGRDc3NDbGFzcykgfHwgdGhpcy5nbG9iYWxDb25maWcuc3VjY2Vzc0ZpZWxkQ3NzQ2xhc3NcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NMYWJlbCA9IHRoaXMuY3JlYXRlU3VjY2Vzc0xhYmVsRWxlbShcbiAgICAgICAga2V5LFxuICAgICAgICBncm91cC5zdWNjZXNzTWVzc2FnZSxcbiAgICAgICAgZ3JvdXAuY29uZmlnXG4gICAgICApO1xuICAgICAgaWYgKHN1Y2Nlc3NMYWJlbCkge1xuICAgICAgICB0aGlzLnJlbmRlckdyb3VwTGFiZWwoXG4gICAgICAgICAgZ3JvdXAuZ3JvdXBFbGVtLFxuICAgICAgICAgIHN1Y2Nlc3NMYWJlbCxcbiAgICAgICAgICAoX2EgPSBncm91cC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5lcnJvcnNDb250YWluZXIsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzVmFsaWQgPSBmYWxzZTtcbiAgICBncm91cC5lbGVtcy5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYjI7XG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICBlbGVtLnN0eWxlLFxuICAgICAgICAoKF9hMiA9IGdyb3VwLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5lcnJvckZpZWxkU3R5bGUpIHx8IHRoaXMuZ2xvYmFsQ29uZmlnLmVycm9yRmllbGRTdHlsZVxuICAgICAgKTtcbiAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChcbiAgICAgICAgLi4uZ2V0Q2xhc3NMaXN0KFxuICAgICAgICAgICgoX2IyID0gZ3JvdXAuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmVycm9yRmllbGRDc3NDbGFzcykgfHwgdGhpcy5nbG9iYWxDb25maWcuZXJyb3JGaWVsZENzc0NsYXNzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29uc3QgZXJyb3JMYWJlbCA9IHRoaXMuY3JlYXRlRXJyb3JMYWJlbEVsZW0oXG4gICAgICBrZXksXG4gICAgICBncm91cC5lcnJvck1lc3NhZ2UsXG4gICAgICBncm91cC5jb25maWdcbiAgICApO1xuICAgIHRoaXMucmVuZGVyR3JvdXBMYWJlbChcbiAgICAgIGdyb3VwLmdyb3VwRWxlbSxcbiAgICAgIGVycm9yTGFiZWwsXG4gICAgICAoX2IgPSBncm91cC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5lcnJvcnNDb250YWluZXJcbiAgICApO1xuICAgIGlmICh0aGlzLmlzVG9vbHRpcCgpKSB7XG4gICAgICB0aGlzLnRvb2x0aXBzLnB1c2goXG4gICAgICAgIHRoaXMucmVuZGVyVG9vbHRpcChcbiAgICAgICAgICBncm91cC5ncm91cEVsZW0sXG4gICAgICAgICAgZXJyb3JMYWJlbCxcbiAgICAgICAgICAoX2QgPSAoX2MgPSBncm91cC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYy50b29sdGlwKSA9PSBudWxsID8gdm9pZCAwIDogX2QucG9zaXRpb25cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyRXJyb3JzKGZvcmNlUmV2YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuaXNTdWJtaXR0ZWQgJiYgIWZvcmNlUmV2YWxpZGF0aW9uICYmICF0aGlzLmdsb2JhbENvbmZpZy52YWxpZGF0ZUJlZm9yZVN1Ym1pdHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jbGVhckVycm9ycygpO1xuICAgIHRoaXMuaXNWYWxpZCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5ncm91cEZpZWxkcykge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cEVycm9yKGtleSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZmllbGRzKSB7XG4gICAgICB0aGlzLnJlbmRlckZpZWxkRXJyb3Ioa2V5KTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LnR5cGUsIGV2ZW50LmVsZW0sIGV2ZW50LmZ1bmMpO1xuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuY3VzdG9tU3R5bGVUYWdzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuY3VzdG9tU3R5bGVUYWdzW2tleV0ucmVtb3ZlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5jbGVhckVycm9ycygpO1xuICAgIGlmICh0aGlzLmdsb2JhbENvbmZpZy5sb2NrRm9ybSkge1xuICAgICAgdGhpcy51bmxvY2tGb3JtKCk7XG4gICAgfVxuICB9XG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSB0aGUgbGlicmFyeSEgRm9ybSBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0aWFsaXplKHRoaXMuZm9ybSwgdGhpcy5nbG9iYWxDb25maWcpO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5maWVsZHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZFNlbGVjdG9yID0gdGhpcy5nZXRGaWVsZFNlbGVjdG9yQnlLZXkoa2V5KTtcbiAgICAgICAgaWYgKGZpZWxkU2VsZWN0b3IpIHtcbiAgICAgICAgICB0aGlzLmFkZEZpZWxkKFxuICAgICAgICAgICAgZmllbGRTZWxlY3RvcixcbiAgICAgICAgICAgIFsuLi50aGlzLmZpZWxkc1trZXldLnJ1bGVzXSxcbiAgICAgICAgICAgIHRoaXMuZmllbGRzW2tleV0uY29uZmlnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNldEN1cnJlbnRMb2NhbGUobG9jYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGUgIT09IFwic3RyaW5nXCIgJiYgbG9jYWxlICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDdXJyZW50IGxvY2FsZSBzaG91bGQgYmUgYSBzdHJpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudExvY2FsZSA9IGxvY2FsZTtcbiAgICBpZiAodGhpcy5pc1N1Ym1pdHRlZCkge1xuICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBvblN1Y2Nlc3MoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9uU3VjY2Vzc0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25GYWlsKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbkZhaWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uVmFsaWRhdGUoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9uVmFsaWRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5leHBvcnQge1xuICBDdXN0b21TdHlsZVRhZ0lkcyxcbiAgR3JvdXBSdWxlcyxcbiAgUnVsZXMsXG4gIEp1c3RWYWxpZGF0ZSBhcyBkZWZhdWx0XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbnVtYmVySXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXMoYSwgYikge1xuXHRpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG5cdFx0cmV0dXJuIDEgLyBhID09PSAxIC8gYjtcblx0fVxuXHRpZiAoYSA9PT0gYikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChudW1iZXJJc05hTihhKSAmJiBudW1iZXJJc05hTihiKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgT2JqZWN0KTtcblxuZGVmaW5lKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU9iamVjdElzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoT2JqZWN0LCB7IGlzOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXM6IGZ1bmN0aW9uIHRlc3RPYmplY3RJcygpIHtcblx0XHRcdHJldHVybiBPYmplY3QuaXMgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzU2hpbTtcbmlmICghT2JqZWN0LmtleXMpIHtcblx0Ly8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcblx0dmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xuXHR2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcblx0dmFyIGRvbnRFbnVtcyA9IFtcblx0XHQndG9TdHJpbmcnLFxuXHRcdCd0b0xvY2FsZVN0cmluZycsXG5cdFx0J3ZhbHVlT2YnLFxuXHRcdCdoYXNPd25Qcm9wZXJ0eScsXG5cdFx0J2lzUHJvdG90eXBlT2YnLFxuXHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0J2NvbnN0cnVjdG9yJ1xuXHRdO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHRcdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcblx0fTtcblx0dmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0XHQkYXBwbGljYXRpb25DYWNoZTogdHJ1ZSxcblx0XHQkY29uc29sZTogdHJ1ZSxcblx0XHQkZXh0ZXJuYWw6IHRydWUsXG5cdFx0JGZyYW1lOiB0cnVlLFxuXHRcdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdFx0JGZyYW1lczogdHJ1ZSxcblx0XHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdFx0JGlubmVyV2lkdGg6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmNoYW5nZTogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuZXJyb3I6IHRydWUsXG5cdFx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHRcdCRvdXRlcldpZHRoOiB0cnVlLFxuXHRcdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0XHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdFx0JHBhcmVudDogdHJ1ZSxcblx0XHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0XHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHRcdCRzY3JvbGxYOiB0cnVlLFxuXHRcdCRzY3JvbGxZOiB0cnVlLFxuXHRcdCRzZWxmOiB0cnVlLFxuXHRcdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdFx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHRcdCR3aW5kb3c6IHRydWVcblx0fTtcblx0dmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSgpKTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHRrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHRcdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHRcdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHRcdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdFx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRcdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRcdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoZUtleXM7XG5cdH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xuXG52YXIgb3JpZ0tleXMgPSBPYmplY3Qua2V5cztcbnZhciBrZXlzU2hpbSA9IG9yaWdLZXlzID8gZnVuY3Rpb24ga2V5cyhvKSB7IHJldHVybiBvcmlnS2V5cyhvKTsgfSA6IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxudmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHR2YXIgYXJncyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gYXJncyAmJiBhcmdzLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50c09iamVjdCA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1nZW5lcmF0b3ItZnVuY3Rpb24nKTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSByZXF1aXJlKCd3aGljaC10eXBlZC1hcnJheScpO1xudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG4vLyBTdG9yZSBhIGNvcHkgb2YgU2hhcmVkQXJyYXlCdWZmZXIgaW4gY2FzZSBpdCdzIGRlbGV0ZWQgZWxzZXdoZXJlXG52YXIgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IFNoYXJlZEFycmF5QnVmZmVyIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSc7XG59XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IFNoYXJlZEFycmF5QnVmZmVyQ29weSgpKTtcbiAgfVxuXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHk7XG59XG5leHBvcnRzLmlzU2hhcmVkQXJyYXlCdWZmZXIgPSBpc1NoYXJlZEFycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nO1xufVxuZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzTWFwSXRlcmF0b3IgPSBpc01hcEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc1NldEl0ZXJhdG9yID0gaXNTZXRJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJztcbn1cbmV4cG9ydHMuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlID0gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO1xuXG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgbnVtYmVyVmFsdWUpO1xufVxuZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3RyaW5nVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSk7XG59XG5leHBvcnRzLmlzQm9vbGVhbk9iamVjdCA9IGlzQm9vbGVhbk9iamVjdDtcblxuZnVuY3Rpb24gaXNCaWdJbnRPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBiaWdJbnRWYWx1ZSk7XG59XG5leHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBTeW1ib2xTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3ltYm9sVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8XG4gICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3ltYm9sT2JqZWN0KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0JveGVkUHJpbWl0aXZlID0gaXNCb3hlZFByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc0FycmF5QnVmZmVyKHZhbHVlKSB8fFxuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyO1xuXG5bJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zbGljZSgyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9zdXBwb3J0L3R5cGVzJyk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5leHBvcnRzLnR5cGVzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMudHlwZXMuaXNOYXRpdmVFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2dvcGQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZE5hbWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kTmFtZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG5hbWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmIChuYW1lID09PSB0eXBlZEFycmF5KSB7XG5cdFx0XHRcdFx0Zm91bmROYW1lID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmROYW1lO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghaXNUeXBlZEFycmF5KHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NzaWJsZU5hbWVzID0gW1xuXHQnQmlnSW50NjRBcnJheScsXG5cdCdCaWdVaW50NjRBcnJheScsXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDE2QXJyYXknLFxuXHQnSW50MzJBcnJheScsXG5cdCdJbnQ4QXJyYXknLFxuXHQnVWludDE2QXJyYXknLFxuXHQnVWludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheSdcbl07XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIG91dCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodHlwZW9mIGdbcG9zc2libGVOYW1lc1tpXV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG91dFtvdXQubGVuZ3RoXSA9IHBvc3NpYmxlTmFtZXNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXQ7XG59O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIGltcG9ydCBTd2lwZXIgZnJvbSAnc3dpcGVyJztcclxuLy8gaW1wb3J0IHtOYXZpZ2F0aW9uLCBQYWdpbmF0aW9ufSBmcm9tICdzd2lwZXIvbW9kdWxlcyc7XHJcblxyXG5jb25zdCBzd2lwZXIgPSBuZXcgU3dpcGVyKCcuc3dpcGVyJywge1xyXG5cdHNsaWRlc1BlclZpZXc6IDEsXHJcblx0c3BhY2VCZXR3ZWVuOiAxMCxcclxuXHRhdXRvcGxheToge1xyXG5cdFx0ZGVsYXk6IDMwMDAsXHJcblx0fSxcclxuXHRzcGVlZDogMjUwMCxcclxuXHRuYXZpZ2F0aW9uOiB7XHJcblx0XHRuZXh0RWw6ICcuc3dpcGVyLWJ1dHRvbi1uZXh0JyxcclxuXHRcdHByZXZFbDogJy5zd2lwZXItYnV0dG9uLXByZXYnLFxyXG5cdH0sXHJcblxyXG5cdGJyZWFrcG9pbnRzOiB7XHJcblx0XHQ2MDA6IHtcclxuXHRcdFx0c3BhY2VCZXR3ZWVuOiA1MCxcclxuXHRcdH0sXHJcblx0fVxyXG59KTtcclxuXHJcbmNvbnN0IHN3aXBlcjIgPSBuZXcgU3dpcGVyKCcuY2VydGlmaWNhdGVzX19zbGlkZXInLCB7XHJcblx0YXV0b3BsYXk6IHtcclxuXHRcdGRlbGF5OiAzMDAwLFxyXG5cdH0sXHJcblx0c3BlZWQ6IDI1MDAsXHJcblx0bmF2aWdhdGlvbjoge1xyXG5cdFx0bmV4dEVsOiAnLnN3aXBlci1idXR0b24tbmV4dCcsXHJcblx0XHRwcmV2RWw6ICcuc3dpcGVyLWJ1dHRvbi1wcmV2JyxcclxuXHR9LFxyXG5cdGJyZWFrcG9pbnRzOiB7XHJcblx0XHQzMjA6IHtcclxuXHRcdFx0c2xpZGVzUGVyVmlldzogMSxcclxuXHRcdH0sXHJcblx0XHQ1MjA6IHtcclxuXHRcdFx0c2xpZGVzUGVyVmlldzogMyxcclxuXHRcdH0sXHJcblx0XHQ5OTI6IHtcclxuXHRcdFx0c2xpZGVzUGVyVmlldzogNCxcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuRmFuY3lib3guYmluZChcIltkYXRhLWZhbmN5Ym94XVwiLCB7fSk7XHJcblxyXG5cclxuLy8gU3BvaWxlcnNcclxuY29uc3Qgc3BvaWxlcnNBcnJheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNwb2lsZXJzXScpO1xyXG5pZiAoc3BvaWxlcnNBcnJheS5sZW5ndGggPiAwKSB7XHJcblx0Ly8g0J/QvtC70YPRh9C10L3QuNC1INC+0LHRi9GH0L3Ri9GFINGB0L/QvtC50LvQtdGA0L7QslxyXG5cdGNvbnN0IHNwb2lsZXJzUmVndWxhciA9IEFycmF5LmZyb20oc3BvaWxlcnNBcnJheSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgc2VsZikge1xyXG5cdFx0cmV0dXJuICFpdGVtLmRhdGFzZXQuc3BvaWxlcnMuc3BsaXQoXCIsXCIpWzBdO1xyXG5cdH0pO1xyXG5cdC8vINCY0L3QuNGG0LjQsNC70LjQt9Cw0YbQuNGPINC+0LHRi9GH0L3Ri9GFINGB0L/QvtC50LvQtdGA0L7QslxyXG5cdGlmIChzcG9pbGVyc1JlZ3VsYXIubGVuZ3RoID4gMCkge1xyXG5cdFx0aW5pdFNwb2lsZXJzKHNwb2lsZXJzUmVndWxhcik7XHJcblx0fVxyXG5cclxuXHQvLyDQn9C+0LvRg9GH0LXQvdC40LUg0YHQv9C+0LnQu9C10YDQvtCyINGBINC80LXQtNC40LAg0LfQsNC/0YDQvtGB0LDQvNC4XHJcblx0Y29uc3Qgc3BvaWxlcnNNZWRpYSA9IEFycmF5LmZyb20oc3BvaWxlcnNBcnJheSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgc2VsZikge1xyXG5cdFx0cmV0dXJuIGl0ZW0uZGF0YXNldC5zcG9pbGVycy5zcGxpdChcIixcIilbMF07XHJcblx0fSk7XHJcblxyXG5cdC8vINCY0L3QuNGG0LjQsNC70LjQt9Cw0YbQuNGPINGB0L/QvtC50LvQtdGA0L7QsiDRgSDQvNC10LTQuNCwINC30LDQv9GA0L7RgdCw0LzQuFxyXG5cdGlmIChzcG9pbGVyc01lZGlhLmxlbmd0aCA+IDApIHtcclxuXHRcdGNvbnN0IGJyZWFrcG9pbnRzQXJyYXkgPSBbXTtcclxuXHRcdHNwb2lsZXJzTWVkaWEuZm9yRWFjaChpdGVtID0+IHtcclxuXHRcdFx0Y29uc3QgcGFyYW1zID0gaXRlbS5kYXRhc2V0LnNwb2lsZXJzO1xyXG5cdFx0XHRjb25zdCBicmVha3BvaW50ID0ge307XHJcblx0XHRcdGNvbnN0IHBhcmFtc0FycmF5ID0gcGFyYW1zLnNwbGl0KFwiLFwiKTtcclxuXHRcdFx0YnJlYWtwb2ludC52YWx1ZSA9IHBhcmFtc0FycmF5WzBdO1xyXG5cdFx0XHRicmVha3BvaW50LnR5cGUgPSBwYXJhbXNBcnJheVsxXSA/IHBhcmFtc0FycmF5WzFdLnRyaW0oKSA6IFwibWF4XCI7XHJcblx0XHRcdGJyZWFrcG9pbnQuaXRlbSA9IGl0ZW07XHJcblx0XHRcdGJyZWFrcG9pbnRzQXJyYXkucHVzaChicmVha3BvaW50KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vINCf0L7Qu9GD0YfQsNC10Lwg0YPQvdC40LrQsNC70YzQvdGL0LUg0LHRgNC10LnQutC/0L7QuNC90YLRi1xyXG5cdFx0bGV0IG1lZGlhUXVlcmllcyA9IGJyZWFrcG9pbnRzQXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcblx0XHRcdHJldHVybiAnKCcgKyBpdGVtLnR5cGUgKyBcIi13aWR0aDogXCIgKyBpdGVtLnZhbHVlICsgXCJweCksXCIgKyBpdGVtLnZhbHVlICsgJywnICsgaXRlbS50eXBlO1xyXG5cdFx0fSk7XHJcblx0XHRtZWRpYVF1ZXJpZXMgPSBtZWRpYVF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgc2VsZikge1xyXG5cdFx0XHRyZXR1cm4gc2VsZi5pbmRleE9mKGl0ZW0pID09PSBpbmRleDtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vINCg0LDQsdC+0YLQsNC10Lwg0YEg0LrQsNC20LTRi9C8INCx0YDQtdC50LrQv9C+0LjQvdGC0L7QvFxyXG5cdFx0bWVkaWFRdWVyaWVzLmZvckVhY2goYnJlYWtwb2ludCA9PiB7XHJcblx0XHRcdGNvbnN0IHBhcmFtc0FycmF5ID0gYnJlYWtwb2ludC5zcGxpdChcIixcIik7XHJcblx0XHRcdGNvbnN0IG1lZGlhQnJlYWtwb2ludCA9IHBhcmFtc0FycmF5WzFdO1xyXG5cdFx0XHRjb25zdCBtZWRpYVR5cGUgPSBwYXJhbXNBcnJheVsyXTtcclxuXHRcdFx0Y29uc3QgbWF0Y2hNZWRpYSA9IHdpbmRvdy5tYXRjaE1lZGlhKHBhcmFtc0FycmF5WzBdKTtcclxuXHJcblx0XHRcdC8vINCe0LHRitC10LrRgtGLINGBINC90YPQttC90YvQvNC4INGD0YHQu9C+0LLQuNGP0LzQuFxyXG5cdFx0XHRjb25zdCBzcG9pbGVyc0FycmF5ID0gYnJlYWtwb2ludHNBcnJheS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHRcdFx0XHRpZiAoaXRlbS52YWx1ZSA9PT0gbWVkaWFCcmVha3BvaW50ICYmIGl0ZW0udHlwZSA9PT0gbWVkaWFUeXBlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHQvLyDQodC+0LHRi9GC0LjQtVxyXG5cdFx0XHRtYXRjaE1lZGlhLmFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRpbml0U3BvaWxlcnMoc3BvaWxlcnNBcnJheSwgbWF0Y2hNZWRpYSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpbml0U3BvaWxlcnMoc3BvaWxlcnNBcnJheSwgbWF0Y2hNZWRpYSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vINCY0L3QuNGG0LjQsNC70LjQt9Cw0YbQuNGPXHJcblx0ZnVuY3Rpb24gaW5pdFNwb2lsZXJzKHNwb2lsZXJzQXJyYXksIG1hdGNoTWVkaWEgPSBmYWxzZSkge1xyXG5cdFx0c3BvaWxlcnNBcnJheS5mb3JFYWNoKHNwb2lsZXJzQmxvY2sgPT4ge1xyXG5cdFx0XHRzcG9pbGVyc0Jsb2NrID0gbWF0Y2hNZWRpYSA/IHNwb2lsZXJzQmxvY2suaXRlbSA6IHNwb2lsZXJzQmxvY2s7XHJcblx0XHRcdGlmIChtYXRjaE1lZGlhLm1hdGNoZXMgfHwgIW1hdGNoTWVkaWEpIHtcclxuXHRcdFx0XHRzcG9pbGVyc0Jsb2NrLmNsYXNzTGlzdC5hZGQoJ19pbml0Jyk7XHJcblx0XHRcdFx0aW5pdFNwb2lsZXJCb2R5KHNwb2lsZXJzQmxvY2spO1xyXG5cdFx0XHRcdHNwb2lsZXJzQmxvY2suYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHNldFNwb2lsZXJBY3Rpb24pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHNwb2lsZXJzQmxvY2suY2xhc3NMaXN0LnJlbW92ZSgnX2luaXQnKTtcclxuXHRcdFx0XHRpbml0U3BvaWxlckJvZHkoc3BvaWxlcnNCbG9jaywgZmFsc2UpO1xyXG5cdFx0XHRcdHNwb2lsZXJzQmxvY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHNldFNwb2lsZXJBY3Rpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vINCg0LDQsdC+0YLQsCDRgSDQutC+0L3RgtC10L3RgtC+0LxcclxuXHRmdW5jdGlvbiBpbml0U3BvaWxlckJvZHkoc3BvaWxlcnNCbG9jaywgaGlkZVNwb2lsZXJCb2R5ID0gdHJ1ZSkge1xyXG5cdFx0Y29uc3Qgc3BvaWxlclRpdGxlcyA9IHNwb2lsZXJzQmxvY2sucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc3BvaWxlcl0nKTtcclxuXHRcdGlmIChzcG9pbGVyVGl0bGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0c3BvaWxlclRpdGxlcy5mb3JFYWNoKHNwb2lsZXJUaXRsZSA9PiB7XHJcblx0XHRcdFx0aWYgKGhpZGVTcG9pbGVyQm9keSkge1xyXG5cdFx0XHRcdFx0c3BvaWxlclRpdGxlLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcclxuXHRcdFx0XHRcdGlmICghc3BvaWxlclRpdGxlLmNsYXNzTGlzdC5jb250YWlucygnX2FjdGl2ZScpKSB7XHJcblx0XHRcdFx0XHRcdHNwb2lsZXJUaXRsZS5uZXh0RWxlbWVudFNpYmxpbmcuaGlkZGVuID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3BvaWxlclRpdGxlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcclxuXHRcdFx0XHRcdHNwb2lsZXJUaXRsZS5uZXh0RWxlbWVudFNpYmxpbmcuaGlkZGVuID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldFNwb2lsZXJBY3Rpb24oZSkge1xyXG5cdFx0Y29uc3QgZWwgPSBlLnRhcmdldDtcclxuXHRcdGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3BvaWxlcicpIHx8IGVsLmNsb3Nlc3QoJ1tkYXRhLXNwb2lsZXJdJykpIHtcclxuXHRcdFx0Y29uc3Qgc3BvaWxlclRpdGxlID0gZWwuaGFzQXR0cmlidXRlKCdkYXRhLXNwb2lsZXInKSA/IGVsIDogZWwuY2xvc2VzdCgnW2RhdGEtc3BvaWxlcl0nKTtcclxuXHRcdFx0Y29uc3Qgc3BvaWxlcnNCbG9jayA9IHNwb2lsZXJUaXRsZS5jbG9zZXN0KCdbZGF0YS1zcG9pbGVyc10nKTtcclxuXHRcdFx0Y29uc3Qgb25lU3BvaWxlciA9IHNwb2lsZXJzQmxvY2suaGFzQXR0cmlidXRlKCdkYXRhLW9uZS1zcG9pbGVyJykgPyB0cnVlIDogZmFsc2U7XHJcblx0XHRcdGlmICghc3BvaWxlcnNCbG9jay5xdWVyeVNlbGVjdG9yQWxsKCcuX3NsaWRlJykubGVuZ3RoKSB7XHJcblx0XHRcdFx0aWYgKG9uZVNwb2lsZXIgJiYgIXNwb2lsZXJUaXRsZS5jbGFzc0xpc3QuY29udGFpbnMoJ19hY3RpdmUnKSkge1xyXG5cdFx0XHRcdFx0aGlkZVNwb2lsZXJzQm9keShzcG9pbGVyc0Jsb2NrKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c3BvaWxlclRpdGxlLmNsYXNzTGlzdC50b2dnbGUoJ19hY3RpdmUnKTtcclxuXHRcdFx0XHRfc2xpZGVUb2dnbGUoc3BvaWxlclRpdGxlLm5leHRFbGVtZW50U2libGluZywgNTAwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBoaWRlU3BvaWxlcnNCb2R5KHNwb2lsZXJzQmxvY2spIHtcclxuXHRcdGNvbnN0IHNwb2lsZXJBY3RpdmVUaXRsZSA9IHNwb2lsZXJzQmxvY2sucXVlcnlTZWxlY3RvcignW2RhdGEtc3BvaWxlcl0uX2FjdGl2ZScpO1xyXG5cdFx0aWYgKHNwb2lsZXJBY3RpdmVUaXRsZSkge1xyXG5cdFx0XHRzcG9pbGVyQWN0aXZlVGl0bGUuY2xhc3NMaXN0LnJlbW92ZSgnX2FjdGl2ZScpO1xyXG5cdFx0XHRfc2xpZGVVcChzcG9pbGVyQWN0aXZlVGl0bGUubmV4dEVsZW1lbnRTaWJsaW5nLCA1MDApO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuXHJcbi8vIFNsaWRlVG9nZ2xlXHJcbmxldCBfc2xpZGVVcCA9ICh0YXJnZXQsIGR1cmF0aW9uID0gNTAwKSA9PiB7XHJcblx0aWYgKCF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdfc2xpZGUnKSkge1xyXG5cdFx0dGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ19zbGlkZScpO1xyXG5cdFx0dGFyZ2V0LnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdoZWlnaHQsIG1hcmdpbiwgcGFkZGluZyc7XHJcblx0XHR0YXJnZXQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xyXG5cdFx0dGFyZ2V0LnN0eWxlLmhlaWdodCA9IHRhcmdldC5vZmZzZXRIZWlnaHQgKyAncHgnO1xyXG5cdFx0dGFyZ2V0Lm9mZnNldEhlaWdodDtcclxuXHRcdHRhcmdldC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG5cdFx0dGFyZ2V0LnN0eWxlLmhlaWdodCA9IDA7XHJcblx0XHR0YXJnZXQuc3R5bGUucGFkZGluZ1RvcCA9IDA7XHJcblx0XHR0YXJnZXQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IDA7XHJcblx0XHR0YXJnZXQuc3R5bGUubWFyZ2luVG9wID0gMDtcclxuXHRcdHRhcmdldC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAwO1xyXG5cdFx0d2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHR0YXJnZXQuaGlkZGVuID0gdHJ1ZTtcclxuXHRcdFx0dGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcclxuXHRcdFx0dGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwYWRkaW5nLXRvcCcpO1xyXG5cdFx0XHR0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BhZGRpbmctYm90dG9tJyk7XHJcblx0XHRcdHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnbWFyZ2luLXRvcCcpO1xyXG5cdFx0XHR0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ21hcmdpbi1ib3R0b20nKTtcclxuXHRcdFx0dGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdvdmVyZmxvdycpO1xyXG5cdFx0XHR0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zaXRpb24tZHVyYXRpb24nKTtcclxuXHRcdFx0dGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uLXByb3BlcnR5Jyk7XHJcblx0XHRcdHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdfc2xpZGUnKTtcclxuXHRcdH0sIGR1cmF0aW9uKTtcclxuXHR9XHJcbn1cclxubGV0IF9zbGlkZURvd24gPSAodGFyZ2V0LCBkdXJhdGlvbiA9IDUwMCkgPT4ge1xyXG5cdGlmICghdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnX3NsaWRlJykpIHtcclxuXHRcdHRhcmdldC5jbGFzc0xpc3QuYWRkKCdfc2xpZGUnKTtcclxuXHRcdGlmICh0YXJnZXQuaGlkZGVuKSB7XHJcblx0XHRcdHRhcmdldC5oaWRkZW4gPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGxldCBoZWlnaHQgPSB0YXJnZXQub2Zmc2V0SGVpZ2h0O1xyXG5cdFx0dGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcblx0XHR0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gMDtcclxuXHRcdHRhcmdldC5zdHlsZS5wYWRkaW5nVG9wID0gMDtcclxuXHRcdHRhcmdldC5zdHlsZS5wYWRkaW5nQm90dG9tID0gMDtcclxuXHRcdHRhcmdldC5zdHlsZS5tYXJnaW5Ub3AgPSAwO1xyXG5cdFx0dGFyZ2V0LnN0eWxlLm1hcmdpbkJvdHRvbSA9IDA7XHJcblx0XHR0YXJnZXQub2Zmc2V0SGVpZ2h0O1xyXG5cdFx0dGFyZ2V0LnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IFwiaGVpZ2h0LCBtYXJnaW4sIHBhZGRpbmdcIjtcclxuXHRcdHRhcmdldC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArICdtcyc7XHJcblx0XHR0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuXHRcdHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncGFkZGluZy10b3AnKTtcclxuXHRcdHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncGFkZGluZy1ib3R0b20nKTtcclxuXHRcdHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnbWFyZ2luLXRvcCcpO1xyXG5cdFx0dGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdtYXJnaW4tYm90dG9tJyk7XHJcblx0XHR3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnaGVpZ2h0Jyk7XHJcblx0XHRcdHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3ZlcmZsb3cnKTtcclxuXHRcdFx0dGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uLWR1cmF0aW9uJyk7XHJcblx0XHRcdHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbi1wcm9wZXJ0eScpO1xyXG5cdFx0XHR0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnX3NsaWRlJyk7XHJcblx0XHR9LCBkdXJhdGlvbik7XHJcblx0fVxyXG59XHJcbmxldCBfc2xpZGVUb2dnbGUgPSAodGFyZ2V0LCBkdXJhdGlvbiA9IDUwMCkgPT4ge1xyXG5cdGlmICh0YXJnZXQuaGlkZGVuKSB7XHJcblx0XHRyZXR1cm4gX3NsaWRlRG93bih0YXJnZXQsIGR1cmF0aW9uKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIF9zbGlkZVVwKHRhcmdldCwgZHVyYXRpb24pO1xyXG5cdH1cclxufVxyXG5cclxuXHJcbmltcG9ydCBJbnB1dG1hc2sgZnJvbSBcImlucHV0bWFzay9saWIvaW5wdXRtYXNrXCI7XHJcbmltcG9ydCBKdXN0VmFsaWRhdGUgZnJvbSBcImp1c3QtdmFsaWRhdGVcIjtcclxuIl0sIm5hbWVzIjpbInN3aXBlciIsIlN3aXBlciIsInNsaWRlc1BlclZpZXciLCJzcGFjZUJldHdlZW4iLCJhdXRvcGxheSIsImRlbGF5Iiwic3BlZWQiLCJuYXZpZ2F0aW9uIiwibmV4dEVsIiwicHJldkVsIiwiYnJlYWtwb2ludHMiLCJzd2lwZXIyIiwiRmFuY3lib3giLCJiaW5kIiwic3BvaWxlcnNBcnJheSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsImluaXRTcG9pbGVycyIsIm1hdGNoTWVkaWEiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJmb3JFYWNoIiwic3BvaWxlcnNCbG9jayIsIml0ZW0iLCJtYXRjaGVzIiwiY2xhc3NMaXN0IiwiYWRkIiwiaW5pdFNwb2lsZXJCb2R5IiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldFNwb2lsZXJBY3Rpb24iLCJyZW1vdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGlkZVNwb2lsZXJCb2R5Iiwic3BvaWxlclRpdGxlcyIsInNwb2lsZXJUaXRsZSIsInJlbW92ZUF0dHJpYnV0ZSIsImNvbnRhaW5zIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiaGlkZGVuIiwic2V0QXR0cmlidXRlIiwiZSIsImVsIiwidGFyZ2V0IiwiaGFzQXR0cmlidXRlIiwiY2xvc2VzdCIsIm9uZVNwb2lsZXIiLCJoaWRlU3BvaWxlcnNCb2R5IiwidG9nZ2xlIiwiX3NsaWRlVG9nZ2xlIiwicHJldmVudERlZmF1bHQiLCJzcG9pbGVyQWN0aXZlVGl0bGUiLCJxdWVyeVNlbGVjdG9yIiwiX3NsaWRlVXAiLCJzcG9pbGVyc1JlZ3VsYXIiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJpbmRleCIsInNlbGYiLCJkYXRhc2V0Iiwic3BvaWxlcnMiLCJzcGxpdCIsInNwb2lsZXJzTWVkaWEiLCJicmVha3BvaW50c0FycmF5IiwicGFyYW1zIiwiYnJlYWtwb2ludCIsInBhcmFtc0FycmF5IiwidmFsdWUiLCJ0eXBlIiwidHJpbSIsInB1c2giLCJtZWRpYVF1ZXJpZXMiLCJtYXAiLCJpbmRleE9mIiwibWVkaWFCcmVha3BvaW50IiwibWVkaWFUeXBlIiwid2luZG93IiwiYWRkTGlzdGVuZXIiLCJkdXJhdGlvbiIsInN0eWxlIiwidHJhbnNpdGlvblByb3BlcnR5IiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwib3ZlcmZsb3ciLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsInNldFRpbWVvdXQiLCJyZW1vdmVQcm9wZXJ0eSIsIl9zbGlkZURvd24iLCJJbnB1dG1hc2siLCJKdXN0VmFsaWRhdGUiXSwic291cmNlUm9vdCI6IiJ9